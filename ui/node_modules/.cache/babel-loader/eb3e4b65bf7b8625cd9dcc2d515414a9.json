{"ast":null,"code":"ace.define(\"ace/snippets/ruby\", [\"require\", \"exports\", \"module\"], function (require, exports, module) {\n  \"use strict\";\n\n  exports.snippetText = \"########################################\\n\\\n# Ruby snippets - for Rails, see below #\\n\\\n########################################\\n\\\n\\n\\\n# encoding for Ruby 1.9\\n\\\nsnippet enc\\n\\\n\t# encoding: utf-8\\n\\\n\\n\\\n# #!/usr/bin/env ruby\\n\\\nsnippet #!\\n\\\n\t#!/usr/bin/env ruby\\n\\\n\t# encoding: utf-8\\n\\\n\\n\\\n# New Block\\n\\\nsnippet =b\\n\\\n\t=begin rdoc\\n\\\n\t\t${1}\\n\\\n\t=end\\n\\\nsnippet y\\n\\\n\t:yields: ${1:arguments}\\n\\\nsnippet rb\\n\\\n\t#!/usr/bin/env ruby -wKU\\n\\\nsnippet beg\\n\\\n\tbegin\\n\\\n\t\t${3}\\n\\\n\trescue ${1:Exception} => ${2:e}\\n\\\n\tend\\n\\\n\\n\\\nsnippet req require\\n\\\n\trequire \\\"${1}\\\"${2}\\n\\\nsnippet #\\n\\\n\t# =>\\n\\\nsnippet end\\n\\\n\t__END__\\n\\\nsnippet case\\n\\\n\tcase ${1:object}\\n\\\n\twhen ${2:condition}\\n\\\n\t\t${3}\\n\\\n\tend\\n\\\nsnippet when\\n\\\n\twhen ${1:condition}\\n\\\n\t\t${2}\\n\\\nsnippet def\\n\\\n\tdef ${1:method_name}\\n\\\n\t\t${2}\\n\\\n\tend\\n\\\nsnippet deft\\n\\\n\tdef test_${1:case_name}\\n\\\n\t\t${2}\\n\\\n\tend\\n\\\nsnippet if\\n\\\n\tif ${1:condition}\\n\\\n\t\t${2}\\n\\\n\tend\\n\\\nsnippet ife\\n\\\n\tif ${1:condition}\\n\\\n\t\t${2}\\n\\\n\telse\\n\\\n\t\t${3}\\n\\\n\tend\\n\\\nsnippet elsif\\n\\\n\telsif ${1:condition}\\n\\\n\t\t${2}\\n\\\nsnippet unless\\n\\\n\tunless ${1:condition}\\n\\\n\t\t${2}\\n\\\n\tend\\n\\\nsnippet while\\n\\\n\twhile ${1:condition}\\n\\\n\t\t${2}\\n\\\n\tend\\n\\\nsnippet for\\n\\\n\tfor ${1:e} in ${2:c}\\n\\\n\t\t${3}\\n\\\n\tend\\n\\\nsnippet until\\n\\\n\tuntil ${1:condition}\\n\\\n\t\t${2}\\n\\\n\tend\\n\\\nsnippet cla class .. end\\n\\\n\tclass ${1:`substitute(Filename(), '\\\\(_\\\\|^\\\\)\\\\(.\\\\)', '\\\\u\\\\2', 'g')`}\\n\\\n\t\t${2}\\n\\\n\tend\\n\\\nsnippet cla class .. initialize .. end\\n\\\n\tclass ${1:`substitute(Filename(), '\\\\(_\\\\|^\\\\)\\\\(.\\\\)', '\\\\u\\\\2', 'g')`}\\n\\\n\t\tdef initialize(${2:args})\\n\\\n\t\t\t${3}\\n\\\n\t\tend\\n\\\n\tend\\n\\\nsnippet cla class .. < ParentClass .. initialize .. end\\n\\\n\tclass ${1:`substitute(Filename(), '\\\\(_\\\\|^\\\\)\\\\(.\\\\)', '\\\\u\\\\2', 'g')`} < ${2:ParentClass}\\n\\\n\t\tdef initialize(${3:args})\\n\\\n\t\t\t${4}\\n\\\n\t\tend\\n\\\n\tend\\n\\\nsnippet cla ClassName = Struct .. do .. end\\n\\\n\t${1:`substitute(Filename(), '\\\\(_\\\\|^\\\\)\\\\(.\\\\)', '\\\\u\\\\2', 'g')`} = Struct.new(:${2:attr_names}) do\\n\\\n\t\tdef ${3:method_name}\\n\\\n\t\t\t${4}\\n\\\n\t\tend\\n\\\n\tend\\n\\\nsnippet cla class BlankSlate .. initialize .. end\\n\\\n\tclass ${1:BlankSlate}\\n\\\n\t\tinstance_methods.each { |meth| undef_method(meth) unless meth =~ /\\\\A__/ }\\n\\\n\tend\\n\\\nsnippet cla class << self .. end\\n\\\n\tclass << ${1:self}\\n\\\n\t\t${2}\\n\\\n\tend\\n\\\n# class .. < DelegateClass .. initialize .. end\\n\\\nsnippet cla-\\n\\\n\tclass ${1:`substitute(Filename(), '\\\\(_\\\\|^\\\\)\\\\(.\\\\)', '\\\\u\\\\2', 'g')`} < DelegateClass(${2:ParentClass})\\n\\\n\t\tdef initialize(${3:args})\\n\\\n\t\t\tsuper(${4:del_obj})\\n\\\n\\n\\\n\t\t\t${5}\\n\\\n\t\tend\\n\\\n\tend\\n\\\nsnippet mod module .. end\\n\\\n\tmodule ${1:`substitute(Filename(), '\\\\(_\\\\|^\\\\)\\\\(.\\\\)', '\\\\u\\\\2', 'g')`}\\n\\\n\t\t${2}\\n\\\n\tend\\n\\\nsnippet mod module .. module_function .. end\\n\\\n\tmodule ${1:`substitute(Filename(), '\\\\(_\\\\|^\\\\)\\\\(.\\\\)', '\\\\u\\\\2', 'g')`}\\n\\\n\t\tmodule_function\\n\\\n\\n\\\n\t\t${2}\\n\\\n\tend\\n\\\nsnippet mod module .. ClassMethods .. end\\n\\\n\tmodule ${1:`substitute(Filename(), '\\\\(_\\\\|^\\\\)\\\\(.\\\\)', '\\\\u\\\\2', 'g')`}\\n\\\n\t\tmodule ClassMethods\\n\\\n\t\t\t${2}\\n\\\n\t\tend\\n\\\n\\n\\\n\t\tmodule InstanceMethods\\n\\\n\\n\\\n\t\tend\\n\\\n\\n\\\n\t\tdef self.included(receiver)\\n\\\n\t\t\treceiver.extend         ClassMethods\\n\\\n\t\t\treceiver.send :include, InstanceMethods\\n\\\n\t\tend\\n\\\n\tend\\n\\\n# attr_reader\\n\\\nsnippet r\\n\\\n\tattr_reader :${1:attr_names}\\n\\\n# attr_writer\\n\\\nsnippet w\\n\\\n\tattr_writer :${1:attr_names}\\n\\\n# attr_accessor\\n\\\nsnippet rw\\n\\\n\tattr_accessor :${1:attr_names}\\n\\\nsnippet atp\\n\\\n\tattr_protected :${1:attr_names}\\n\\\nsnippet ata\\n\\\n\tattr_accessible :${1:attr_names}\\n\\\n# include Enumerable\\n\\\nsnippet Enum\\n\\\n\tinclude Enumerable\\n\\\n\\n\\\n\tdef each(&block)\\n\\\n\t\t${1}\\n\\\n\tend\\n\\\n# include Comparable\\n\\\nsnippet Comp\\n\\\n\tinclude Comparable\\n\\\n\\n\\\n\tdef <=>(other)\\n\\\n\t\t${1}\\n\\\n\tend\\n\\\n# extend Forwardable\\n\\\nsnippet Forw-\\n\\\n\textend Forwardable\\n\\\n# def self\\n\\\nsnippet defs\\n\\\n\tdef self.${1:class_method_name}\\n\\\n\t\t${2}\\n\\\n\tend\\n\\\n# def method_missing\\n\\\nsnippet defmm\\n\\\n\tdef method_missing(meth, *args, &blk)\\n\\\n\t\t${1}\\n\\\n\tend\\n\\\nsnippet defd\\n\\\n\tdef_delegator :${1:@del_obj}, :${2:del_meth}, :${3:new_name}\\n\\\nsnippet defds\\n\\\n\tdef_delegators :${1:@del_obj}, :${2:del_methods}\\n\\\nsnippet am\\n\\\n\talias_method :${1:new_name}, :${2:old_name}\\n\\\nsnippet app\\n\\\n\tif __FILE__ == $PROGRAM_NAME\\n\\\n\t\t${1}\\n\\\n\tend\\n\\\n# usage_if()\\n\\\nsnippet usai\\n\\\n\tif ARGV.${1}\\n\\\n\t\tabort \\\"Usage: #{$PROGRAM_NAME} ${2:ARGS_GO_HERE}\\\"${3}\\n\\\n\tend\\n\\\n# usage_unless()\\n\\\nsnippet usau\\n\\\n\tunless ARGV.${1}\\n\\\n\t\tabort \\\"Usage: #{$PROGRAM_NAME} ${2:ARGS_GO_HERE}\\\"${3}\\n\\\n\tend\\n\\\nsnippet array\\n\\\n\tArray.new(${1:10}) { |${2:i}| ${3} }\\n\\\nsnippet hash\\n\\\n\tHash.new { |${1:hash}, ${2:key}| $1[$2] = ${3} }\\n\\\nsnippet file File.foreach() { |line| .. }\\n\\\n\tFile.foreach(${1:\\\"path/to/file\\\"}) { |${2:line}| ${3} }\\n\\\nsnippet file File.read()\\n\\\n\tFile.read(${1:\\\"path/to/file\\\"})${2}\\n\\\nsnippet Dir Dir.global() { |file| .. }\\n\\\n\tDir.glob(${1:\\\"dir/glob/*\\\"}) { |${2:file}| ${3} }\\n\\\nsnippet Dir Dir[\\\"..\\\"]\\n\\\n\tDir[${1:\\\"glob/**/*.rb\\\"}]${2}\\n\\\nsnippet dir\\n\\\n\tFilename.dirname(__FILE__)\\n\\\nsnippet deli\\n\\\n\tdelete_if { |${1:e}| ${2} }\\n\\\nsnippet fil\\n\\\n\tfill(${1:range}) { |${2:i}| ${3} }\\n\\\n# flatten_once()\\n\\\nsnippet flao\\n\\\n\tinject(Array.new) { |${1:arr}, ${2:a}| $1.push(*$2)}${3}\\n\\\nsnippet zip\\n\\\n\tzip(${1:enums}) { |${2:row}| ${3} }\\n\\\n# downto(0) { |n| .. }\\n\\\nsnippet dow\\n\\\n\tdownto(${1:0}) { |${2:n}| ${3} }\\n\\\nsnippet ste\\n\\\n\tstep(${1:2}) { |${2:n}| ${3} }\\n\\\nsnippet tim\\n\\\n\ttimes { |${1:n}| ${2} }\\n\\\nsnippet upt\\n\\\n\tupto(${1:1.0/0.0}) { |${2:n}| ${3} }\\n\\\nsnippet loo\\n\\\n\tloop { ${1} }\\n\\\nsnippet ea\\n\\\n\teach { |${1:e}| ${2} }\\n\\\nsnippet ead\\n\\\n\teach do |${1:e}|\\n\\\n\t\t${2}\\n\\\n\tend\\n\\\nsnippet eab\\n\\\n\teach_byte { |${1:byte}| ${2} }\\n\\\nsnippet eac- each_char { |chr| .. }\\n\\\n\teach_char { |${1:chr}| ${2} }\\n\\\nsnippet eac- each_cons(..) { |group| .. }\\n\\\n\teach_cons(${1:2}) { |${2:group}| ${3} }\\n\\\nsnippet eai\\n\\\n\teach_index { |${1:i}| ${2} }\\n\\\nsnippet eaid\\n\\\n\teach_index do |${1:i}|\\n\\\n\t\t${2}\\n\\\n\tend\\n\\\nsnippet eak\\n\\\n\teach_key { |${1:key}| ${2} }\\n\\\nsnippet eakd\\n\\\n\teach_key do |${1:key}|\\n\\\n\t\t${2}\\n\\\n\tend\\n\\\nsnippet eal\\n\\\n\teach_line { |${1:line}| ${2} }\\n\\\nsnippet eald\\n\\\n\teach_line do |${1:line}|\\n\\\n\t\t${2}\\n\\\n\tend\\n\\\nsnippet eap\\n\\\n\teach_pair { |${1:name}, ${2:val}| ${3} }\\n\\\nsnippet eapd\\n\\\n\teach_pair do |${1:name}, ${2:val}|\\n\\\n\t\t${3}\\n\\\n\tend\\n\\\nsnippet eas-\\n\\\n\teach_slice(${1:2}) { |${2:group}| ${3} }\\n\\\nsnippet easd-\\n\\\n\teach_slice(${1:2}) do |${2:group}|\\n\\\n\t\t${3}\\n\\\n\tend\\n\\\nsnippet eav\\n\\\n\teach_value { |${1:val}| ${2} }\\n\\\nsnippet eavd\\n\\\n\teach_value do |${1:val}|\\n\\\n\t\t${2}\\n\\\n\tend\\n\\\nsnippet eawi\\n\\\n\teach_with_index { |${1:e}, ${2:i}| ${3} }\\n\\\nsnippet eawid\\n\\\n\teach_with_index do |${1:e},${2:i}|\\n\\\n\t\t${3}\\n\\\n\tend\\n\\\nsnippet reve\\n\\\n\treverse_each { |${1:e}| ${2} }\\n\\\nsnippet reved\\n\\\n\treverse_each do |${1:e}|\\n\\\n\t\t${2}\\n\\\n\tend\\n\\\nsnippet inj\\n\\\n\tinject(${1:init}) { |${2:mem}, ${3:var}| ${4} }\\n\\\nsnippet injd\\n\\\n\tinject(${1:init}) do |${2:mem}, ${3:var}|\\n\\\n\t\t${4}\\n\\\n\tend\\n\\\nsnippet map\\n\\\n\tmap { |${1:e}| ${2} }\\n\\\nsnippet mapd\\n\\\n\tmap do |${1:e}|\\n\\\n\t\t${2}\\n\\\n\tend\\n\\\nsnippet mapwi-\\n\\\n\tenum_with_index.map { |${1:e}, ${2:i}| ${3} }\\n\\\nsnippet sor\\n\\\n\tsort { |a, b| ${1} }\\n\\\nsnippet sorb\\n\\\n\tsort_by { |${1:e}| ${2} }\\n\\\nsnippet ran\\n\\\n\tsort_by { rand }\\n\\\nsnippet all\\n\\\n\tall? { |${1:e}| ${2} }\\n\\\nsnippet any\\n\\\n\tany? { |${1:e}| ${2} }\\n\\\nsnippet cl\\n\\\n\tclassify { |${1:e}| ${2} }\\n\\\nsnippet col\\n\\\n\tcollect { |${1:e}| ${2} }\\n\\\nsnippet cold\\n\\\n\tcollect do |${1:e}|\\n\\\n\t\t${2}\\n\\\n\tend\\n\\\nsnippet det\\n\\\n\tdetect { |${1:e}| ${2} }\\n\\\nsnippet detd\\n\\\n\tdetect do |${1:e}|\\n\\\n\t\t${2}\\n\\\n\tend\\n\\\nsnippet fet\\n\\\n\tfetch(${1:name}) { |${2:key}| ${3} }\\n\\\nsnippet fin\\n\\\n\tfind { |${1:e}| ${2} }\\n\\\nsnippet find\\n\\\n\tfind do |${1:e}|\\n\\\n\t\t${2}\\n\\\n\tend\\n\\\nsnippet fina\\n\\\n\tfind_all { |${1:e}| ${2} }\\n\\\nsnippet finad\\n\\\n\tfind_all do |${1:e}|\\n\\\n\t\t${2}\\n\\\n\tend\\n\\\nsnippet gre\\n\\\n\tgrep(${1:/pattern/}) { |${2:match}| ${3} }\\n\\\nsnippet sub\\n\\\n\t${1:g}sub(${2:/pattern/}) { |${3:match}| ${4} }\\n\\\nsnippet sca\\n\\\n\tscan(${1:/pattern/}) { |${2:match}| ${3} }\\n\\\nsnippet scad\\n\\\n\tscan(${1:/pattern/}) do |${2:match}|\\n\\\n\t\t${3}\\n\\\n\tend\\n\\\nsnippet max\\n\\\n\tmax { |a, b| ${1} }\\n\\\nsnippet min\\n\\\n\tmin { |a, b| ${1} }\\n\\\nsnippet par\\n\\\n\tpartition { |${1:e}| ${2} }\\n\\\nsnippet pard\\n\\\n\tpartition do |${1:e}|\\n\\\n\t\t${2}\\n\\\n\tend\\n\\\nsnippet rej\\n\\\n\treject { |${1:e}| ${2} }\\n\\\nsnippet rejd\\n\\\n\treject do |${1:e}|\\n\\\n\t\t${2}\\n\\\n\tend\\n\\\nsnippet sel\\n\\\n\tselect { |${1:e}| ${2} }\\n\\\nsnippet seld\\n\\\n\tselect do |${1:e}|\\n\\\n\t\t${2}\\n\\\n\tend\\n\\\nsnippet lam\\n\\\n\tlambda { |${1:args}| ${2} }\\n\\\nsnippet doo\\n\\\n\tdo\\n\\\n\t\t${1}\\n\\\n\tend\\n\\\nsnippet dov\\n\\\n\tdo |${1:variable}|\\n\\\n\t\t${2}\\n\\\n\tend\\n\\\nsnippet :\\n\\\n\t:${1:key} => ${2:\\\"value\\\"}${3}\\n\\\nsnippet ope\\n\\\n\topen(${1:\\\"path/or/url/or/pipe\\\"}, \\\"${2:w}\\\") { |${3:io}| ${4} }\\n\\\n# path_from_here()\\n\\\nsnippet fpath\\n\\\n\tFile.join(File.dirname(__FILE__), *%2[${1:rel path here}])${2}\\n\\\n# unix_filter {}\\n\\\nsnippet unif\\n\\\n\tARGF.each_line${1} do |${2:line}|\\n\\\n\t\t${3}\\n\\\n\tend\\n\\\n# option_parse {}\\n\\\nsnippet optp\\n\\\n\trequire \\\"optparse\\\"\\n\\\n\\n\\\n\toptions = {${1:default => \\\"args\\\"}}\\n\\\n\\n\\\n\tARGV.options do |opts|\\n\\\n\t\topts.banner = \\\"Usage: #{File.basename($PROGRAM_NAME)}\\n\\\nsnippet opt\\n\\\n\topts.on( \\\"-${1:o}\\\", \\\"--${2:long-option-name}\\\", ${3:String},\\n\\\n\t         \\\"${4:Option description.}\\\") do |${5:opt}|\\n\\\n\t\t${6}\\n\\\n\tend\\n\\\nsnippet tc\\n\\\n\trequire \\\"test/unit\\\"\\n\\\n\\n\\\n\trequire \\\"${1:library_file_name}\\\"\\n\\\n\\n\\\n\tclass Test${2:$1} < Test::Unit::TestCase\\n\\\n\t\tdef test_${3:case_name}\\n\\\n\t\t\t${4}\\n\\\n\t\tend\\n\\\n\tend\\n\\\nsnippet ts\\n\\\n\trequire \\\"test/unit\\\"\\n\\\n\\n\\\n\trequire \\\"tc_${1:test_case_file}\\\"\\n\\\n\trequire \\\"tc_${2:test_case_file}\\\"${3}\\n\\\nsnippet as\\n\\\n\tassert ${1:test}, \\\"${2:Failure message.}\\\"${3}\\n\\\nsnippet ase\\n\\\n\tassert_equal ${1:expected}, ${2:actual}${3}\\n\\\nsnippet asne\\n\\\n\tassert_not_equal ${1:unexpected}, ${2:actual}${3}\\n\\\nsnippet asid\\n\\\n\tassert_in_delta ${1:expected_float}, ${2:actual_float}, ${3:2 ** -20}${4}\\n\\\nsnippet asio\\n\\\n\tassert_instance_of ${1:ExpectedClass}, ${2:actual_instance}${3}\\n\\\nsnippet asko\\n\\\n\tassert_kind_of ${1:ExpectedKind}, ${2:actual_instance}${3}\\n\\\nsnippet asn\\n\\\n\tassert_nil ${1:instance}${2}\\n\\\nsnippet asnn\\n\\\n\tassert_not_nil ${1:instance}${2}\\n\\\nsnippet asm\\n\\\n\tassert_match /${1:expected_pattern}/, ${2:actual_string}${3}\\n\\\nsnippet asnm\\n\\\n\tassert_no_match /${1:unexpected_pattern}/, ${2:actual_string}${3}\\n\\\nsnippet aso\\n\\\n\tassert_operator ${1:left}, :${2:operator}, ${3:right}${4}\\n\\\nsnippet asr\\n\\\n\tassert_raise ${1:Exception} { ${2} }\\n\\\nsnippet asrd\\n\\\n\tassert_raise ${1:Exception} do\\n\\\n\t\t${2}\\n\\\n\tend\\n\\\nsnippet asnr\\n\\\n\tassert_nothing_raised ${1:Exception} { ${2} }\\n\\\nsnippet asnrd\\n\\\n\tassert_nothing_raised ${1:Exception} do\\n\\\n\t\t${2}\\n\\\n\tend\\n\\\nsnippet asrt\\n\\\n\tassert_respond_to ${1:object}, :${2:method}${3}\\n\\\nsnippet ass assert_same(..)\\n\\\n\tassert_same ${1:expected}, ${2:actual}${3}\\n\\\nsnippet ass assert_send(..)\\n\\\n\tassert_send [${1:object}, :${2:message}, ${3:args}]${4}\\n\\\nsnippet asns\\n\\\n\tassert_not_same ${1:unexpected}, ${2:actual}${3}\\n\\\nsnippet ast\\n\\\n\tassert_throws :${1:expected} { ${2} }\\n\\\nsnippet astd\\n\\\n\tassert_throws :${1:expected} do\\n\\\n\t\t${2}\\n\\\n\tend\\n\\\nsnippet asnt\\n\\\n\tassert_nothing_thrown { ${1} }\\n\\\nsnippet asntd\\n\\\n\tassert_nothing_thrown do\\n\\\n\t\t${1}\\n\\\n\tend\\n\\\nsnippet fl\\n\\\n\tflunk \\\"${1:Failure message.}\\\"${2}\\n\\\n# Benchmark.bmbm do .. end\\n\\\nsnippet bm-\\n\\\n\tTESTS = ${1:10_000}\\n\\\n\tBenchmark.bmbm do |results|\\n\\\n\t\t${2}\\n\\\n\tend\\n\\\nsnippet rep\\n\\\n\tresults.report(\\\"${1:name}:\\\") { TESTS.times { ${2} }}\\n\\\n# Marshal.dump(.., file)\\n\\\nsnippet Md\\n\\\n\tFile.open(${1:\\\"path/to/file.dump\\\"}, \\\"wb\\\") { |${2:file}| Marshal.dump(${3:obj}, $2) }${4}\\n\\\n# Mashal.load(obj)\\n\\\nsnippet Ml\\n\\\n\tFile.open(${1:\\\"path/to/file.dump\\\"}, \\\"rb\\\") { |${2:file}| Marshal.load($2) }${3}\\n\\\n# deep_copy(..)\\n\\\nsnippet deec\\n\\\n\tMarshal.load(Marshal.dump(${1:obj_to_copy}))${2}\\n\\\nsnippet Pn-\\n\\\n\tPStore.new(${1:\\\"file_name.pstore\\\"})${2}\\n\\\nsnippet tra\\n\\\n\ttransaction(${1:true}) { ${2} }\\n\\\n# xmlread(..)\\n\\\nsnippet xml-\\n\\\n\tREXML::Document.new(File.read(${1:\\\"path/to/file\\\"}))${2}\\n\\\n# xpath(..) { .. }\\n\\\nsnippet xpa\\n\\\n\telements.each(${1:\\\"//Xpath\\\"}) do |${2:node}|\\n\\\n\t\t${3}\\n\\\n\tend\\n\\\n# class_from_name()\\n\\\nsnippet clafn\\n\\\n\tsplit(\\\"::\\\").inject(Object) { |par, const| par.const_get(const) }\\n\\\n# singleton_class()\\n\\\nsnippet sinc\\n\\\n\tclass << self; self end\\n\\\nsnippet nam\\n\\\n\tnamespace :${1:`Filename()`} do\\n\\\n\t\t${2}\\n\\\n\tend\\n\\\nsnippet tas\\n\\\n\tdesc \\\"${1:Task description}\\\"\\n\\\n\ttask :${2:task_name => [:dependent, :tasks]} do\\n\\\n\t\t${3}\\n\\\n\tend\\n\\\n# block\\n\\\nsnippet b\\n\\\n\t{ |${1:var}| ${2} }\\n\\\nsnippet begin\\n\\\n\tbegin\\n\\\n\t\traise 'A test exception.'\\n\\\n\trescue Exception => e\\n\\\n\t\tputs e.message\\n\\\n\t\tputs e.backtrace.inspect\\n\\\n\telse\\n\\\n\t\t# other exception\\n\\\n\tensure\\n\\\n\t\t# always executed\\n\\\n\tend\\n\\\n\\n\\\n#debugging\\n\\\nsnippet debug\\n\\\n\trequire 'ruby-debug'; debugger; true;\\n\\\nsnippet pry\\n\\\n\trequire 'pry'; binding.pry\\n\\\n\\n\\\n#############################################\\n\\\n# Rails snippets - for pure Ruby, see above #\\n\\\n#############################################\\n\\\nsnippet art\\n\\\n\tassert_redirected_to ${1::action => \\\"${2:index}\\\"}\\n\\\nsnippet artnp\\n\\\n\tassert_redirected_to ${1:parent}_${2:child}_path(${3:@$1}, ${4:@$2})\\n\\\nsnippet artnpp\\n\\\n\tassert_redirected_to ${1:parent}_${2:child}_path(${3:@$1})\\n\\\nsnippet artp\\n\\\n\tassert_redirected_to ${1:model}_path(${2:@$1})\\n\\\nsnippet artpp\\n\\\n\tassert_redirected_to ${1:model}s_path\\n\\\nsnippet asd\\n\\\n\tassert_difference \\\"${1:Model}.${2:count}\\\", $1 do\\n\\\n\t\t${3}\\n\\\n\tend\\n\\\nsnippet asnd\\n\\\n\tassert_no_difference \\\"${1:Model}.${2:count}\\\" do\\n\\\n\t\t${3}\\n\\\n\tend\\n\\\nsnippet asre\\n\\\n\tassert_response :${1:success}, @response.body${2}\\n\\\nsnippet asrj\\n\\\n\tassert_rjs :${1:replace}, \\\"${2:dom id}\\\"\\n\\\nsnippet ass assert_select(..)\\n\\\n\tassert_select '${1:path}', :${2:text} => '${3:inner_html' ${4:do}\\n\\\nsnippet bf\\n\\\n\tbefore_filter :${1:method}\\n\\\nsnippet bt\\n\\\n\tbelongs_to :${1:association}\\n\\\nsnippet crw\\n\\\n\tcattr_accessor :${1:attr_names}\\n\\\nsnippet defcreate\\n\\\n\tdef create\\n\\\n\t\t@${1:model_class_name} = ${2:ModelClassName}.new(params[:$1])\\n\\\n\\n\\\n\t\trespond_to do |wants|\\n\\\n\t\t\tif @$1.save\\n\\\n\t\t\t\tflash[:notice] = '$2 was successfully created.'\\n\\\n\t\t\t\twants.html { redirect_to(@$1) }\\n\\\n\t\t\t\twants.xml  { render :xml => @$1, :status => :created, :location => @$1 }\\n\\\n\t\t\telse\\n\\\n\t\t\t\twants.html { render :action => \\\"new\\\" }\\n\\\n\t\t\t\twants.xml  { render :xml => @$1.errors, :status => :unprocessable_entity }\\n\\\n\t\t\tend\\n\\\n\t\tend\\n\\\n\tend${3}\\n\\\nsnippet defdestroy\\n\\\n\tdef destroy\\n\\\n\t\t@${1:model_class_name} = ${2:ModelClassName}.find(params[:id])\\n\\\n\t\t@$1.destroy\\n\\\n\\n\\\n\t\trespond_to do |wants|\\n\\\n\t\t\twants.html { redirect_to($1s_url) }\\n\\\n\t\t\twants.xml  { head :ok }\\n\\\n\t\tend\\n\\\n\tend${3}\\n\\\nsnippet defedit\\n\\\n\tdef edit\\n\\\n\t\t@${1:model_class_name} = ${2:ModelClassName}.find(params[:id])\\n\\\n\tend\\n\\\nsnippet defindex\\n\\\n\tdef index\\n\\\n\t\t@${1:model_class_name} = ${2:ModelClassName}.all\\n\\\n\\n\\\n\t\trespond_to do |wants|\\n\\\n\t\t\twants.html # index.html.erb\\n\\\n\t\t\twants.xml  { render :xml => @$1s }\\n\\\n\t\tend\\n\\\n\tend${3}\\n\\\nsnippet defnew\\n\\\n\tdef new\\n\\\n\t\t@${1:model_class_name} = ${2:ModelClassName}.new\\n\\\n\\n\\\n\t\trespond_to do |wants|\\n\\\n\t\t\twants.html # new.html.erb\\n\\\n\t\t\twants.xml  { render :xml => @$1 }\\n\\\n\t\tend\\n\\\n\tend${3}\\n\\\nsnippet defshow\\n\\\n\tdef show\\n\\\n\t\t@${1:model_class_name} = ${2:ModelClassName}.find(params[:id])\\n\\\n\\n\\\n\t\trespond_to do |wants|\\n\\\n\t\t\twants.html # show.html.erb\\n\\\n\t\t\twants.xml  { render :xml => @$1 }\\n\\\n\t\tend\\n\\\n\tend${3}\\n\\\nsnippet defupdate\\n\\\n\tdef update\\n\\\n\t\t@${1:model_class_name} = ${2:ModelClassName}.find(params[:id])\\n\\\n\\n\\\n\t\trespond_to do |wants|\\n\\\n\t\t\tif @$1.update_attributes(params[:$1])\\n\\\n\t\t\t\tflash[:notice] = '$2 was successfully updated.'\\n\\\n\t\t\t\twants.html { redirect_to(@$1) }\\n\\\n\t\t\t\twants.xml  { head :ok }\\n\\\n\t\t\telse\\n\\\n\t\t\t\twants.html { render :action => \\\"edit\\\" }\\n\\\n\t\t\t\twants.xml  { render :xml => @$1.errors, :status => :unprocessable_entity }\\n\\\n\t\t\tend\\n\\\n\t\tend\\n\\\n\tend${3}\\n\\\nsnippet flash\\n\\\n\tflash[:${1:notice}] = \\\"${2}\\\"\\n\\\nsnippet habtm\\n\\\n\thas_and_belongs_to_many :${1:object}, :join_table => \\\"${2:table_name}\\\", :foreign_key => \\\"${3}_id\\\"${4}\\n\\\nsnippet hm\\n\\\n\thas_many :${1:object}\\n\\\nsnippet hmd\\n\\\n\thas_many :${1:other}s, :class_name => \\\"${2:$1}\\\", :foreign_key => \\\"${3:$1}_id\\\", :dependent => :destroy${4}\\n\\\nsnippet hmt\\n\\\n\thas_many :${1:object}, :through => :${2:object}\\n\\\nsnippet ho\\n\\\n\thas_one :${1:object}\\n\\\nsnippet i18\\n\\\n\tI18n.t('${1:type.key}')${2}\\n\\\nsnippet ist\\n\\\n\t<%= image_submit_tag(\\\"${1:agree.png}\\\", :id => \\\"${2:id}\\\"${3} %>\\n\\\nsnippet log\\n\\\n\tRails.logger.${1:debug} ${2}\\n\\\nsnippet log2\\n\\\n\tRAILS_DEFAULT_LOGGER.${1:debug} ${2}\\n\\\nsnippet logd\\n\\\n\tlogger.debug { \\\"${1:message}\\\" }${2}\\n\\\nsnippet loge\\n\\\n\tlogger.error { \\\"${1:message}\\\" }${2}\\n\\\nsnippet logf\\n\\\n\tlogger.fatal { \\\"${1:message}\\\" }${2}\\n\\\nsnippet logi\\n\\\n\tlogger.info { \\\"${1:message}\\\" }${2}\\n\\\nsnippet logw\\n\\\n\tlogger.warn { \\\"${1:message}\\\" }${2}\\n\\\nsnippet mapc\\n\\\n\t${1:map}.${2:connect} '${3:controller/:action/:id}'\\n\\\nsnippet mapca\\n\\\n\t${1:map}.catch_all \\\"*${2:anything}\\\", :controller => \\\"${3:default}\\\", :action => \\\"${4:error}\\\"${5}\\n\\\nsnippet mapr\\n\\\n\t${1:map}.resource :${2:resource}\\n\\\nsnippet maprs\\n\\\n\t${1:map}.resources :${2:resource}\\n\\\nsnippet mapwo\\n\\\n\t${1:map}.with_options :${2:controller} => '${3:thing}' do |$3|\\n\\\n\t\t${4}\\n\\\n\tend\\n\\\nsnippet mbs\\n\\\n\tbefore_save :${1:method}\\n\\\nsnippet mcht\\n\\\n\tchange_table :${1:table_name} do |t|\\n\\\n\t\t${2}\\n\\\n\tend\\n\\\nsnippet mp\\n\\\n\tmap(&:${1:id})\\n\\\nsnippet mrw\\n\\\n\tmattr_accessor :${1:attr_names}\\n\\\nsnippet oa\\n\\\n\torder(\\\"${1:field}\\\")\\n\\\nsnippet od\\n\\\n\torder(\\\"${1:field} DESC\\\")\\n\\\nsnippet pa\\n\\\n\tparams[:${1:id}]${2}\\n\\\nsnippet ra\\n\\\n\trender :action => \\\"${1:action}\\\"\\n\\\nsnippet ral\\n\\\n\trender :action => \\\"${1:action}\\\", :layout => \\\"${2:layoutname}\\\"\\n\\\nsnippet rest\\n\\\n\trespond_to do |wants|\\n\\\n\t\twants.${1:html} { ${2} }\\n\\\n\tend\\n\\\nsnippet rf\\n\\\n\trender :file => \\\"${1:filepath}\\\"\\n\\\nsnippet rfu\\n\\\n\trender :file => \\\"${1:filepath}\\\", :use_full_path => ${2:false}\\n\\\nsnippet ri\\n\\\n\trender :inline => \\\"${1:<%= 'hello' %>}\\\"\\n\\\nsnippet ril\\n\\\n\trender :inline => \\\"${1:<%= 'hello' %>}\\\", :locals => { ${2::name} => \\\"${3:value}\\\"${4} }\\n\\\nsnippet rit\\n\\\n\trender :inline => \\\"${1:<%= 'hello' %>}\\\", :type => ${2::rxml}\\n\\\nsnippet rjson\\n\\\n\trender :json => ${1:text to render}\\n\\\nsnippet rl\\n\\\n\trender :layout => \\\"${1:layoutname}\\\"\\n\\\nsnippet rn\\n\\\n\trender :nothing => ${1:true}\\n\\\nsnippet rns\\n\\\n\trender :nothing => ${1:true}, :status => ${2:401}\\n\\\nsnippet rp\\n\\\n\trender :partial => \\\"${1:item}\\\"\\n\\\nsnippet rpc\\n\\\n\trender :partial => \\\"${1:item}\\\", :collection => ${2:@$1s}\\n\\\nsnippet rpl\\n\\\n\trender :partial => \\\"${1:item}\\\", :locals => { :${2:$1} => ${3:@$1}\\n\\\nsnippet rpo\\n\\\n\trender :partial => \\\"${1:item}\\\", :object => ${2:@$1}\\n\\\nsnippet rps\\n\\\n\trender :partial => \\\"${1:item}\\\", :status => ${2:500}\\n\\\nsnippet rt\\n\\\n\trender :text => \\\"${1:text to render}\\\"\\n\\\nsnippet rtl\\n\\\n\trender :text => \\\"${1:text to render}\\\", :layout => \\\"${2:layoutname}\\\"\\n\\\nsnippet rtlt\\n\\\n\trender :text => \\\"${1:text to render}\\\", :layout => ${2:true}\\n\\\nsnippet rts\\n\\\n\trender :text => \\\"${1:text to render}\\\", :status => ${2:401}\\n\\\nsnippet ru\\n\\\n\trender :update do |${1:page}|\\n\\\n\t\t$1.${2}\\n\\\n\tend\\n\\\nsnippet rxml\\n\\\n\trender :xml => ${1:text to render}\\n\\\nsnippet sc\\n\\\n\tscope :${1:name}, :where(:@${2:field} => ${3:value})\\n\\\nsnippet sl\\n\\\n\tscope :${1:name}, lambda do |${2:value}|\\n\\\n\t\twhere(\\\"${3:field = ?}\\\", ${4:bind var})\\n\\\n\tend\\n\\\nsnippet sha1\\n\\\n\tDigest::SHA1.hexdigest(${1:string})\\n\\\nsnippet sweeper\\n\\\n\tclass ${1:ModelClassName}Sweeper < ActionController::Caching::Sweeper\\n\\\n\t\tobserve $1\\n\\\n\\n\\\n\t\tdef after_save(${2:model_class_name})\\n\\\n\t\t\texpire_cache($2)\\n\\\n\t\tend\\n\\\n\\n\\\n\t\tdef after_destroy($2)\\n\\\n\t\t\texpire_cache($2)\\n\\\n\t\tend\\n\\\n\\n\\\n\t\tdef expire_cache($2)\\n\\\n\t\t\texpire_page\\n\\\n\t\tend\\n\\\n\tend\\n\\\nsnippet tcb\\n\\\n\tt.boolean :${1:title}\\n\\\n\t${2}\\n\\\nsnippet tcbi\\n\\\n\tt.binary :${1:title}, :limit => ${2:2}.megabytes\\n\\\n\t${3}\\n\\\nsnippet tcd\\n\\\n\tt.decimal :${1:title}, :precision => ${2:10}, :scale => ${3:2}\\n\\\n\t${4}\\n\\\nsnippet tcda\\n\\\n\tt.date :${1:title}\\n\\\n\t${2}\\n\\\nsnippet tcdt\\n\\\n\tt.datetime :${1:title}\\n\\\n\t${2}\\n\\\nsnippet tcf\\n\\\n\tt.float :${1:title}\\n\\\n\t${2}\\n\\\nsnippet tch\\n\\\n\tt.change :${1:name}, :${2:string}, :${3:limit} => ${4:80}\\n\\\n\t${5}\\n\\\nsnippet tci\\n\\\n\tt.integer :${1:title}\\n\\\n\t${2}\\n\\\nsnippet tcl\\n\\\n\tt.integer :lock_version, :null => false, :default => 0\\n\\\n\t${1}\\n\\\nsnippet tcr\\n\\\n\tt.references :${1:taggable}, :polymorphic => { :default => '${2:Photo}' }\\n\\\n\t${3}\\n\\\nsnippet tcs\\n\\\n\tt.string :${1:title}\\n\\\n\t${2}\\n\\\nsnippet tct\\n\\\n\tt.text :${1:title}\\n\\\n\t${2}\\n\\\nsnippet tcti\\n\\\n\tt.time :${1:title}\\n\\\n\t${2}\\n\\\nsnippet tcts\\n\\\n\tt.timestamp :${1:title}\\n\\\n\t${2}\\n\\\nsnippet tctss\\n\\\n\tt.timestamps\\n\\\n\t${1}\\n\\\nsnippet va\\n\\\n\tvalidates_associated :${1:attribute}\\n\\\nsnippet vao\\n\\\n\tvalidates_acceptance_of :${1:terms}\\n\\\nsnippet vc\\n\\\n\tvalidates_confirmation_of :${1:attribute}\\n\\\nsnippet ve\\n\\\n\tvalidates_exclusion_of :${1:attribute}, :in => ${2:%w( mov avi )}\\n\\\nsnippet vf\\n\\\n\tvalidates_format_of :${1:attribute}, :with => /${2:regex}/\\n\\\nsnippet vi\\n\\\n\tvalidates_inclusion_of :${1:attribute}, :in => %w(${2: mov avi })\\n\\\nsnippet vl\\n\\\n\tvalidates_length_of :${1:attribute}, :within => ${2:3}..${3:20}\\n\\\nsnippet vn\\n\\\n\tvalidates_numericality_of :${1:attribute}\\n\\\nsnippet vpo\\n\\\n\tvalidates_presence_of :${1:attribute}\\n\\\nsnippet vu\\n\\\n\tvalidates_uniqueness_of :${1:attribute}\\n\\\nsnippet wants\\n\\\n\twants.${1:js|xml|html} { ${2} }\\n\\\nsnippet wc\\n\\\n\twhere(${1:\\\"conditions\\\"}${2:, bind_var})\\n\\\nsnippet wh\\n\\\n\twhere(${1:field} => ${2:value})\\n\\\nsnippet xdelete\\n\\\n\txhr :delete, :${1:destroy}, :id => ${2:1}${3}\\n\\\nsnippet xget\\n\\\n\txhr :get, :${1:show}, :id => ${2:1}${3}\\n\\\nsnippet xpost\\n\\\n\txhr :post, :${1:create}, :${2:object} => { ${3} }\\n\\\nsnippet xput\\n\\\n\txhr :put, :${1:update}, :id => ${2:1}, :${3:object} => { ${4} }${5}\\n\\\nsnippet test\\n\\\n\ttest \\\"should ${1:do something}\\\" do\\n\\\n\t\t${2}\\n\\\n\tend\\n\\\n#migrations\\n\\\nsnippet mac\\n\\\n\tadd_column :${1:table_name}, :${2:column_name}, :${3:data_type}\\n\\\nsnippet mrc\\n\\\n\tremove_column :${1:table_name}, :${2:column_name}\\n\\\nsnippet mrnc\\n\\\n\trename_column :${1:table_name}, :${2:old_column_name}, :${3:new_column_name}\\n\\\nsnippet mcc\\n\\\n\tchange_column :${1:table}, :${2:column}, :${3:type}\\n\\\nsnippet mccc\\n\\\n\tt.column :${1:title}, :${2:string}\\n\\\nsnippet mct\\n\\\n\tcreate_table :${1:table_name} do |t|\\n\\\n\t\tt.column :${2:name}, :${3:type}\\n\\\n\tend\\n\\\nsnippet migration\\n\\\n\tclass ${1:class_name} < ActiveRecord::Migration\\n\\\n\t\tdef self.up\\n\\\n\t\t\t${2}\\n\\\n\t\tend\\n\\\n\\n\\\n\t\tdef self.down\\n\\\n\t\tend\\n\\\n\tend\\n\\\n\\n\\\nsnippet trc\\n\\\n\tt.remove :${1:column}\\n\\\nsnippet tre\\n\\\n\tt.rename :${1:old_column_name}, :${2:new_column_name}\\n\\\n\t${3}\\n\\\nsnippet tref\\n\\\n\tt.references :${1:model}\\n\\\n\\n\\\n#rspec\\n\\\nsnippet it\\n\\\n\tit \\\"${1:spec_name}\\\" do\\n\\\n\t\t${2}\\n\\\n\tend\\n\\\nsnippet itp\\n\\\n\tit \\\"${1:spec_name}\\\"\\n\\\n\t${2}\\n\\\nsnippet desc\\n\\\n\tdescribe ${1:class_name} do\\n\\\n\t\t${2}\\n\\\n\tend\\n\\\nsnippet cont\\n\\\n\tcontext \\\"${1:message}\\\" do\\n\\\n\t\t${2}\\n\\\n\tend\\n\\\nsnippet bef\\n\\\n\tbefore :${1:each} do\\n\\\n\t\t${2}\\n\\\n\tend\\n\\\nsnippet aft\\n\\\n\tafter :${1:each} do\\n\\\n\t\t${2}\\n\\\n\tend\\n\\\n\";\n  exports.scope = \"ruby\";\n});\n\n(function () {\n  ace.require([\"ace/snippets/ruby\"], function (m) {\n    if (typeof module == \"object\" && typeof exports == \"object\" && module) {\n      module.exports = m;\n    }\n  });\n})();","map":{"version":3,"sources":["/home/magoo/projects/keyrier-json/node_modules/ace-builds/src-noconflict/snippets/ruby.js"],"names":["ace","define","require","exports","module","snippetText","scope","m"],"mappings":"AAAAA,GAAG,CAACC,MAAJ,CAAW,mBAAX,EAA+B,CAAC,SAAD,EAAW,SAAX,EAAqB,QAArB,CAA/B,EAA+D,UAASC,OAAT,EAAkBC,OAAlB,EAA2BC,MAA3B,EAAmC;AAClG;;AAEAD,EAAAA,OAAO,CAACE,WAAR,GAAsB;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;CAAtB;AAi6BAF,EAAAA,OAAO,CAACG,KAAR,GAAgB,MAAhB;AAEC,CAt6BD;;AAs6BmB,CAAC,YAAW;AACXN,EAAAA,GAAG,CAACE,OAAJ,CAAY,CAAC,mBAAD,CAAZ,EAAmC,UAASK,CAAT,EAAY;AAC3C,QAAI,OAAOH,MAAP,IAAiB,QAAjB,IAA6B,OAAOD,OAAP,IAAkB,QAA/C,IAA2DC,MAA/D,EAAuE;AACnEA,MAAAA,MAAM,CAACD,OAAP,GAAiBI,CAAjB;AACH;AACJ,GAJD;AAKH,CANE","sourcesContent":["ace.define(\"ace/snippets/ruby\",[\"require\",\"exports\",\"module\"], function(require, exports, module) {\n\"use strict\";\n\nexports.snippetText = \"########################################\\n\\\n# Ruby snippets - for Rails, see below #\\n\\\n########################################\\n\\\n\\n\\\n# encoding for Ruby 1.9\\n\\\nsnippet enc\\n\\\n\t# encoding: utf-8\\n\\\n\\n\\\n# #!/usr/bin/env ruby\\n\\\nsnippet #!\\n\\\n\t#!/usr/bin/env ruby\\n\\\n\t# encoding: utf-8\\n\\\n\\n\\\n# New Block\\n\\\nsnippet =b\\n\\\n\t=begin rdoc\\n\\\n\t\t${1}\\n\\\n\t=end\\n\\\nsnippet y\\n\\\n\t:yields: ${1:arguments}\\n\\\nsnippet rb\\n\\\n\t#!/usr/bin/env ruby -wKU\\n\\\nsnippet beg\\n\\\n\tbegin\\n\\\n\t\t${3}\\n\\\n\trescue ${1:Exception} => ${2:e}\\n\\\n\tend\\n\\\n\\n\\\nsnippet req require\\n\\\n\trequire \\\"${1}\\\"${2}\\n\\\nsnippet #\\n\\\n\t# =>\\n\\\nsnippet end\\n\\\n\t__END__\\n\\\nsnippet case\\n\\\n\tcase ${1:object}\\n\\\n\twhen ${2:condition}\\n\\\n\t\t${3}\\n\\\n\tend\\n\\\nsnippet when\\n\\\n\twhen ${1:condition}\\n\\\n\t\t${2}\\n\\\nsnippet def\\n\\\n\tdef ${1:method_name}\\n\\\n\t\t${2}\\n\\\n\tend\\n\\\nsnippet deft\\n\\\n\tdef test_${1:case_name}\\n\\\n\t\t${2}\\n\\\n\tend\\n\\\nsnippet if\\n\\\n\tif ${1:condition}\\n\\\n\t\t${2}\\n\\\n\tend\\n\\\nsnippet ife\\n\\\n\tif ${1:condition}\\n\\\n\t\t${2}\\n\\\n\telse\\n\\\n\t\t${3}\\n\\\n\tend\\n\\\nsnippet elsif\\n\\\n\telsif ${1:condition}\\n\\\n\t\t${2}\\n\\\nsnippet unless\\n\\\n\tunless ${1:condition}\\n\\\n\t\t${2}\\n\\\n\tend\\n\\\nsnippet while\\n\\\n\twhile ${1:condition}\\n\\\n\t\t${2}\\n\\\n\tend\\n\\\nsnippet for\\n\\\n\tfor ${1:e} in ${2:c}\\n\\\n\t\t${3}\\n\\\n\tend\\n\\\nsnippet until\\n\\\n\tuntil ${1:condition}\\n\\\n\t\t${2}\\n\\\n\tend\\n\\\nsnippet cla class .. end\\n\\\n\tclass ${1:`substitute(Filename(), '\\\\(_\\\\|^\\\\)\\\\(.\\\\)', '\\\\u\\\\2', 'g')`}\\n\\\n\t\t${2}\\n\\\n\tend\\n\\\nsnippet cla class .. initialize .. end\\n\\\n\tclass ${1:`substitute(Filename(), '\\\\(_\\\\|^\\\\)\\\\(.\\\\)', '\\\\u\\\\2', 'g')`}\\n\\\n\t\tdef initialize(${2:args})\\n\\\n\t\t\t${3}\\n\\\n\t\tend\\n\\\n\tend\\n\\\nsnippet cla class .. < ParentClass .. initialize .. end\\n\\\n\tclass ${1:`substitute(Filename(), '\\\\(_\\\\|^\\\\)\\\\(.\\\\)', '\\\\u\\\\2', 'g')`} < ${2:ParentClass}\\n\\\n\t\tdef initialize(${3:args})\\n\\\n\t\t\t${4}\\n\\\n\t\tend\\n\\\n\tend\\n\\\nsnippet cla ClassName = Struct .. do .. end\\n\\\n\t${1:`substitute(Filename(), '\\\\(_\\\\|^\\\\)\\\\(.\\\\)', '\\\\u\\\\2', 'g')`} = Struct.new(:${2:attr_names}) do\\n\\\n\t\tdef ${3:method_name}\\n\\\n\t\t\t${4}\\n\\\n\t\tend\\n\\\n\tend\\n\\\nsnippet cla class BlankSlate .. initialize .. end\\n\\\n\tclass ${1:BlankSlate}\\n\\\n\t\tinstance_methods.each { |meth| undef_method(meth) unless meth =~ /\\\\A__/ }\\n\\\n\tend\\n\\\nsnippet cla class << self .. end\\n\\\n\tclass << ${1:self}\\n\\\n\t\t${2}\\n\\\n\tend\\n\\\n# class .. < DelegateClass .. initialize .. end\\n\\\nsnippet cla-\\n\\\n\tclass ${1:`substitute(Filename(), '\\\\(_\\\\|^\\\\)\\\\(.\\\\)', '\\\\u\\\\2', 'g')`} < DelegateClass(${2:ParentClass})\\n\\\n\t\tdef initialize(${3:args})\\n\\\n\t\t\tsuper(${4:del_obj})\\n\\\n\\n\\\n\t\t\t${5}\\n\\\n\t\tend\\n\\\n\tend\\n\\\nsnippet mod module .. end\\n\\\n\tmodule ${1:`substitute(Filename(), '\\\\(_\\\\|^\\\\)\\\\(.\\\\)', '\\\\u\\\\2', 'g')`}\\n\\\n\t\t${2}\\n\\\n\tend\\n\\\nsnippet mod module .. module_function .. end\\n\\\n\tmodule ${1:`substitute(Filename(), '\\\\(_\\\\|^\\\\)\\\\(.\\\\)', '\\\\u\\\\2', 'g')`}\\n\\\n\t\tmodule_function\\n\\\n\\n\\\n\t\t${2}\\n\\\n\tend\\n\\\nsnippet mod module .. ClassMethods .. end\\n\\\n\tmodule ${1:`substitute(Filename(), '\\\\(_\\\\|^\\\\)\\\\(.\\\\)', '\\\\u\\\\2', 'g')`}\\n\\\n\t\tmodule ClassMethods\\n\\\n\t\t\t${2}\\n\\\n\t\tend\\n\\\n\\n\\\n\t\tmodule InstanceMethods\\n\\\n\\n\\\n\t\tend\\n\\\n\\n\\\n\t\tdef self.included(receiver)\\n\\\n\t\t\treceiver.extend         ClassMethods\\n\\\n\t\t\treceiver.send :include, InstanceMethods\\n\\\n\t\tend\\n\\\n\tend\\n\\\n# attr_reader\\n\\\nsnippet r\\n\\\n\tattr_reader :${1:attr_names}\\n\\\n# attr_writer\\n\\\nsnippet w\\n\\\n\tattr_writer :${1:attr_names}\\n\\\n# attr_accessor\\n\\\nsnippet rw\\n\\\n\tattr_accessor :${1:attr_names}\\n\\\nsnippet atp\\n\\\n\tattr_protected :${1:attr_names}\\n\\\nsnippet ata\\n\\\n\tattr_accessible :${1:attr_names}\\n\\\n# include Enumerable\\n\\\nsnippet Enum\\n\\\n\tinclude Enumerable\\n\\\n\\n\\\n\tdef each(&block)\\n\\\n\t\t${1}\\n\\\n\tend\\n\\\n# include Comparable\\n\\\nsnippet Comp\\n\\\n\tinclude Comparable\\n\\\n\\n\\\n\tdef <=>(other)\\n\\\n\t\t${1}\\n\\\n\tend\\n\\\n# extend Forwardable\\n\\\nsnippet Forw-\\n\\\n\textend Forwardable\\n\\\n# def self\\n\\\nsnippet defs\\n\\\n\tdef self.${1:class_method_name}\\n\\\n\t\t${2}\\n\\\n\tend\\n\\\n# def method_missing\\n\\\nsnippet defmm\\n\\\n\tdef method_missing(meth, *args, &blk)\\n\\\n\t\t${1}\\n\\\n\tend\\n\\\nsnippet defd\\n\\\n\tdef_delegator :${1:@del_obj}, :${2:del_meth}, :${3:new_name}\\n\\\nsnippet defds\\n\\\n\tdef_delegators :${1:@del_obj}, :${2:del_methods}\\n\\\nsnippet am\\n\\\n\talias_method :${1:new_name}, :${2:old_name}\\n\\\nsnippet app\\n\\\n\tif __FILE__ == $PROGRAM_NAME\\n\\\n\t\t${1}\\n\\\n\tend\\n\\\n# usage_if()\\n\\\nsnippet usai\\n\\\n\tif ARGV.${1}\\n\\\n\t\tabort \\\"Usage: #{$PROGRAM_NAME} ${2:ARGS_GO_HERE}\\\"${3}\\n\\\n\tend\\n\\\n# usage_unless()\\n\\\nsnippet usau\\n\\\n\tunless ARGV.${1}\\n\\\n\t\tabort \\\"Usage: #{$PROGRAM_NAME} ${2:ARGS_GO_HERE}\\\"${3}\\n\\\n\tend\\n\\\nsnippet array\\n\\\n\tArray.new(${1:10}) { |${2:i}| ${3} }\\n\\\nsnippet hash\\n\\\n\tHash.new { |${1:hash}, ${2:key}| $1[$2] = ${3} }\\n\\\nsnippet file File.foreach() { |line| .. }\\n\\\n\tFile.foreach(${1:\\\"path/to/file\\\"}) { |${2:line}| ${3} }\\n\\\nsnippet file File.read()\\n\\\n\tFile.read(${1:\\\"path/to/file\\\"})${2}\\n\\\nsnippet Dir Dir.global() { |file| .. }\\n\\\n\tDir.glob(${1:\\\"dir/glob/*\\\"}) { |${2:file}| ${3} }\\n\\\nsnippet Dir Dir[\\\"..\\\"]\\n\\\n\tDir[${1:\\\"glob/**/*.rb\\\"}]${2}\\n\\\nsnippet dir\\n\\\n\tFilename.dirname(__FILE__)\\n\\\nsnippet deli\\n\\\n\tdelete_if { |${1:e}| ${2} }\\n\\\nsnippet fil\\n\\\n\tfill(${1:range}) { |${2:i}| ${3} }\\n\\\n# flatten_once()\\n\\\nsnippet flao\\n\\\n\tinject(Array.new) { |${1:arr}, ${2:a}| $1.push(*$2)}${3}\\n\\\nsnippet zip\\n\\\n\tzip(${1:enums}) { |${2:row}| ${3} }\\n\\\n# downto(0) { |n| .. }\\n\\\nsnippet dow\\n\\\n\tdownto(${1:0}) { |${2:n}| ${3} }\\n\\\nsnippet ste\\n\\\n\tstep(${1:2}) { |${2:n}| ${3} }\\n\\\nsnippet tim\\n\\\n\ttimes { |${1:n}| ${2} }\\n\\\nsnippet upt\\n\\\n\tupto(${1:1.0/0.0}) { |${2:n}| ${3} }\\n\\\nsnippet loo\\n\\\n\tloop { ${1} }\\n\\\nsnippet ea\\n\\\n\teach { |${1:e}| ${2} }\\n\\\nsnippet ead\\n\\\n\teach do |${1:e}|\\n\\\n\t\t${2}\\n\\\n\tend\\n\\\nsnippet eab\\n\\\n\teach_byte { |${1:byte}| ${2} }\\n\\\nsnippet eac- each_char { |chr| .. }\\n\\\n\teach_char { |${1:chr}| ${2} }\\n\\\nsnippet eac- each_cons(..) { |group| .. }\\n\\\n\teach_cons(${1:2}) { |${2:group}| ${3} }\\n\\\nsnippet eai\\n\\\n\teach_index { |${1:i}| ${2} }\\n\\\nsnippet eaid\\n\\\n\teach_index do |${1:i}|\\n\\\n\t\t${2}\\n\\\n\tend\\n\\\nsnippet eak\\n\\\n\teach_key { |${1:key}| ${2} }\\n\\\nsnippet eakd\\n\\\n\teach_key do |${1:key}|\\n\\\n\t\t${2}\\n\\\n\tend\\n\\\nsnippet eal\\n\\\n\teach_line { |${1:line}| ${2} }\\n\\\nsnippet eald\\n\\\n\teach_line do |${1:line}|\\n\\\n\t\t${2}\\n\\\n\tend\\n\\\nsnippet eap\\n\\\n\teach_pair { |${1:name}, ${2:val}| ${3} }\\n\\\nsnippet eapd\\n\\\n\teach_pair do |${1:name}, ${2:val}|\\n\\\n\t\t${3}\\n\\\n\tend\\n\\\nsnippet eas-\\n\\\n\teach_slice(${1:2}) { |${2:group}| ${3} }\\n\\\nsnippet easd-\\n\\\n\teach_slice(${1:2}) do |${2:group}|\\n\\\n\t\t${3}\\n\\\n\tend\\n\\\nsnippet eav\\n\\\n\teach_value { |${1:val}| ${2} }\\n\\\nsnippet eavd\\n\\\n\teach_value do |${1:val}|\\n\\\n\t\t${2}\\n\\\n\tend\\n\\\nsnippet eawi\\n\\\n\teach_with_index { |${1:e}, ${2:i}| ${3} }\\n\\\nsnippet eawid\\n\\\n\teach_with_index do |${1:e},${2:i}|\\n\\\n\t\t${3}\\n\\\n\tend\\n\\\nsnippet reve\\n\\\n\treverse_each { |${1:e}| ${2} }\\n\\\nsnippet reved\\n\\\n\treverse_each do |${1:e}|\\n\\\n\t\t${2}\\n\\\n\tend\\n\\\nsnippet inj\\n\\\n\tinject(${1:init}) { |${2:mem}, ${3:var}| ${4} }\\n\\\nsnippet injd\\n\\\n\tinject(${1:init}) do |${2:mem}, ${3:var}|\\n\\\n\t\t${4}\\n\\\n\tend\\n\\\nsnippet map\\n\\\n\tmap { |${1:e}| ${2} }\\n\\\nsnippet mapd\\n\\\n\tmap do |${1:e}|\\n\\\n\t\t${2}\\n\\\n\tend\\n\\\nsnippet mapwi-\\n\\\n\tenum_with_index.map { |${1:e}, ${2:i}| ${3} }\\n\\\nsnippet sor\\n\\\n\tsort { |a, b| ${1} }\\n\\\nsnippet sorb\\n\\\n\tsort_by { |${1:e}| ${2} }\\n\\\nsnippet ran\\n\\\n\tsort_by { rand }\\n\\\nsnippet all\\n\\\n\tall? { |${1:e}| ${2} }\\n\\\nsnippet any\\n\\\n\tany? { |${1:e}| ${2} }\\n\\\nsnippet cl\\n\\\n\tclassify { |${1:e}| ${2} }\\n\\\nsnippet col\\n\\\n\tcollect { |${1:e}| ${2} }\\n\\\nsnippet cold\\n\\\n\tcollect do |${1:e}|\\n\\\n\t\t${2}\\n\\\n\tend\\n\\\nsnippet det\\n\\\n\tdetect { |${1:e}| ${2} }\\n\\\nsnippet detd\\n\\\n\tdetect do |${1:e}|\\n\\\n\t\t${2}\\n\\\n\tend\\n\\\nsnippet fet\\n\\\n\tfetch(${1:name}) { |${2:key}| ${3} }\\n\\\nsnippet fin\\n\\\n\tfind { |${1:e}| ${2} }\\n\\\nsnippet find\\n\\\n\tfind do |${1:e}|\\n\\\n\t\t${2}\\n\\\n\tend\\n\\\nsnippet fina\\n\\\n\tfind_all { |${1:e}| ${2} }\\n\\\nsnippet finad\\n\\\n\tfind_all do |${1:e}|\\n\\\n\t\t${2}\\n\\\n\tend\\n\\\nsnippet gre\\n\\\n\tgrep(${1:/pattern/}) { |${2:match}| ${3} }\\n\\\nsnippet sub\\n\\\n\t${1:g}sub(${2:/pattern/}) { |${3:match}| ${4} }\\n\\\nsnippet sca\\n\\\n\tscan(${1:/pattern/}) { |${2:match}| ${3} }\\n\\\nsnippet scad\\n\\\n\tscan(${1:/pattern/}) do |${2:match}|\\n\\\n\t\t${3}\\n\\\n\tend\\n\\\nsnippet max\\n\\\n\tmax { |a, b| ${1} }\\n\\\nsnippet min\\n\\\n\tmin { |a, b| ${1} }\\n\\\nsnippet par\\n\\\n\tpartition { |${1:e}| ${2} }\\n\\\nsnippet pard\\n\\\n\tpartition do |${1:e}|\\n\\\n\t\t${2}\\n\\\n\tend\\n\\\nsnippet rej\\n\\\n\treject { |${1:e}| ${2} }\\n\\\nsnippet rejd\\n\\\n\treject do |${1:e}|\\n\\\n\t\t${2}\\n\\\n\tend\\n\\\nsnippet sel\\n\\\n\tselect { |${1:e}| ${2} }\\n\\\nsnippet seld\\n\\\n\tselect do |${1:e}|\\n\\\n\t\t${2}\\n\\\n\tend\\n\\\nsnippet lam\\n\\\n\tlambda { |${1:args}| ${2} }\\n\\\nsnippet doo\\n\\\n\tdo\\n\\\n\t\t${1}\\n\\\n\tend\\n\\\nsnippet dov\\n\\\n\tdo |${1:variable}|\\n\\\n\t\t${2}\\n\\\n\tend\\n\\\nsnippet :\\n\\\n\t:${1:key} => ${2:\\\"value\\\"}${3}\\n\\\nsnippet ope\\n\\\n\topen(${1:\\\"path/or/url/or/pipe\\\"}, \\\"${2:w}\\\") { |${3:io}| ${4} }\\n\\\n# path_from_here()\\n\\\nsnippet fpath\\n\\\n\tFile.join(File.dirname(__FILE__), *%2[${1:rel path here}])${2}\\n\\\n# unix_filter {}\\n\\\nsnippet unif\\n\\\n\tARGF.each_line${1} do |${2:line}|\\n\\\n\t\t${3}\\n\\\n\tend\\n\\\n# option_parse {}\\n\\\nsnippet optp\\n\\\n\trequire \\\"optparse\\\"\\n\\\n\\n\\\n\toptions = {${1:default => \\\"args\\\"}}\\n\\\n\\n\\\n\tARGV.options do |opts|\\n\\\n\t\topts.banner = \\\"Usage: #{File.basename($PROGRAM_NAME)}\\n\\\nsnippet opt\\n\\\n\topts.on( \\\"-${1:o}\\\", \\\"--${2:long-option-name}\\\", ${3:String},\\n\\\n\t         \\\"${4:Option description.}\\\") do |${5:opt}|\\n\\\n\t\t${6}\\n\\\n\tend\\n\\\nsnippet tc\\n\\\n\trequire \\\"test/unit\\\"\\n\\\n\\n\\\n\trequire \\\"${1:library_file_name}\\\"\\n\\\n\\n\\\n\tclass Test${2:$1} < Test::Unit::TestCase\\n\\\n\t\tdef test_${3:case_name}\\n\\\n\t\t\t${4}\\n\\\n\t\tend\\n\\\n\tend\\n\\\nsnippet ts\\n\\\n\trequire \\\"test/unit\\\"\\n\\\n\\n\\\n\trequire \\\"tc_${1:test_case_file}\\\"\\n\\\n\trequire \\\"tc_${2:test_case_file}\\\"${3}\\n\\\nsnippet as\\n\\\n\tassert ${1:test}, \\\"${2:Failure message.}\\\"${3}\\n\\\nsnippet ase\\n\\\n\tassert_equal ${1:expected}, ${2:actual}${3}\\n\\\nsnippet asne\\n\\\n\tassert_not_equal ${1:unexpected}, ${2:actual}${3}\\n\\\nsnippet asid\\n\\\n\tassert_in_delta ${1:expected_float}, ${2:actual_float}, ${3:2 ** -20}${4}\\n\\\nsnippet asio\\n\\\n\tassert_instance_of ${1:ExpectedClass}, ${2:actual_instance}${3}\\n\\\nsnippet asko\\n\\\n\tassert_kind_of ${1:ExpectedKind}, ${2:actual_instance}${3}\\n\\\nsnippet asn\\n\\\n\tassert_nil ${1:instance}${2}\\n\\\nsnippet asnn\\n\\\n\tassert_not_nil ${1:instance}${2}\\n\\\nsnippet asm\\n\\\n\tassert_match /${1:expected_pattern}/, ${2:actual_string}${3}\\n\\\nsnippet asnm\\n\\\n\tassert_no_match /${1:unexpected_pattern}/, ${2:actual_string}${3}\\n\\\nsnippet aso\\n\\\n\tassert_operator ${1:left}, :${2:operator}, ${3:right}${4}\\n\\\nsnippet asr\\n\\\n\tassert_raise ${1:Exception} { ${2} }\\n\\\nsnippet asrd\\n\\\n\tassert_raise ${1:Exception} do\\n\\\n\t\t${2}\\n\\\n\tend\\n\\\nsnippet asnr\\n\\\n\tassert_nothing_raised ${1:Exception} { ${2} }\\n\\\nsnippet asnrd\\n\\\n\tassert_nothing_raised ${1:Exception} do\\n\\\n\t\t${2}\\n\\\n\tend\\n\\\nsnippet asrt\\n\\\n\tassert_respond_to ${1:object}, :${2:method}${3}\\n\\\nsnippet ass assert_same(..)\\n\\\n\tassert_same ${1:expected}, ${2:actual}${3}\\n\\\nsnippet ass assert_send(..)\\n\\\n\tassert_send [${1:object}, :${2:message}, ${3:args}]${4}\\n\\\nsnippet asns\\n\\\n\tassert_not_same ${1:unexpected}, ${2:actual}${3}\\n\\\nsnippet ast\\n\\\n\tassert_throws :${1:expected} { ${2} }\\n\\\nsnippet astd\\n\\\n\tassert_throws :${1:expected} do\\n\\\n\t\t${2}\\n\\\n\tend\\n\\\nsnippet asnt\\n\\\n\tassert_nothing_thrown { ${1} }\\n\\\nsnippet asntd\\n\\\n\tassert_nothing_thrown do\\n\\\n\t\t${1}\\n\\\n\tend\\n\\\nsnippet fl\\n\\\n\tflunk \\\"${1:Failure message.}\\\"${2}\\n\\\n# Benchmark.bmbm do .. end\\n\\\nsnippet bm-\\n\\\n\tTESTS = ${1:10_000}\\n\\\n\tBenchmark.bmbm do |results|\\n\\\n\t\t${2}\\n\\\n\tend\\n\\\nsnippet rep\\n\\\n\tresults.report(\\\"${1:name}:\\\") { TESTS.times { ${2} }}\\n\\\n# Marshal.dump(.., file)\\n\\\nsnippet Md\\n\\\n\tFile.open(${1:\\\"path/to/file.dump\\\"}, \\\"wb\\\") { |${2:file}| Marshal.dump(${3:obj}, $2) }${4}\\n\\\n# Mashal.load(obj)\\n\\\nsnippet Ml\\n\\\n\tFile.open(${1:\\\"path/to/file.dump\\\"}, \\\"rb\\\") { |${2:file}| Marshal.load($2) }${3}\\n\\\n# deep_copy(..)\\n\\\nsnippet deec\\n\\\n\tMarshal.load(Marshal.dump(${1:obj_to_copy}))${2}\\n\\\nsnippet Pn-\\n\\\n\tPStore.new(${1:\\\"file_name.pstore\\\"})${2}\\n\\\nsnippet tra\\n\\\n\ttransaction(${1:true}) { ${2} }\\n\\\n# xmlread(..)\\n\\\nsnippet xml-\\n\\\n\tREXML::Document.new(File.read(${1:\\\"path/to/file\\\"}))${2}\\n\\\n# xpath(..) { .. }\\n\\\nsnippet xpa\\n\\\n\telements.each(${1:\\\"//Xpath\\\"}) do |${2:node}|\\n\\\n\t\t${3}\\n\\\n\tend\\n\\\n# class_from_name()\\n\\\nsnippet clafn\\n\\\n\tsplit(\\\"::\\\").inject(Object) { |par, const| par.const_get(const) }\\n\\\n# singleton_class()\\n\\\nsnippet sinc\\n\\\n\tclass << self; self end\\n\\\nsnippet nam\\n\\\n\tnamespace :${1:`Filename()`} do\\n\\\n\t\t${2}\\n\\\n\tend\\n\\\nsnippet tas\\n\\\n\tdesc \\\"${1:Task description}\\\"\\n\\\n\ttask :${2:task_name => [:dependent, :tasks]} do\\n\\\n\t\t${3}\\n\\\n\tend\\n\\\n# block\\n\\\nsnippet b\\n\\\n\t{ |${1:var}| ${2} }\\n\\\nsnippet begin\\n\\\n\tbegin\\n\\\n\t\traise 'A test exception.'\\n\\\n\trescue Exception => e\\n\\\n\t\tputs e.message\\n\\\n\t\tputs e.backtrace.inspect\\n\\\n\telse\\n\\\n\t\t# other exception\\n\\\n\tensure\\n\\\n\t\t# always executed\\n\\\n\tend\\n\\\n\\n\\\n#debugging\\n\\\nsnippet debug\\n\\\n\trequire 'ruby-debug'; debugger; true;\\n\\\nsnippet pry\\n\\\n\trequire 'pry'; binding.pry\\n\\\n\\n\\\n#############################################\\n\\\n# Rails snippets - for pure Ruby, see above #\\n\\\n#############################################\\n\\\nsnippet art\\n\\\n\tassert_redirected_to ${1::action => \\\"${2:index}\\\"}\\n\\\nsnippet artnp\\n\\\n\tassert_redirected_to ${1:parent}_${2:child}_path(${3:@$1}, ${4:@$2})\\n\\\nsnippet artnpp\\n\\\n\tassert_redirected_to ${1:parent}_${2:child}_path(${3:@$1})\\n\\\nsnippet artp\\n\\\n\tassert_redirected_to ${1:model}_path(${2:@$1})\\n\\\nsnippet artpp\\n\\\n\tassert_redirected_to ${1:model}s_path\\n\\\nsnippet asd\\n\\\n\tassert_difference \\\"${1:Model}.${2:count}\\\", $1 do\\n\\\n\t\t${3}\\n\\\n\tend\\n\\\nsnippet asnd\\n\\\n\tassert_no_difference \\\"${1:Model}.${2:count}\\\" do\\n\\\n\t\t${3}\\n\\\n\tend\\n\\\nsnippet asre\\n\\\n\tassert_response :${1:success}, @response.body${2}\\n\\\nsnippet asrj\\n\\\n\tassert_rjs :${1:replace}, \\\"${2:dom id}\\\"\\n\\\nsnippet ass assert_select(..)\\n\\\n\tassert_select '${1:path}', :${2:text} => '${3:inner_html' ${4:do}\\n\\\nsnippet bf\\n\\\n\tbefore_filter :${1:method}\\n\\\nsnippet bt\\n\\\n\tbelongs_to :${1:association}\\n\\\nsnippet crw\\n\\\n\tcattr_accessor :${1:attr_names}\\n\\\nsnippet defcreate\\n\\\n\tdef create\\n\\\n\t\t@${1:model_class_name} = ${2:ModelClassName}.new(params[:$1])\\n\\\n\\n\\\n\t\trespond_to do |wants|\\n\\\n\t\t\tif @$1.save\\n\\\n\t\t\t\tflash[:notice] = '$2 was successfully created.'\\n\\\n\t\t\t\twants.html { redirect_to(@$1) }\\n\\\n\t\t\t\twants.xml  { render :xml => @$1, :status => :created, :location => @$1 }\\n\\\n\t\t\telse\\n\\\n\t\t\t\twants.html { render :action => \\\"new\\\" }\\n\\\n\t\t\t\twants.xml  { render :xml => @$1.errors, :status => :unprocessable_entity }\\n\\\n\t\t\tend\\n\\\n\t\tend\\n\\\n\tend${3}\\n\\\nsnippet defdestroy\\n\\\n\tdef destroy\\n\\\n\t\t@${1:model_class_name} = ${2:ModelClassName}.find(params[:id])\\n\\\n\t\t@$1.destroy\\n\\\n\\n\\\n\t\trespond_to do |wants|\\n\\\n\t\t\twants.html { redirect_to($1s_url) }\\n\\\n\t\t\twants.xml  { head :ok }\\n\\\n\t\tend\\n\\\n\tend${3}\\n\\\nsnippet defedit\\n\\\n\tdef edit\\n\\\n\t\t@${1:model_class_name} = ${2:ModelClassName}.find(params[:id])\\n\\\n\tend\\n\\\nsnippet defindex\\n\\\n\tdef index\\n\\\n\t\t@${1:model_class_name} = ${2:ModelClassName}.all\\n\\\n\\n\\\n\t\trespond_to do |wants|\\n\\\n\t\t\twants.html # index.html.erb\\n\\\n\t\t\twants.xml  { render :xml => @$1s }\\n\\\n\t\tend\\n\\\n\tend${3}\\n\\\nsnippet defnew\\n\\\n\tdef new\\n\\\n\t\t@${1:model_class_name} = ${2:ModelClassName}.new\\n\\\n\\n\\\n\t\trespond_to do |wants|\\n\\\n\t\t\twants.html # new.html.erb\\n\\\n\t\t\twants.xml  { render :xml => @$1 }\\n\\\n\t\tend\\n\\\n\tend${3}\\n\\\nsnippet defshow\\n\\\n\tdef show\\n\\\n\t\t@${1:model_class_name} = ${2:ModelClassName}.find(params[:id])\\n\\\n\\n\\\n\t\trespond_to do |wants|\\n\\\n\t\t\twants.html # show.html.erb\\n\\\n\t\t\twants.xml  { render :xml => @$1 }\\n\\\n\t\tend\\n\\\n\tend${3}\\n\\\nsnippet defupdate\\n\\\n\tdef update\\n\\\n\t\t@${1:model_class_name} = ${2:ModelClassName}.find(params[:id])\\n\\\n\\n\\\n\t\trespond_to do |wants|\\n\\\n\t\t\tif @$1.update_attributes(params[:$1])\\n\\\n\t\t\t\tflash[:notice] = '$2 was successfully updated.'\\n\\\n\t\t\t\twants.html { redirect_to(@$1) }\\n\\\n\t\t\t\twants.xml  { head :ok }\\n\\\n\t\t\telse\\n\\\n\t\t\t\twants.html { render :action => \\\"edit\\\" }\\n\\\n\t\t\t\twants.xml  { render :xml => @$1.errors, :status => :unprocessable_entity }\\n\\\n\t\t\tend\\n\\\n\t\tend\\n\\\n\tend${3}\\n\\\nsnippet flash\\n\\\n\tflash[:${1:notice}] = \\\"${2}\\\"\\n\\\nsnippet habtm\\n\\\n\thas_and_belongs_to_many :${1:object}, :join_table => \\\"${2:table_name}\\\", :foreign_key => \\\"${3}_id\\\"${4}\\n\\\nsnippet hm\\n\\\n\thas_many :${1:object}\\n\\\nsnippet hmd\\n\\\n\thas_many :${1:other}s, :class_name => \\\"${2:$1}\\\", :foreign_key => \\\"${3:$1}_id\\\", :dependent => :destroy${4}\\n\\\nsnippet hmt\\n\\\n\thas_many :${1:object}, :through => :${2:object}\\n\\\nsnippet ho\\n\\\n\thas_one :${1:object}\\n\\\nsnippet i18\\n\\\n\tI18n.t('${1:type.key}')${2}\\n\\\nsnippet ist\\n\\\n\t<%= image_submit_tag(\\\"${1:agree.png}\\\", :id => \\\"${2:id}\\\"${3} %>\\n\\\nsnippet log\\n\\\n\tRails.logger.${1:debug} ${2}\\n\\\nsnippet log2\\n\\\n\tRAILS_DEFAULT_LOGGER.${1:debug} ${2}\\n\\\nsnippet logd\\n\\\n\tlogger.debug { \\\"${1:message}\\\" }${2}\\n\\\nsnippet loge\\n\\\n\tlogger.error { \\\"${1:message}\\\" }${2}\\n\\\nsnippet logf\\n\\\n\tlogger.fatal { \\\"${1:message}\\\" }${2}\\n\\\nsnippet logi\\n\\\n\tlogger.info { \\\"${1:message}\\\" }${2}\\n\\\nsnippet logw\\n\\\n\tlogger.warn { \\\"${1:message}\\\" }${2}\\n\\\nsnippet mapc\\n\\\n\t${1:map}.${2:connect} '${3:controller/:action/:id}'\\n\\\nsnippet mapca\\n\\\n\t${1:map}.catch_all \\\"*${2:anything}\\\", :controller => \\\"${3:default}\\\", :action => \\\"${4:error}\\\"${5}\\n\\\nsnippet mapr\\n\\\n\t${1:map}.resource :${2:resource}\\n\\\nsnippet maprs\\n\\\n\t${1:map}.resources :${2:resource}\\n\\\nsnippet mapwo\\n\\\n\t${1:map}.with_options :${2:controller} => '${3:thing}' do |$3|\\n\\\n\t\t${4}\\n\\\n\tend\\n\\\nsnippet mbs\\n\\\n\tbefore_save :${1:method}\\n\\\nsnippet mcht\\n\\\n\tchange_table :${1:table_name} do |t|\\n\\\n\t\t${2}\\n\\\n\tend\\n\\\nsnippet mp\\n\\\n\tmap(&:${1:id})\\n\\\nsnippet mrw\\n\\\n\tmattr_accessor :${1:attr_names}\\n\\\nsnippet oa\\n\\\n\torder(\\\"${1:field}\\\")\\n\\\nsnippet od\\n\\\n\torder(\\\"${1:field} DESC\\\")\\n\\\nsnippet pa\\n\\\n\tparams[:${1:id}]${2}\\n\\\nsnippet ra\\n\\\n\trender :action => \\\"${1:action}\\\"\\n\\\nsnippet ral\\n\\\n\trender :action => \\\"${1:action}\\\", :layout => \\\"${2:layoutname}\\\"\\n\\\nsnippet rest\\n\\\n\trespond_to do |wants|\\n\\\n\t\twants.${1:html} { ${2} }\\n\\\n\tend\\n\\\nsnippet rf\\n\\\n\trender :file => \\\"${1:filepath}\\\"\\n\\\nsnippet rfu\\n\\\n\trender :file => \\\"${1:filepath}\\\", :use_full_path => ${2:false}\\n\\\nsnippet ri\\n\\\n\trender :inline => \\\"${1:<%= 'hello' %>}\\\"\\n\\\nsnippet ril\\n\\\n\trender :inline => \\\"${1:<%= 'hello' %>}\\\", :locals => { ${2::name} => \\\"${3:value}\\\"${4} }\\n\\\nsnippet rit\\n\\\n\trender :inline => \\\"${1:<%= 'hello' %>}\\\", :type => ${2::rxml}\\n\\\nsnippet rjson\\n\\\n\trender :json => ${1:text to render}\\n\\\nsnippet rl\\n\\\n\trender :layout => \\\"${1:layoutname}\\\"\\n\\\nsnippet rn\\n\\\n\trender :nothing => ${1:true}\\n\\\nsnippet rns\\n\\\n\trender :nothing => ${1:true}, :status => ${2:401}\\n\\\nsnippet rp\\n\\\n\trender :partial => \\\"${1:item}\\\"\\n\\\nsnippet rpc\\n\\\n\trender :partial => \\\"${1:item}\\\", :collection => ${2:@$1s}\\n\\\nsnippet rpl\\n\\\n\trender :partial => \\\"${1:item}\\\", :locals => { :${2:$1} => ${3:@$1}\\n\\\nsnippet rpo\\n\\\n\trender :partial => \\\"${1:item}\\\", :object => ${2:@$1}\\n\\\nsnippet rps\\n\\\n\trender :partial => \\\"${1:item}\\\", :status => ${2:500}\\n\\\nsnippet rt\\n\\\n\trender :text => \\\"${1:text to render}\\\"\\n\\\nsnippet rtl\\n\\\n\trender :text => \\\"${1:text to render}\\\", :layout => \\\"${2:layoutname}\\\"\\n\\\nsnippet rtlt\\n\\\n\trender :text => \\\"${1:text to render}\\\", :layout => ${2:true}\\n\\\nsnippet rts\\n\\\n\trender :text => \\\"${1:text to render}\\\", :status => ${2:401}\\n\\\nsnippet ru\\n\\\n\trender :update do |${1:page}|\\n\\\n\t\t$1.${2}\\n\\\n\tend\\n\\\nsnippet rxml\\n\\\n\trender :xml => ${1:text to render}\\n\\\nsnippet sc\\n\\\n\tscope :${1:name}, :where(:@${2:field} => ${3:value})\\n\\\nsnippet sl\\n\\\n\tscope :${1:name}, lambda do |${2:value}|\\n\\\n\t\twhere(\\\"${3:field = ?}\\\", ${4:bind var})\\n\\\n\tend\\n\\\nsnippet sha1\\n\\\n\tDigest::SHA1.hexdigest(${1:string})\\n\\\nsnippet sweeper\\n\\\n\tclass ${1:ModelClassName}Sweeper < ActionController::Caching::Sweeper\\n\\\n\t\tobserve $1\\n\\\n\\n\\\n\t\tdef after_save(${2:model_class_name})\\n\\\n\t\t\texpire_cache($2)\\n\\\n\t\tend\\n\\\n\\n\\\n\t\tdef after_destroy($2)\\n\\\n\t\t\texpire_cache($2)\\n\\\n\t\tend\\n\\\n\\n\\\n\t\tdef expire_cache($2)\\n\\\n\t\t\texpire_page\\n\\\n\t\tend\\n\\\n\tend\\n\\\nsnippet tcb\\n\\\n\tt.boolean :${1:title}\\n\\\n\t${2}\\n\\\nsnippet tcbi\\n\\\n\tt.binary :${1:title}, :limit => ${2:2}.megabytes\\n\\\n\t${3}\\n\\\nsnippet tcd\\n\\\n\tt.decimal :${1:title}, :precision => ${2:10}, :scale => ${3:2}\\n\\\n\t${4}\\n\\\nsnippet tcda\\n\\\n\tt.date :${1:title}\\n\\\n\t${2}\\n\\\nsnippet tcdt\\n\\\n\tt.datetime :${1:title}\\n\\\n\t${2}\\n\\\nsnippet tcf\\n\\\n\tt.float :${1:title}\\n\\\n\t${2}\\n\\\nsnippet tch\\n\\\n\tt.change :${1:name}, :${2:string}, :${3:limit} => ${4:80}\\n\\\n\t${5}\\n\\\nsnippet tci\\n\\\n\tt.integer :${1:title}\\n\\\n\t${2}\\n\\\nsnippet tcl\\n\\\n\tt.integer :lock_version, :null => false, :default => 0\\n\\\n\t${1}\\n\\\nsnippet tcr\\n\\\n\tt.references :${1:taggable}, :polymorphic => { :default => '${2:Photo}' }\\n\\\n\t${3}\\n\\\nsnippet tcs\\n\\\n\tt.string :${1:title}\\n\\\n\t${2}\\n\\\nsnippet tct\\n\\\n\tt.text :${1:title}\\n\\\n\t${2}\\n\\\nsnippet tcti\\n\\\n\tt.time :${1:title}\\n\\\n\t${2}\\n\\\nsnippet tcts\\n\\\n\tt.timestamp :${1:title}\\n\\\n\t${2}\\n\\\nsnippet tctss\\n\\\n\tt.timestamps\\n\\\n\t${1}\\n\\\nsnippet va\\n\\\n\tvalidates_associated :${1:attribute}\\n\\\nsnippet vao\\n\\\n\tvalidates_acceptance_of :${1:terms}\\n\\\nsnippet vc\\n\\\n\tvalidates_confirmation_of :${1:attribute}\\n\\\nsnippet ve\\n\\\n\tvalidates_exclusion_of :${1:attribute}, :in => ${2:%w( mov avi )}\\n\\\nsnippet vf\\n\\\n\tvalidates_format_of :${1:attribute}, :with => /${2:regex}/\\n\\\nsnippet vi\\n\\\n\tvalidates_inclusion_of :${1:attribute}, :in => %w(${2: mov avi })\\n\\\nsnippet vl\\n\\\n\tvalidates_length_of :${1:attribute}, :within => ${2:3}..${3:20}\\n\\\nsnippet vn\\n\\\n\tvalidates_numericality_of :${1:attribute}\\n\\\nsnippet vpo\\n\\\n\tvalidates_presence_of :${1:attribute}\\n\\\nsnippet vu\\n\\\n\tvalidates_uniqueness_of :${1:attribute}\\n\\\nsnippet wants\\n\\\n\twants.${1:js|xml|html} { ${2} }\\n\\\nsnippet wc\\n\\\n\twhere(${1:\\\"conditions\\\"}${2:, bind_var})\\n\\\nsnippet wh\\n\\\n\twhere(${1:field} => ${2:value})\\n\\\nsnippet xdelete\\n\\\n\txhr :delete, :${1:destroy}, :id => ${2:1}${3}\\n\\\nsnippet xget\\n\\\n\txhr :get, :${1:show}, :id => ${2:1}${3}\\n\\\nsnippet xpost\\n\\\n\txhr :post, :${1:create}, :${2:object} => { ${3} }\\n\\\nsnippet xput\\n\\\n\txhr :put, :${1:update}, :id => ${2:1}, :${3:object} => { ${4} }${5}\\n\\\nsnippet test\\n\\\n\ttest \\\"should ${1:do something}\\\" do\\n\\\n\t\t${2}\\n\\\n\tend\\n\\\n#migrations\\n\\\nsnippet mac\\n\\\n\tadd_column :${1:table_name}, :${2:column_name}, :${3:data_type}\\n\\\nsnippet mrc\\n\\\n\tremove_column :${1:table_name}, :${2:column_name}\\n\\\nsnippet mrnc\\n\\\n\trename_column :${1:table_name}, :${2:old_column_name}, :${3:new_column_name}\\n\\\nsnippet mcc\\n\\\n\tchange_column :${1:table}, :${2:column}, :${3:type}\\n\\\nsnippet mccc\\n\\\n\tt.column :${1:title}, :${2:string}\\n\\\nsnippet mct\\n\\\n\tcreate_table :${1:table_name} do |t|\\n\\\n\t\tt.column :${2:name}, :${3:type}\\n\\\n\tend\\n\\\nsnippet migration\\n\\\n\tclass ${1:class_name} < ActiveRecord::Migration\\n\\\n\t\tdef self.up\\n\\\n\t\t\t${2}\\n\\\n\t\tend\\n\\\n\\n\\\n\t\tdef self.down\\n\\\n\t\tend\\n\\\n\tend\\n\\\n\\n\\\nsnippet trc\\n\\\n\tt.remove :${1:column}\\n\\\nsnippet tre\\n\\\n\tt.rename :${1:old_column_name}, :${2:new_column_name}\\n\\\n\t${3}\\n\\\nsnippet tref\\n\\\n\tt.references :${1:model}\\n\\\n\\n\\\n#rspec\\n\\\nsnippet it\\n\\\n\tit \\\"${1:spec_name}\\\" do\\n\\\n\t\t${2}\\n\\\n\tend\\n\\\nsnippet itp\\n\\\n\tit \\\"${1:spec_name}\\\"\\n\\\n\t${2}\\n\\\nsnippet desc\\n\\\n\tdescribe ${1:class_name} do\\n\\\n\t\t${2}\\n\\\n\tend\\n\\\nsnippet cont\\n\\\n\tcontext \\\"${1:message}\\\" do\\n\\\n\t\t${2}\\n\\\n\tend\\n\\\nsnippet bef\\n\\\n\tbefore :${1:each} do\\n\\\n\t\t${2}\\n\\\n\tend\\n\\\nsnippet aft\\n\\\n\tafter :${1:each} do\\n\\\n\t\t${2}\\n\\\n\tend\\n\\\n\";\nexports.scope = \"ruby\";\n\n});                (function() {\n                    ace.require([\"ace/snippets/ruby\"], function(m) {\n                        if (typeof module == \"object\" && typeof exports == \"object\" && module) {\n                            module.exports = m;\n                        }\n                    });\n                })();\n            "]},"metadata":{},"sourceType":"script"}