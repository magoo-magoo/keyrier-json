{"ast":null,"code":"import { drop, forEach } from \"../../utils/utils\";\nimport { Alternation, Alternative, NonTerminal, Option, Repetition, RepetitionMandatory, RepetitionMandatoryWithSeparator, RepetitionWithSeparator, Terminal } from \"./gast/gast_public\";\n/**\n *  A Grammar Walker that computes the \"remaining\" grammar \"after\" a productions in the grammar.\n */\n\nvar RestWalker =\n/** @class */\nfunction () {\n  function RestWalker() {}\n\n  RestWalker.prototype.walk = function (prod, prevRest) {\n    var _this = this;\n\n    if (prevRest === void 0) {\n      prevRest = [];\n    }\n\n    forEach(prod.definition, function (subProd, index) {\n      var currRest = drop(prod.definition, index + 1);\n      /* istanbul ignore else */\n\n      if (subProd instanceof NonTerminal) {\n        _this.walkProdRef(subProd, currRest, prevRest);\n      } else if (subProd instanceof Terminal) {\n        _this.walkTerminal(subProd, currRest, prevRest);\n      } else if (subProd instanceof Alternative) {\n        _this.walkFlat(subProd, currRest, prevRest);\n      } else if (subProd instanceof Option) {\n        _this.walkOption(subProd, currRest, prevRest);\n      } else if (subProd instanceof RepetitionMandatory) {\n        _this.walkAtLeastOne(subProd, currRest, prevRest);\n      } else if (subProd instanceof RepetitionMandatoryWithSeparator) {\n        _this.walkAtLeastOneSep(subProd, currRest, prevRest);\n      } else if (subProd instanceof RepetitionWithSeparator) {\n        _this.walkManySep(subProd, currRest, prevRest);\n      } else if (subProd instanceof Repetition) {\n        _this.walkMany(subProd, currRest, prevRest);\n      } else if (subProd instanceof Alternation) {\n        _this.walkOr(subProd, currRest, prevRest);\n      } else {\n        throw Error(\"non exhaustive match\");\n      }\n    });\n  };\n\n  RestWalker.prototype.walkTerminal = function (terminal, currRest, prevRest) {};\n\n  RestWalker.prototype.walkProdRef = function (refProd, currRest, prevRest) {};\n\n  RestWalker.prototype.walkFlat = function (flatProd, currRest, prevRest) {\n    // ABCDEF => after the D the rest is EF\n    var fullOrRest = currRest.concat(prevRest);\n    this.walk(flatProd, fullOrRest);\n  };\n\n  RestWalker.prototype.walkOption = function (optionProd, currRest, prevRest) {\n    // ABC(DE)?F => after the (DE)? the rest is F\n    var fullOrRest = currRest.concat(prevRest);\n    this.walk(optionProd, fullOrRest);\n  };\n\n  RestWalker.prototype.walkAtLeastOne = function (atLeastOneProd, currRest, prevRest) {\n    // ABC(DE)+F => after the (DE)+ the rest is (DE)?F\n    var fullAtLeastOneRest = [new Option({\n      definition: atLeastOneProd.definition\n    })].concat(currRest, prevRest);\n    this.walk(atLeastOneProd, fullAtLeastOneRest);\n  };\n\n  RestWalker.prototype.walkAtLeastOneSep = function (atLeastOneSepProd, currRest, prevRest) {\n    // ABC DE(,DE)* F => after the (,DE)+ the rest is (,DE)?F\n    var fullAtLeastOneSepRest = restForRepetitionWithSeparator(atLeastOneSepProd, currRest, prevRest);\n    this.walk(atLeastOneSepProd, fullAtLeastOneSepRest);\n  };\n\n  RestWalker.prototype.walkMany = function (manyProd, currRest, prevRest) {\n    // ABC(DE)*F => after the (DE)* the rest is (DE)?F\n    var fullManyRest = [new Option({\n      definition: manyProd.definition\n    })].concat(currRest, prevRest);\n    this.walk(manyProd, fullManyRest);\n  };\n\n  RestWalker.prototype.walkManySep = function (manySepProd, currRest, prevRest) {\n    // ABC (DE(,DE)*)? F => after the (,DE)* the rest is (,DE)?F\n    var fullManySepRest = restForRepetitionWithSeparator(manySepProd, currRest, prevRest);\n    this.walk(manySepProd, fullManySepRest);\n  };\n\n  RestWalker.prototype.walkOr = function (orProd, currRest, prevRest) {\n    var _this = this; // ABC(D|E|F)G => when finding the (D|E|F) the rest is G\n\n\n    var fullOrRest = currRest.concat(prevRest); // walk all different alternatives\n\n    forEach(orProd.definition, function (alt) {\n      // wrapping each alternative in a single definition wrapper\n      // to avoid errors in computing the rest of that alternative in the invocation to computeInProdFollows\n      // (otherwise for OR([alt1,alt2]) alt2 will be considered in 'rest' of alt1\n      var prodWrapper = new Alternative({\n        definition: [alt]\n      });\n\n      _this.walk(prodWrapper, fullOrRest);\n    });\n  };\n\n  return RestWalker;\n}();\n\nexport { RestWalker };\n\nfunction restForRepetitionWithSeparator(repSepProd, currRest, prevRest) {\n  var repSepRest = [new Option({\n    definition: [new Terminal({\n      terminalType: repSepProd.separator\n    })].concat(repSepProd.definition)\n  })];\n  var fullRepSepRest = repSepRest.concat(currRest, prevRest);\n  return fullRepSepRest;\n}","map":{"version":3,"sources":["../../../../src/parse/grammar/rest.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["import { drop, forEach } from \"../../utils/utils\";\nimport { Alternation, Alternative, NonTerminal, Option, Repetition, RepetitionMandatory, RepetitionMandatoryWithSeparator, RepetitionWithSeparator, Terminal } from \"./gast/gast_public\";\n/**\n *  A Grammar Walker that computes the \"remaining\" grammar \"after\" a productions in the grammar.\n */\nvar RestWalker = /** @class */ (function () {\n    function RestWalker() {\n    }\n    RestWalker.prototype.walk = function (prod, prevRest) {\n        var _this = this;\n        if (prevRest === void 0) { prevRest = []; }\n        forEach(prod.definition, function (subProd, index) {\n            var currRest = drop(prod.definition, index + 1);\n            /* istanbul ignore else */\n            if (subProd instanceof NonTerminal) {\n                _this.walkProdRef(subProd, currRest, prevRest);\n            }\n            else if (subProd instanceof Terminal) {\n                _this.walkTerminal(subProd, currRest, prevRest);\n            }\n            else if (subProd instanceof Alternative) {\n                _this.walkFlat(subProd, currRest, prevRest);\n            }\n            else if (subProd instanceof Option) {\n                _this.walkOption(subProd, currRest, prevRest);\n            }\n            else if (subProd instanceof RepetitionMandatory) {\n                _this.walkAtLeastOne(subProd, currRest, prevRest);\n            }\n            else if (subProd instanceof RepetitionMandatoryWithSeparator) {\n                _this.walkAtLeastOneSep(subProd, currRest, prevRest);\n            }\n            else if (subProd instanceof RepetitionWithSeparator) {\n                _this.walkManySep(subProd, currRest, prevRest);\n            }\n            else if (subProd instanceof Repetition) {\n                _this.walkMany(subProd, currRest, prevRest);\n            }\n            else if (subProd instanceof Alternation) {\n                _this.walkOr(subProd, currRest, prevRest);\n            }\n            else {\n                throw Error(\"non exhaustive match\");\n            }\n        });\n    };\n    RestWalker.prototype.walkTerminal = function (terminal, currRest, prevRest) { };\n    RestWalker.prototype.walkProdRef = function (refProd, currRest, prevRest) { };\n    RestWalker.prototype.walkFlat = function (flatProd, currRest, prevRest) {\n        // ABCDEF => after the D the rest is EF\n        var fullOrRest = currRest.concat(prevRest);\n        this.walk(flatProd, fullOrRest);\n    };\n    RestWalker.prototype.walkOption = function (optionProd, currRest, prevRest) {\n        // ABC(DE)?F => after the (DE)? the rest is F\n        var fullOrRest = currRest.concat(prevRest);\n        this.walk(optionProd, fullOrRest);\n    };\n    RestWalker.prototype.walkAtLeastOne = function (atLeastOneProd, currRest, prevRest) {\n        // ABC(DE)+F => after the (DE)+ the rest is (DE)?F\n        var fullAtLeastOneRest = [\n            new Option({ definition: atLeastOneProd.definition })\n        ].concat(currRest, prevRest);\n        this.walk(atLeastOneProd, fullAtLeastOneRest);\n    };\n    RestWalker.prototype.walkAtLeastOneSep = function (atLeastOneSepProd, currRest, prevRest) {\n        // ABC DE(,DE)* F => after the (,DE)+ the rest is (,DE)?F\n        var fullAtLeastOneSepRest = restForRepetitionWithSeparator(atLeastOneSepProd, currRest, prevRest);\n        this.walk(atLeastOneSepProd, fullAtLeastOneSepRest);\n    };\n    RestWalker.prototype.walkMany = function (manyProd, currRest, prevRest) {\n        // ABC(DE)*F => after the (DE)* the rest is (DE)?F\n        var fullManyRest = [\n            new Option({ definition: manyProd.definition })\n        ].concat(currRest, prevRest);\n        this.walk(manyProd, fullManyRest);\n    };\n    RestWalker.prototype.walkManySep = function (manySepProd, currRest, prevRest) {\n        // ABC (DE(,DE)*)? F => after the (,DE)* the rest is (,DE)?F\n        var fullManySepRest = restForRepetitionWithSeparator(manySepProd, currRest, prevRest);\n        this.walk(manySepProd, fullManySepRest);\n    };\n    RestWalker.prototype.walkOr = function (orProd, currRest, prevRest) {\n        var _this = this;\n        // ABC(D|E|F)G => when finding the (D|E|F) the rest is G\n        var fullOrRest = currRest.concat(prevRest);\n        // walk all different alternatives\n        forEach(orProd.definition, function (alt) {\n            // wrapping each alternative in a single definition wrapper\n            // to avoid errors in computing the rest of that alternative in the invocation to computeInProdFollows\n            // (otherwise for OR([alt1,alt2]) alt2 will be considered in 'rest' of alt1\n            var prodWrapper = new Alternative({ definition: [alt] });\n            _this.walk(prodWrapper, fullOrRest);\n        });\n    };\n    return RestWalker;\n}());\nexport { RestWalker };\nfunction restForRepetitionWithSeparator(repSepProd, currRest, prevRest) {\n    var repSepRest = [\n        new Option({\n            definition: [new Terminal({ terminalType: repSepProd.separator })].concat(repSepProd.definition)\n        })\n    ];\n    var fullRepSepRest = repSepRest.concat(currRest, prevRest);\n    return fullRepSepRest;\n}\n//# sourceMappingURL=rest.js.map"]},"metadata":{},"sourceType":"module"}