{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.calcGridColWidth = calcGridColWidth;\nexports.calcGridItemPosition = calcGridItemPosition;\nexports.calcXY = calcXY;\nexports.calcWH = calcWH;\n/*:: import type { Position } from \"./utils\";*/\n\n/*:: export type PositionParams = {\n  margin: [number, number],\n  containerPadding: [number, number],\n  containerWidth: number,\n  cols: number,\n  rowHeight: number,\n  maxRows: number\n};*/\n// Helper for generating column width\n\nfunction calcGridColWidth(positionParams\n/*: PositionParams*/\n)\n/*: number*/\n{\n  var margin = positionParams.margin,\n      containerPadding = positionParams.containerPadding,\n      containerWidth = positionParams.containerWidth,\n      cols = positionParams.cols;\n  return (containerWidth - margin[0] * (cols - 1) - containerPadding[0] * 2) / cols;\n}\n/**\n * Return position on the page given an x, y, w, h.\n * left, top, width, height are all in pixels.\n * @param  {PositionParams} positionParams  Parameters of grid needed for coordinates calculations.\n * @param  {Number}  x                      X coordinate in grid units.\n * @param  {Number}  y                      Y coordinate in grid units.\n * @param  {Number}  w                      W coordinate in grid units.\n * @param  {Number}  h                      H coordinate in grid units.\n * @return {Position}                       Object containing coords.\n */\n\n\nfunction calcGridItemPosition(positionParams\n/*: PositionParams*/\n, x\n/*: number*/\n, y\n/*: number*/\n, w\n/*: number*/\n, h\n/*: number*/\n, state\n/*: ?Object*/\n)\n/*: Position*/\n{\n  var margin = positionParams.margin,\n      containerPadding = positionParams.containerPadding,\n      rowHeight = positionParams.rowHeight;\n  var colWidth = calcGridColWidth(positionParams);\n  var out = {}; // If resizing, use the exact width and height as returned from resizing callbacks.\n\n  if (state && state.resizing) {\n    out.width = Math.round(state.resizing.width);\n    out.height = Math.round(state.resizing.height);\n  } // Otherwise, calculate from grid units.\n  else {\n      // 0 * Infinity === NaN, which causes problems with resize constraints;\n      // Fix this if it occurs.\n      // Note we do it here rather than later because Math.round(Infinity) causes deopt\n      out.width = w === Infinity ? w : Math.round(colWidth * w + Math.max(0, w - 1) * margin[0]);\n      out.height = h === Infinity ? h : Math.round(rowHeight * h + Math.max(0, h - 1) * margin[1]);\n    } // If dragging, use the exact width and height as returned from dragging callbacks.\n\n\n  if (state && state.dragging) {\n    out.top = Math.round(state.dragging.top);\n    out.left = Math.round(state.dragging.left);\n  } // Otherwise, calculate from grid units.\n  else {\n      out.top = Math.round((rowHeight + margin[1]) * y + containerPadding[1]);\n      out.left = Math.round((colWidth + margin[0]) * x + containerPadding[0]);\n    }\n\n  return out;\n}\n/**\n * Translate x and y coordinates from pixels to grid units.\n * @param  {PositionParams} positionParams  Parameters of grid needed for coordinates calculations.\n * @param  {Number} top                     Top position (relative to parent) in pixels.\n * @param  {Number} left                    Left position (relative to parent) in pixels.\n * @param  {Number} w                       W coordinate in grid units.\n * @param  {Number} h                       H coordinate in grid units.\n * @return {Object}                         x and y in grid units.\n */\n\n\nfunction calcXY(positionParams\n/*: PositionParams*/\n, top\n/*: number*/\n, left\n/*: number*/\n, w\n/*: number*/\n, h\n/*: number*/\n)\n/*: { x: number, y: number }*/\n{\n  var margin = positionParams.margin,\n      cols = positionParams.cols,\n      rowHeight = positionParams.rowHeight,\n      maxRows = positionParams.maxRows;\n  var colWidth = calcGridColWidth(positionParams); // left = colWidth * x + margin * (x + 1)\n  // l = cx + m(x+1)\n  // l = cx + mx + m\n  // l - m = cx + mx\n  // l - m = x(c + m)\n  // (l - m) / (c + m) = x\n  // x = (left - margin) / (coldWidth + margin)\n\n  var x = Math.round((left - margin[0]) / (colWidth + margin[0]));\n  var y = Math.round((top - margin[1]) / (rowHeight + margin[1])); // Capping\n\n  x = Math.max(Math.min(x, cols - w), 0);\n  y = Math.max(Math.min(y, maxRows - h), 0);\n  return {\n    x: x,\n    y: y\n  };\n}\n/**\n * Given a height and width in pixel values, calculate grid units.\n * @param  {PositionParams} positionParams  Parameters of grid needed for coordinates calcluations.\n * @param  {Number} height                  Height in pixels.\n * @param  {Number} width                   Width in pixels.\n * @param  {Number} x                       X coordinate in grid units.\n * @param  {Number} y                       Y coordinate in grid units.\n * @return {Object}                         w, h as grid units.\n */\n\n\nfunction calcWH(positionParams\n/*: PositionParams*/\n, width\n/*: number*/\n, height\n/*: number*/\n, x\n/*: number*/\n, y\n/*: number*/\n)\n/*: { w: number, h: number }*/\n{\n  var margin = positionParams.margin,\n      maxRows = positionParams.maxRows,\n      cols = positionParams.cols,\n      rowHeight = positionParams.rowHeight;\n  var colWidth = calcGridColWidth(positionParams); // width = colWidth * w - (margin * (w - 1))\n  // ...\n  // w = (width + margin) / (colWidth + margin)\n\n  var w = Math.round((width + margin[0]) / (colWidth + margin[0]));\n  var h = Math.round((height + margin[1]) / (rowHeight + margin[1])); // Capping\n\n  w = Math.max(Math.min(w, cols - x), 0);\n  h = Math.max(Math.min(h, maxRows - y), 0);\n  return {\n    w: w,\n    h: h\n  };\n}","map":{"version":3,"sources":["/home/magoo/projects/keyrier-json/node_modules/react-grid-layout/build/calculateUtils.js"],"names":["Object","defineProperty","exports","value","calcGridColWidth","calcGridItemPosition","calcXY","calcWH","positionParams","margin","containerPadding","containerWidth","cols","x","y","w","h","state","rowHeight","colWidth","out","resizing","width","Math","round","height","Infinity","max","dragging","top","left","maxRows","min"],"mappings":"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","sourcesContent":["\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.calcGridColWidth = calcGridColWidth;\nexports.calcGridItemPosition = calcGridItemPosition;\nexports.calcXY = calcXY;\nexports.calcWH = calcWH;\n\n/*:: import type { Position } from \"./utils\";*/\n\n/*:: export type PositionParams = {\n  margin: [number, number],\n  containerPadding: [number, number],\n  containerWidth: number,\n  cols: number,\n  rowHeight: number,\n  maxRows: number\n};*/\n// Helper for generating column width\nfunction calcGridColWidth(positionParams\n/*: PositionParams*/\n)\n/*: number*/\n{\n  var margin = positionParams.margin,\n      containerPadding = positionParams.containerPadding,\n      containerWidth = positionParams.containerWidth,\n      cols = positionParams.cols;\n  return (containerWidth - margin[0] * (cols - 1) - containerPadding[0] * 2) / cols;\n}\n/**\n * Return position on the page given an x, y, w, h.\n * left, top, width, height are all in pixels.\n * @param  {PositionParams} positionParams  Parameters of grid needed for coordinates calculations.\n * @param  {Number}  x                      X coordinate in grid units.\n * @param  {Number}  y                      Y coordinate in grid units.\n * @param  {Number}  w                      W coordinate in grid units.\n * @param  {Number}  h                      H coordinate in grid units.\n * @return {Position}                       Object containing coords.\n */\n\n\nfunction calcGridItemPosition(positionParams\n/*: PositionParams*/\n, x\n/*: number*/\n, y\n/*: number*/\n, w\n/*: number*/\n, h\n/*: number*/\n, state\n/*: ?Object*/\n)\n/*: Position*/\n{\n  var margin = positionParams.margin,\n      containerPadding = positionParams.containerPadding,\n      rowHeight = positionParams.rowHeight;\n  var colWidth = calcGridColWidth(positionParams);\n  var out = {}; // If resizing, use the exact width and height as returned from resizing callbacks.\n\n  if (state && state.resizing) {\n    out.width = Math.round(state.resizing.width);\n    out.height = Math.round(state.resizing.height);\n  } // Otherwise, calculate from grid units.\n  else {\n      // 0 * Infinity === NaN, which causes problems with resize constraints;\n      // Fix this if it occurs.\n      // Note we do it here rather than later because Math.round(Infinity) causes deopt\n      out.width = w === Infinity ? w : Math.round(colWidth * w + Math.max(0, w - 1) * margin[0]);\n      out.height = h === Infinity ? h : Math.round(rowHeight * h + Math.max(0, h - 1) * margin[1]);\n    } // If dragging, use the exact width and height as returned from dragging callbacks.\n\n\n  if (state && state.dragging) {\n    out.top = Math.round(state.dragging.top);\n    out.left = Math.round(state.dragging.left);\n  } // Otherwise, calculate from grid units.\n  else {\n      out.top = Math.round((rowHeight + margin[1]) * y + containerPadding[1]);\n      out.left = Math.round((colWidth + margin[0]) * x + containerPadding[0]);\n    }\n\n  return out;\n}\n/**\n * Translate x and y coordinates from pixels to grid units.\n * @param  {PositionParams} positionParams  Parameters of grid needed for coordinates calculations.\n * @param  {Number} top                     Top position (relative to parent) in pixels.\n * @param  {Number} left                    Left position (relative to parent) in pixels.\n * @param  {Number} w                       W coordinate in grid units.\n * @param  {Number} h                       H coordinate in grid units.\n * @return {Object}                         x and y in grid units.\n */\n\n\nfunction calcXY(positionParams\n/*: PositionParams*/\n, top\n/*: number*/\n, left\n/*: number*/\n, w\n/*: number*/\n, h\n/*: number*/\n)\n/*: { x: number, y: number }*/\n{\n  var margin = positionParams.margin,\n      cols = positionParams.cols,\n      rowHeight = positionParams.rowHeight,\n      maxRows = positionParams.maxRows;\n  var colWidth = calcGridColWidth(positionParams); // left = colWidth * x + margin * (x + 1)\n  // l = cx + m(x+1)\n  // l = cx + mx + m\n  // l - m = cx + mx\n  // l - m = x(c + m)\n  // (l - m) / (c + m) = x\n  // x = (left - margin) / (coldWidth + margin)\n\n  var x = Math.round((left - margin[0]) / (colWidth + margin[0]));\n  var y = Math.round((top - margin[1]) / (rowHeight + margin[1])); // Capping\n\n  x = Math.max(Math.min(x, cols - w), 0);\n  y = Math.max(Math.min(y, maxRows - h), 0);\n  return {\n    x: x,\n    y: y\n  };\n}\n/**\n * Given a height and width in pixel values, calculate grid units.\n * @param  {PositionParams} positionParams  Parameters of grid needed for coordinates calcluations.\n * @param  {Number} height                  Height in pixels.\n * @param  {Number} width                   Width in pixels.\n * @param  {Number} x                       X coordinate in grid units.\n * @param  {Number} y                       Y coordinate in grid units.\n * @return {Object}                         w, h as grid units.\n */\n\n\nfunction calcWH(positionParams\n/*: PositionParams*/\n, width\n/*: number*/\n, height\n/*: number*/\n, x\n/*: number*/\n, y\n/*: number*/\n)\n/*: { w: number, h: number }*/\n{\n  var margin = positionParams.margin,\n      maxRows = positionParams.maxRows,\n      cols = positionParams.cols,\n      rowHeight = positionParams.rowHeight;\n  var colWidth = calcGridColWidth(positionParams); // width = colWidth * w - (margin * (w - 1))\n  // ...\n  // w = (width + margin) / (colWidth + margin)\n\n  var w = Math.round((width + margin[0]) / (colWidth + margin[0]));\n  var h = Math.round((height + margin[1]) / (rowHeight + margin[1])); // Capping\n\n  w = Math.max(Math.min(w, cols - x), 0);\n  h = Math.max(Math.min(h, maxRows - y), 0);\n  return {\n    w: w,\n    h: h\n  };\n}"]},"metadata":{},"sourceType":"script"}