{"ast":null,"code":"/* eslint-disable */\nimport { useCallback, useMemo, useRef, useState } from 'react';\nimport { useFirstMountState } from './useFirstMountState';\nimport { resolveHookState } from './util/resolveHookState';\nexport function useStateWithHistory(initialState, capacity, initialHistory) {\n  if (capacity === void 0) {\n    capacity = 10;\n  }\n\n  if (capacity < 1) {\n    throw new Error(\"Capacity has to be greater than 1, got '\" + capacity + \"'\");\n  }\n\n  var isFirstMount = useFirstMountState();\n\n  var _a = useState(initialState),\n      state = _a[0],\n      innerSetState = _a[1];\n\n  var history = useRef(initialHistory !== null && initialHistory !== void 0 ? initialHistory : []);\n  var historyPosition = useRef(0); // do the states manipulation only on first mount, no sense to load re-renders with useless calculations\n\n  if (isFirstMount) {\n    if (history.current.length) {\n      // if last element of history !== initial - push initial to history\n      if (history.current[history.current.length - 1] !== initialState) {\n        history.current.push(initialState);\n      } // if initial history bigger that capacity - crop the first elements out\n\n\n      if (history.current.length > capacity) {\n        history.current = history.current.slice(history.current.length - capacity);\n      }\n    } else {\n      // initiate the history with initial state\n      history.current.push(initialState);\n    }\n\n    historyPosition.current = history.current.length && history.current.length - 1;\n  }\n\n  var setState = useCallback(function (newState) {\n    innerSetState(function (currentState) {\n      newState = resolveHookState(newState); // is state has changed\n\n      if (newState !== currentState) {\n        // if current position is not the last - pop element to the right\n        if (historyPosition.current < history.current.length - 1) {\n          history.current = history.current.slice(0, historyPosition.current + 1);\n        }\n\n        historyPosition.current = history.current.push(newState) - 1; // if capacity is reached - shift first elements\n\n        if (history.current.length > capacity) {\n          history.current = history.current.slice(history.current.length - capacity);\n        }\n      }\n\n      return newState;\n    });\n  }, [state, capacity]);\n  var historyState = useMemo(function () {\n    return {\n      history: history.current,\n      position: historyPosition.current,\n      capacity: capacity,\n      back: function (amount) {\n        if (amount === void 0) {\n          amount = 1;\n        } // don't do anything if we already at the left border\n\n\n        if (!historyPosition.current) {\n          return;\n        }\n\n        innerSetState(function () {\n          historyPosition.current -= Math.min(amount, historyPosition.current);\n          return history.current[historyPosition.current];\n        });\n      },\n      forward: function (amount) {\n        if (amount === void 0) {\n          amount = 1;\n        } // don't do anything if we already at the right border\n\n\n        if (historyPosition.current === history.current.length - 1) {\n          return;\n        }\n\n        innerSetState(function () {\n          historyPosition.current = Math.min(historyPosition.current + amount, history.current.length - 1);\n          return history.current[historyPosition.current];\n        });\n      },\n      go: function (position) {\n        if (position === historyPosition.current) {\n          return;\n        }\n\n        innerSetState(function () {\n          historyPosition.current = position < 0 ? Math.max(history.current.length + position, 0) : Math.min(history.current.length - 1, position);\n          return history.current[historyPosition.current];\n        });\n      }\n    };\n  }, [state]);\n  return [state, setState, historyState];\n}","map":{"version":3,"sources":["/home/magoo/projects/keyrier-json/node_modules/react-use/esm/useStateWithHistory.js"],"names":["useCallback","useMemo","useRef","useState","useFirstMountState","resolveHookState","useStateWithHistory","initialState","capacity","initialHistory","Error","isFirstMount","_a","state","innerSetState","history","historyPosition","current","length","push","slice","setState","newState","currentState","historyState","position","back","amount","Math","min","forward","go","max"],"mappings":"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","sourcesContent":["/* eslint-disable */\nimport { useCallback, useMemo, useRef, useState } from 'react';\nimport { useFirstMountState } from './useFirstMountState';\nimport { resolveHookState } from './util/resolveHookState';\nexport function useStateWithHistory(initialState, capacity, initialHistory) {\n    if (capacity === void 0) { capacity = 10; }\n    if (capacity < 1) {\n        throw new Error(\"Capacity has to be greater than 1, got '\" + capacity + \"'\");\n    }\n    var isFirstMount = useFirstMountState();\n    var _a = useState(initialState), state = _a[0], innerSetState = _a[1];\n    var history = useRef((initialHistory !== null && initialHistory !== void 0 ? initialHistory : []));\n    var historyPosition = useRef(0);\n    // do the states manipulation only on first mount, no sense to load re-renders with useless calculations\n    if (isFirstMount) {\n        if (history.current.length) {\n            // if last element of history !== initial - push initial to history\n            if (history.current[history.current.length - 1] !== initialState) {\n                history.current.push(initialState);\n            }\n            // if initial history bigger that capacity - crop the first elements out\n            if (history.current.length > capacity) {\n                history.current = history.current.slice(history.current.length - capacity);\n            }\n        }\n        else {\n            // initiate the history with initial state\n            history.current.push(initialState);\n        }\n        historyPosition.current = history.current.length && history.current.length - 1;\n    }\n    var setState = useCallback(function (newState) {\n        innerSetState(function (currentState) {\n            newState = resolveHookState(newState);\n            // is state has changed\n            if (newState !== currentState) {\n                // if current position is not the last - pop element to the right\n                if (historyPosition.current < history.current.length - 1) {\n                    history.current = history.current.slice(0, historyPosition.current + 1);\n                }\n                historyPosition.current = history.current.push(newState) - 1;\n                // if capacity is reached - shift first elements\n                if (history.current.length > capacity) {\n                    history.current = history.current.slice(history.current.length - capacity);\n                }\n            }\n            return newState;\n        });\n    }, [state, capacity]);\n    var historyState = useMemo(function () { return ({\n        history: history.current,\n        position: historyPosition.current,\n        capacity: capacity,\n        back: function (amount) {\n            if (amount === void 0) { amount = 1; }\n            // don't do anything if we already at the left border\n            if (!historyPosition.current) {\n                return;\n            }\n            innerSetState(function () {\n                historyPosition.current -= Math.min(amount, historyPosition.current);\n                return history.current[historyPosition.current];\n            });\n        },\n        forward: function (amount) {\n            if (amount === void 0) { amount = 1; }\n            // don't do anything if we already at the right border\n            if (historyPosition.current === history.current.length - 1) {\n                return;\n            }\n            innerSetState(function () {\n                historyPosition.current = Math.min(historyPosition.current + amount, history.current.length - 1);\n                return history.current[historyPosition.current];\n            });\n        },\n        go: function (position) {\n            if (position === historyPosition.current) {\n                return;\n            }\n            innerSetState(function () {\n                historyPosition.current =\n                    position < 0\n                        ? Math.max(history.current.length + position, 0)\n                        : Math.min(history.current.length - 1, position);\n                return history.current[historyPosition.current];\n            });\n        },\n    }); }, [state]);\n    return [state, setState, historyState];\n}\n"]},"metadata":{},"sourceType":"module"}