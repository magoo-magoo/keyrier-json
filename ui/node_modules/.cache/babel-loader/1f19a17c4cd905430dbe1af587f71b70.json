{"ast":null,"code":"ace.define(\"ace/keyboard/vim\", [\"require\", \"exports\", \"module\", \"ace/range\", \"ace/lib/event_emitter\", \"ace/lib/dom\", \"ace/lib/oop\", \"ace/lib/keys\", \"ace/lib/event\", \"ace/search\", \"ace/lib/useragent\", \"ace/search_highlight\", \"ace/commands/multi_select_commands\", \"ace/mode/text\", \"ace/multi_select\"], function (require, exports, module) {\n  'use strict';\n\n  function log() {\n    var d = \"\";\n\n    function format(p) {\n      if (typeof p != \"object\") return p + \"\";\n\n      if (\"line\" in p) {\n        return p.line + \":\" + p.ch;\n      }\n\n      if (\"anchor\" in p) {\n        return format(p.anchor) + \"->\" + format(p.head);\n      }\n\n      if (Array.isArray(p)) return \"[\" + p.map(function (x) {\n        return format(x);\n      }) + \"]\";\n      return JSON.stringify(p);\n    }\n\n    for (var i = 0; i < arguments.length; i++) {\n      var p = arguments[i];\n      var f = format(p);\n      d += f + \"  \";\n    }\n\n    console.log(d);\n  }\n\n  var Range = require(\"../range\").Range;\n\n  var EventEmitter = require(\"../lib/event_emitter\").EventEmitter;\n\n  var dom = require(\"../lib/dom\");\n\n  var oop = require(\"../lib/oop\");\n\n  var KEYS = require(\"../lib/keys\");\n\n  var event = require(\"../lib/event\");\n\n  var Search = require(\"../search\").Search;\n\n  var useragent = require(\"../lib/useragent\");\n\n  var SearchHighlight = require(\"../search_highlight\").SearchHighlight;\n\n  var multiSelectCommands = require(\"../commands/multi_select_commands\");\n\n  var TextModeTokenRe = require(\"../mode/text\").Mode.prototype.tokenRe;\n\n  require(\"../multi_select\");\n\n  var CodeMirror = function (ace) {\n    this.ace = ace;\n    this.state = {};\n    this.marks = {};\n    this.$uid = 0;\n    this.onChange = this.onChange.bind(this);\n    this.onSelectionChange = this.onSelectionChange.bind(this);\n    this.onBeforeEndOperation = this.onBeforeEndOperation.bind(this);\n    this.ace.on('change', this.onChange);\n    this.ace.on('changeSelection', this.onSelectionChange);\n    this.ace.on('beforeEndOperation', this.onBeforeEndOperation);\n  };\n\n  CodeMirror.Pos = function (line, ch) {\n    if (!(this instanceof Pos)) return new Pos(line, ch);\n    this.line = line;\n    this.ch = ch;\n  };\n\n  CodeMirror.defineOption = function (name, val, setter) {};\n\n  CodeMirror.commands = {\n    redo: function (cm) {\n      cm.ace.redo();\n    },\n    undo: function (cm) {\n      cm.ace.undo();\n    },\n    newlineAndIndent: function (cm) {\n      cm.ace.insert(\"\\n\");\n    }\n  };\n  CodeMirror.keyMap = {};\n\n  CodeMirror.addClass = CodeMirror.rmClass = function () {};\n\n  CodeMirror.e_stop = CodeMirror.e_preventDefault = event.stopEvent;\n\n  CodeMirror.keyName = function (e) {\n    var key = KEYS[e.keyCode] || e.key || \"\";\n    if (key.length == 1) key = key.toUpperCase();\n    key = event.getModifierString(e).replace(/(^|-)\\w/g, function (m) {\n      return m.toUpperCase();\n    }) + key;\n    return key;\n  };\n\n  CodeMirror.keyMap['default'] = function (key) {\n    return function (cm) {\n      var cmd = cm.ace.commands.commandKeyBinding[key.toLowerCase()];\n      return cmd && cm.ace.execCommand(cmd) !== false;\n    };\n  };\n\n  CodeMirror.lookupKey = function lookupKey(key, map, handle) {\n    if (!map) map = \"default\";\n    if (typeof map == \"string\") map = CodeMirror.keyMap[map];\n    var found = typeof map == \"function\" ? map(key) : map[key];\n    if (found === false) return \"nothing\";\n    if (found === \"...\") return \"multi\";\n    if (found != null && handle(found)) return \"handled\";\n\n    if (map.fallthrough) {\n      if (!Array.isArray(map.fallthrough)) return lookupKey(key, map.fallthrough, handle);\n\n      for (var i = 0; i < map.fallthrough.length; i++) {\n        var result = lookupKey(key, map.fallthrough[i], handle);\n        if (result) return result;\n      }\n    }\n  };\n\n  CodeMirror.signal = function (o, name, e) {\n    return o._signal(name, e);\n  };\n\n  CodeMirror.on = event.addListener;\n  CodeMirror.off = event.removeListener;\n\n  CodeMirror.isWordChar = function (ch) {\n    if (ch < \"\\x7f\") return /^\\w$/.test(ch);\n    TextModeTokenRe.lastIndex = 0;\n    return TextModeTokenRe.test(ch);\n  };\n\n  (function () {\n    oop.implement(CodeMirror.prototype, EventEmitter);\n\n    this.destroy = function () {\n      this.ace.off('change', this.onChange);\n      this.ace.off('changeSelection', this.onSelectionChange);\n      this.ace.off('beforeEndOperation', this.onBeforeEndOperation);\n      this.removeOverlay();\n    };\n\n    this.virtualSelectionMode = function () {\n      return this.ace.inVirtualSelectionMode && this.ace.selection.index;\n    };\n\n    this.onChange = function (delta) {\n      var change = {\n        text: delta.action[0] == 'i' ? delta.lines : []\n      };\n      var curOp = this.curOp = this.curOp || {};\n      if (!curOp.changeHandlers) curOp.changeHandlers = this._eventRegistry[\"change\"] && this._eventRegistry[\"change\"].slice();\n\n      if (!curOp.lastChange) {\n        curOp.lastChange = curOp.change = change;\n      } else {\n        curOp.lastChange.next = curOp.lastChange = change;\n      }\n\n      this.$updateMarkers(delta);\n    };\n\n    this.onSelectionChange = function () {\n      var curOp = this.curOp = this.curOp || {};\n      if (!curOp.cursorActivityHandlers) curOp.cursorActivityHandlers = this._eventRegistry[\"cursorActivity\"] && this._eventRegistry[\"cursorActivity\"].slice();\n      this.curOp.cursorActivity = true;\n\n      if (this.ace.inMultiSelectMode) {\n        this.ace.keyBinding.removeKeyboardHandler(multiSelectCommands.keyboardHandler);\n      }\n    };\n\n    this.operation = function (fn, force) {\n      if (!force && this.curOp || force && this.curOp && this.curOp.force) {\n        return fn();\n      }\n\n      if (force || !this.ace.curOp) {\n        if (this.curOp) this.onBeforeEndOperation();\n      }\n\n      if (!this.ace.curOp) {\n        var prevOp = this.ace.prevOp;\n        this.ace.startOperation({\n          command: {\n            name: \"vim\",\n            scrollIntoView: \"cursor\"\n          }\n        });\n      }\n\n      var curOp = this.curOp = this.curOp || {};\n      this.curOp.force = force;\n      var result = fn();\n\n      if (this.ace.curOp && this.ace.curOp.command.name == \"vim\") {\n        if (this.state.dialog) this.ace.curOp.command.scrollIntoView = false;\n        this.ace.endOperation();\n        if (!curOp.cursorActivity && !curOp.lastChange && prevOp) this.ace.prevOp = prevOp;\n      }\n\n      if (force || !this.ace.curOp) {\n        if (this.curOp) this.onBeforeEndOperation();\n      }\n\n      return result;\n    };\n\n    this.onBeforeEndOperation = function () {\n      var op = this.curOp;\n\n      if (op) {\n        if (op.change) {\n          this.signal(\"change\", op.change, op);\n        }\n\n        if (op && op.cursorActivity) {\n          this.signal(\"cursorActivity\", null, op);\n        }\n\n        this.curOp = null;\n      }\n    };\n\n    this.signal = function (eventName, e, handlers) {\n      var listeners = handlers ? handlers[eventName + \"Handlers\"] : (this._eventRegistry || {})[eventName];\n      if (!listeners) return;\n      listeners = listeners.slice();\n\n      for (var i = 0; i < listeners.length; i++) listeners[i](this, e);\n    };\n\n    this.firstLine = function () {\n      return 0;\n    };\n\n    this.lastLine = function () {\n      return this.ace.session.getLength() - 1;\n    };\n\n    this.lineCount = function () {\n      return this.ace.session.getLength();\n    };\n\n    this.setCursor = function (line, ch) {\n      if (typeof line === 'object') {\n        ch = line.ch;\n        line = line.line;\n      }\n\n      if (!this.ace.inVirtualSelectionMode) this.ace.exitMultiSelectMode();\n      this.ace.session.unfold({\n        row: line,\n        column: ch\n      });\n      this.ace.selection.moveTo(line, ch);\n    };\n\n    this.getCursor = function (p) {\n      var sel = this.ace.selection;\n      var pos = p == 'anchor' ? sel.isEmpty() ? sel.lead : sel.anchor : p == 'head' || !p ? sel.lead : sel.getRange()[p];\n      return toCmPos(pos);\n    };\n\n    this.listSelections = function (p) {\n      var ranges = this.ace.multiSelect.rangeList.ranges;\n      if (!ranges.length || this.ace.inVirtualSelectionMode) return [{\n        anchor: this.getCursor('anchor'),\n        head: this.getCursor('head')\n      }];\n      return ranges.map(function (r) {\n        return {\n          anchor: this.clipPos(toCmPos(r.cursor == r.end ? r.start : r.end)),\n          head: this.clipPos(toCmPos(r.cursor))\n        };\n      }, this);\n    };\n\n    this.setSelections = function (p, primIndex) {\n      var sel = this.ace.multiSelect;\n      var ranges = p.map(function (x) {\n        var anchor = toAcePos(x.anchor);\n        var head = toAcePos(x.head);\n        var r = Range.comparePoints(anchor, head) < 0 ? new Range.fromPoints(anchor, head) : new Range.fromPoints(head, anchor);\n        r.cursor = Range.comparePoints(r.start, head) ? r.end : r.start;\n        return r;\n      });\n\n      if (this.ace.inVirtualSelectionMode) {\n        this.ace.selection.fromOrientedRange(ranges[0]);\n        return;\n      }\n\n      if (!primIndex) {\n        ranges = ranges.reverse();\n      } else if (ranges[primIndex]) {\n        ranges.push(ranges.splice(primIndex, 1)[0]);\n      }\n\n      sel.toSingleRange(ranges[0].clone());\n      var session = this.ace.session;\n\n      for (var i = 0; i < ranges.length; i++) {\n        var range = session.$clipRangeToDocument(ranges[i]); // todo why ace doesn't do this?\n\n        sel.addRange(range);\n      }\n    };\n\n    this.setSelection = function (a, h, options) {\n      var sel = this.ace.selection;\n      sel.moveTo(a.line, a.ch);\n      sel.selectTo(h.line, h.ch);\n\n      if (options && options.origin == '*mouse') {\n        this.onBeforeEndOperation();\n      }\n    };\n\n    this.somethingSelected = function (p) {\n      return !this.ace.selection.isEmpty();\n    };\n\n    this.clipPos = function (p) {\n      var pos = this.ace.session.$clipPositionToDocument(p.line, p.ch);\n      return toCmPos(pos);\n    };\n\n    this.markText = function (cursor) {\n      return {\n        clear: function () {},\n        find: function () {}\n      };\n    };\n\n    this.$updateMarkers = function (delta) {\n      var isInsert = delta.action == \"insert\";\n      var start = delta.start;\n      var end = delta.end;\n      var rowShift = (end.row - start.row) * (isInsert ? 1 : -1);\n      var colShift = (end.column - start.column) * (isInsert ? 1 : -1);\n      if (isInsert) end = start;\n\n      for (var i in this.marks) {\n        var point = this.marks[i];\n        var cmp = Range.comparePoints(point, start);\n\n        if (cmp < 0) {\n          continue; // delta starts after the range\n        }\n\n        if (cmp === 0) {\n          if (isInsert) {\n            if (point.bias == 1) {\n              cmp = 1;\n            } else {\n              point.bias = -1;\n              continue;\n            }\n          }\n        }\n\n        var cmp2 = isInsert ? cmp : Range.comparePoints(point, end);\n\n        if (cmp2 > 0) {\n          point.row += rowShift;\n          point.column += point.row == end.row ? colShift : 0;\n          continue;\n        }\n\n        if (!isInsert && cmp2 <= 0) {\n          point.row = start.row;\n          point.column = start.column;\n          if (cmp2 === 0) point.bias = 1;\n        }\n      }\n    };\n\n    var Marker = function (cm, id, row, column) {\n      this.cm = cm;\n      this.id = id;\n      this.row = row;\n      this.column = column;\n      cm.marks[this.id] = this;\n    };\n\n    Marker.prototype.clear = function () {\n      delete this.cm.marks[this.id];\n    };\n\n    Marker.prototype.find = function () {\n      return toCmPos(this);\n    };\n\n    this.setBookmark = function (cursor, options) {\n      var bm = new Marker(this, this.$uid++, cursor.line, cursor.ch);\n      if (!options || !options.insertLeft) bm.$insertRight = true;\n      this.marks[bm.id] = bm;\n      return bm;\n    };\n\n    this.moveH = function (increment, unit) {\n      if (unit == 'char') {\n        var sel = this.ace.selection;\n        sel.clearSelection();\n        sel.moveCursorBy(0, increment);\n      }\n    };\n\n    this.findPosV = function (start, amount, unit, goalColumn) {\n      if (unit == 'page') {\n        var renderer = this.ace.renderer;\n        var config = renderer.layerConfig;\n        amount = amount * Math.floor(config.height / config.lineHeight);\n        unit = 'line';\n      }\n\n      if (unit == 'line') {\n        var screenPos = this.ace.session.documentToScreenPosition(start.line, start.ch);\n        if (goalColumn != null) screenPos.column = goalColumn;\n        screenPos.row += amount;\n        screenPos.row = Math.min(Math.max(0, screenPos.row), this.ace.session.getScreenLength() - 1);\n        var pos = this.ace.session.screenToDocumentPosition(screenPos.row, screenPos.column);\n        return toCmPos(pos);\n      } else {\n        debugger;\n      }\n    };\n\n    this.charCoords = function (pos, mode) {\n      if (mode == 'div' || !mode) {\n        var sc = this.ace.session.documentToScreenPosition(pos.line, pos.ch);\n        return {\n          left: sc.column,\n          top: sc.row\n        };\n      }\n\n      if (mode == 'local') {\n        var renderer = this.ace.renderer;\n        var sc = this.ace.session.documentToScreenPosition(pos.line, pos.ch);\n        var lh = renderer.layerConfig.lineHeight;\n        var cw = renderer.layerConfig.characterWidth;\n        var top = lh * sc.row;\n        return {\n          left: sc.column * cw,\n          top: top,\n          bottom: top + lh\n        };\n      }\n    };\n\n    this.coordsChar = function (pos, mode) {\n      var renderer = this.ace.renderer;\n\n      if (mode == 'local') {\n        var row = Math.max(0, Math.floor(pos.top / renderer.lineHeight));\n        var col = Math.max(0, Math.floor(pos.left / renderer.characterWidth));\n        var ch = renderer.session.screenToDocumentPosition(row, col);\n        return toCmPos(ch);\n      } else if (mode == 'div') {\n        throw \"not implemented\";\n      }\n    };\n\n    this.getSearchCursor = function (query, pos, caseFold) {\n      var caseSensitive = false;\n      var isRegexp = false;\n\n      if (query instanceof RegExp && !query.global) {\n        caseSensitive = !query.ignoreCase;\n        query = query.source;\n        isRegexp = true;\n      }\n\n      var search = new Search();\n      if (pos.ch == undefined) pos.ch = Number.MAX_VALUE;\n      var acePos = {\n        row: pos.line,\n        column: pos.ch\n      };\n      var cm = this;\n      var last = null;\n      return {\n        findNext: function () {\n          return this.find(false);\n        },\n        findPrevious: function () {\n          return this.find(true);\n        },\n        find: function (back) {\n          search.setOptions({\n            needle: query,\n            caseSensitive: caseSensitive,\n            wrap: false,\n            backwards: back,\n            regExp: isRegexp,\n            start: last || acePos\n          });\n          var range = search.find(cm.ace.session);\n\n          if (range && range.isEmpty()) {\n            if (cm.getLine(range.start.row).length == range.start.column) {\n              search.$options.start = range;\n              range = search.find(cm.ace.session);\n            }\n          }\n\n          last = range;\n          return last;\n        },\n        from: function () {\n          return last && toCmPos(last.start);\n        },\n        to: function () {\n          return last && toCmPos(last.end);\n        },\n        replace: function (text) {\n          if (last) {\n            last.end = cm.ace.session.doc.replace(last, text);\n          }\n        }\n      };\n    };\n\n    this.scrollTo = function (x, y) {\n      var renderer = this.ace.renderer;\n      var config = renderer.layerConfig;\n      var maxHeight = config.maxHeight;\n      maxHeight -= (renderer.$size.scrollerHeight - renderer.lineHeight) * renderer.$scrollPastEnd;\n      if (y != null) this.ace.session.setScrollTop(Math.max(0, Math.min(y, maxHeight)));\n      if (x != null) this.ace.session.setScrollLeft(Math.max(0, Math.min(x, config.width)));\n    };\n\n    this.scrollInfo = function () {\n      return 0;\n    };\n\n    this.scrollIntoView = function (pos, margin) {\n      if (pos) {\n        var renderer = this.ace.renderer;\n        var viewMargin = {\n          \"top\": 0,\n          \"bottom\": margin\n        };\n        renderer.scrollCursorIntoView(toAcePos(pos), renderer.lineHeight * 2 / renderer.$size.scrollerHeight, viewMargin);\n      }\n    };\n\n    this.getLine = function (row) {\n      return this.ace.session.getLine(row);\n    };\n\n    this.getRange = function (s, e) {\n      return this.ace.session.getTextRange(new Range(s.line, s.ch, e.line, e.ch));\n    };\n\n    this.replaceRange = function (text, s, e) {\n      if (!e) e = s;\n      return this.ace.session.replace(new Range(s.line, s.ch, e.line, e.ch), text);\n    };\n\n    this.replaceSelection = this.replaceSelections = function (p) {\n      var sel = this.ace.selection;\n\n      if (this.ace.inVirtualSelectionMode) {\n        this.ace.session.replace(sel.getRange(), p[0] || \"\");\n        return;\n      }\n\n      sel.inVirtualSelectionMode = true;\n      var ranges = sel.rangeList.ranges;\n      if (!ranges.length) ranges = [this.ace.multiSelect.getRange()];\n\n      for (var i = ranges.length; i--;) this.ace.session.replace(ranges[i], p[i] || \"\");\n\n      sel.inVirtualSelectionMode = false;\n    };\n\n    this.getSelection = function () {\n      return this.ace.getSelectedText();\n    };\n\n    this.getSelections = function () {\n      return this.listSelections().map(function (x) {\n        return this.getRange(x.anchor, x.head);\n      }, this);\n    };\n\n    this.getInputField = function () {\n      return this.ace.textInput.getElement();\n    };\n\n    this.getWrapperElement = function () {\n      return this.ace.container;\n    };\n\n    var optMap = {\n      indentWithTabs: \"useSoftTabs\",\n      indentUnit: \"tabSize\",\n      tabSize: \"tabSize\",\n      firstLineNumber: \"firstLineNumber\",\n      readOnly: \"readOnly\"\n    };\n\n    this.setOption = function (name, val) {\n      this.state[name] = val;\n\n      switch (name) {\n        case 'indentWithTabs':\n          name = optMap[name];\n          val = !val;\n          break;\n\n        case 'keyMap':\n          this.state.$keyMap = val;\n          return;\n          break;\n\n        default:\n          name = optMap[name];\n      }\n\n      if (name) this.ace.setOption(name, val);\n    };\n\n    this.getOption = function (name, val) {\n      var aceOpt = optMap[name];\n      if (aceOpt) val = this.ace.getOption(aceOpt);\n\n      switch (name) {\n        case 'indentWithTabs':\n          name = optMap[name];\n          return !val;\n\n        case 'keyMap':\n          return this.state.$keyMap;\n      }\n\n      return aceOpt ? val : this.state[name];\n    };\n\n    this.toggleOverwrite = function (on) {\n      this.state.overwrite = on;\n      return this.ace.setOverwrite(on);\n    };\n\n    this.addOverlay = function (o) {\n      if (!this.$searchHighlight || !this.$searchHighlight.session) {\n        var highlight = new SearchHighlight(null, \"ace_highlight-marker\", \"text\");\n        var marker = this.ace.session.addDynamicMarker(highlight);\n        highlight.id = marker.id;\n        highlight.session = this.ace.session;\n\n        highlight.destroy = function (o) {\n          highlight.session.off(\"change\", highlight.updateOnChange);\n          highlight.session.off(\"changeEditor\", highlight.destroy);\n          highlight.session.removeMarker(highlight.id);\n          highlight.session = null;\n        };\n\n        highlight.updateOnChange = function (delta) {\n          var row = delta.start.row;\n          if (row == delta.end.row) highlight.cache[row] = undefined;else highlight.cache.splice(row, highlight.cache.length);\n        };\n\n        highlight.session.on(\"changeEditor\", highlight.destroy);\n        highlight.session.on(\"change\", highlight.updateOnChange);\n      }\n\n      var re = new RegExp(o.query.source, \"gmi\");\n      this.$searchHighlight = o.highlight = highlight;\n      this.$searchHighlight.setRegexp(re);\n      this.ace.renderer.updateBackMarkers();\n    };\n\n    this.removeOverlay = function (o) {\n      if (this.$searchHighlight && this.$searchHighlight.session) {\n        this.$searchHighlight.destroy();\n      }\n    };\n\n    this.getScrollInfo = function () {\n      var renderer = this.ace.renderer;\n      var config = renderer.layerConfig;\n      return {\n        left: renderer.scrollLeft,\n        top: renderer.scrollTop,\n        height: config.maxHeight,\n        width: config.width,\n        clientHeight: config.height,\n        clientWidth: config.width\n      };\n    };\n\n    this.getValue = function () {\n      return this.ace.getValue();\n    };\n\n    this.setValue = function (v) {\n      return this.ace.setValue(v, -1);\n    };\n\n    this.getTokenTypeAt = function (pos) {\n      var token = this.ace.session.getTokenAt(pos.line, pos.ch);\n      return token && /comment|string/.test(token.type) ? \"string\" : \"\";\n    };\n\n    this.findMatchingBracket = function (pos) {\n      var m = this.ace.session.findMatchingBracket(toAcePos(pos));\n      return {\n        to: m && toCmPos(m)\n      };\n    };\n\n    this.indentLine = function (line, method) {\n      if (method === true) this.ace.session.indentRows(line, line, \"\\t\");else if (method === false) this.ace.session.outdentRows(new Range(line, 0, line, 0));\n    };\n\n    this.indexFromPos = function (pos) {\n      return this.ace.session.doc.positionToIndex(toAcePos(pos));\n    };\n\n    this.posFromIndex = function (index) {\n      return toCmPos(this.ace.session.doc.indexToPosition(index));\n    };\n\n    this.focus = function (index) {\n      return this.ace.textInput.focus();\n    };\n\n    this.blur = function (index) {\n      return this.ace.blur();\n    };\n\n    this.defaultTextHeight = function (index) {\n      return this.ace.renderer.layerConfig.lineHeight;\n    };\n\n    this.scanForBracket = function (pos, dir, _, options) {\n      var re = options.bracketRegex.source;\n      var tokenRe = /paren|text|operator|tag/;\n\n      if (dir == 1) {\n        var m = this.ace.session.$findClosingBracket(re.slice(1, 2), toAcePos(pos), tokenRe);\n      } else {\n        var m = this.ace.session.$findOpeningBracket(re.slice(-2, -1), {\n          row: pos.line,\n          column: pos.ch + 1\n        }, tokenRe);\n      }\n\n      return m && {\n        pos: toCmPos(m)\n      };\n    };\n\n    this.refresh = function () {\n      return this.ace.resize(true);\n    };\n\n    this.getMode = function () {\n      return {\n        name: this.getOption(\"mode\")\n      };\n    };\n\n    this.execCommand = function (name) {\n      if (name == \"indentAuto\") this.ace.execCommand(\"autoindent\");else console.log(name + \" is not implemented\");\n    };\n  }).call(CodeMirror.prototype);\n\n  function toAcePos(cmPos) {\n    return {\n      row: cmPos.line,\n      column: cmPos.ch\n    };\n  }\n\n  function toCmPos(acePos) {\n    return new Pos(acePos.row, acePos.column);\n  }\n\n  var StringStream = CodeMirror.StringStream = function (string, tabSize) {\n    this.pos = this.start = 0;\n    this.string = string;\n    this.tabSize = tabSize || 8;\n    this.lastColumnPos = this.lastColumnValue = 0;\n    this.lineStart = 0;\n  };\n\n  StringStream.prototype = {\n    eol: function () {\n      return this.pos >= this.string.length;\n    },\n    sol: function () {\n      return this.pos == this.lineStart;\n    },\n    peek: function () {\n      return this.string.charAt(this.pos) || undefined;\n    },\n    next: function () {\n      if (this.pos < this.string.length) return this.string.charAt(this.pos++);\n    },\n    eat: function (match) {\n      var ch = this.string.charAt(this.pos);\n      if (typeof match == \"string\") var ok = ch == match;else var ok = ch && (match.test ? match.test(ch) : match(ch));\n\n      if (ok) {\n        ++this.pos;\n        return ch;\n      }\n    },\n    eatWhile: function (match) {\n      var start = this.pos;\n\n      while (this.eat(match)) {}\n\n      return this.pos > start;\n    },\n    eatSpace: function () {\n      var start = this.pos;\n\n      while (/[\\s\\u00a0]/.test(this.string.charAt(this.pos))) ++this.pos;\n\n      return this.pos > start;\n    },\n    skipToEnd: function () {\n      this.pos = this.string.length;\n    },\n    skipTo: function (ch) {\n      var found = this.string.indexOf(ch, this.pos);\n\n      if (found > -1) {\n        this.pos = found;\n        return true;\n      }\n    },\n    backUp: function (n) {\n      this.pos -= n;\n    },\n    column: function () {\n      throw \"not implemented\";\n    },\n    indentation: function () {\n      throw \"not implemented\";\n    },\n    match: function (pattern, consume, caseInsensitive) {\n      if (typeof pattern == \"string\") {\n        var cased = function (str) {\n          return caseInsensitive ? str.toLowerCase() : str;\n        };\n\n        var substr = this.string.substr(this.pos, pattern.length);\n\n        if (cased(substr) == cased(pattern)) {\n          if (consume !== false) this.pos += pattern.length;\n          return true;\n        }\n      } else {\n        var match = this.string.slice(this.pos).match(pattern);\n        if (match && match.index > 0) return null;\n        if (match && consume !== false) this.pos += match[0].length;\n        return match;\n      }\n    },\n    current: function () {\n      return this.string.slice(this.start, this.pos);\n    },\n    hideFirstChars: function (n, inner) {\n      this.lineStart += n;\n\n      try {\n        return inner();\n      } finally {\n        this.lineStart -= n;\n      }\n    }\n  };\n\n  CodeMirror.defineExtension = function (name, fn) {\n    CodeMirror.prototype[name] = fn;\n  };\n\n  dom.importCssString(\".normal-mode .ace_cursor{\\\n    border: none;\\\n    background-color: rgba(255,0,0,0.5);\\\n}\\\n.normal-mode .ace_hidden-cursors .ace_cursor{\\\n  background-color: transparent;\\\n  border: 1px solid red;\\\n  opacity: 0.7\\\n}\\\n.ace_dialog {\\\n  position: absolute;\\\n  left: 0; right: 0;\\\n  background: inherit;\\\n  z-index: 15;\\\n  padding: .1em .8em;\\\n  overflow: hidden;\\\n  color: inherit;\\\n}\\\n.ace_dialog-top {\\\n  border-bottom: 1px solid #444;\\\n  top: 0;\\\n}\\\n.ace_dialog-bottom {\\\n  border-top: 1px solid #444;\\\n  bottom: 0;\\\n}\\\n.ace_dialog input {\\\n  border: none;\\\n  outline: none;\\\n  background: transparent;\\\n  width: 20em;\\\n  color: inherit;\\\n  font-family: monospace;\\\n}\", \"vimMode\");\n\n  (function () {\n    function dialogDiv(cm, template, bottom) {\n      var wrap = cm.ace.container;\n      var dialog;\n      dialog = wrap.appendChild(document.createElement(\"div\"));\n      if (bottom) dialog.className = \"ace_dialog ace_dialog-bottom\";else dialog.className = \"ace_dialog ace_dialog-top\";\n\n      if (typeof template == \"string\") {\n        dialog.innerHTML = template;\n      } else {\n        // Assuming it's a detached DOM element.\n        dialog.appendChild(template);\n      }\n\n      return dialog;\n    }\n\n    function closeNotification(cm, newVal) {\n      if (cm.state.currentNotificationClose) cm.state.currentNotificationClose();\n      cm.state.currentNotificationClose = newVal;\n    }\n\n    CodeMirror.defineExtension(\"openDialog\", function (template, callback, options) {\n      if (this.virtualSelectionMode()) return;\n      if (!options) options = {};\n      closeNotification(this, null);\n      var dialog = dialogDiv(this, template, options.bottom);\n      var closed = false,\n          me = this;\n      this.state.dialog = dialog;\n\n      function close(newVal) {\n        if (typeof newVal == 'string') {\n          inp.value = newVal;\n        } else {\n          if (closed) return;\n\n          if (newVal && newVal.type == \"blur\") {\n            if (document.activeElement === inp) return;\n          }\n\n          me.state.dialog = null;\n          closed = true;\n          dialog.parentNode.removeChild(dialog);\n          me.focus();\n          if (options.onClose) options.onClose(dialog);\n        }\n      }\n\n      var inp = dialog.getElementsByTagName(\"input\")[0],\n          button;\n\n      if (inp) {\n        if (options.value) {\n          inp.value = options.value;\n          if (options.selectValueOnOpen !== false) inp.select();\n        }\n\n        if (options.onInput) CodeMirror.on(inp, \"input\", function (e) {\n          options.onInput(e, inp.value, close);\n        });\n        if (options.onKeyUp) CodeMirror.on(inp, \"keyup\", function (e) {\n          options.onKeyUp(e, inp.value, close);\n        });\n        CodeMirror.on(inp, \"keydown\", function (e) {\n          if (options && options.onKeyDown && options.onKeyDown(e, inp.value, close)) {\n            return;\n          }\n\n          if (e.keyCode == 13) callback(inp.value);\n\n          if (e.keyCode == 27 || options.closeOnEnter !== false && e.keyCode == 13) {\n            inp.blur();\n            CodeMirror.e_stop(e);\n            close();\n          }\n        });\n        if (options.closeOnBlur !== false) CodeMirror.on(inp, \"blur\", close);\n        inp.focus();\n      } else if (button = dialog.getElementsByTagName(\"button\")[0]) {\n        CodeMirror.on(button, \"click\", function () {\n          close();\n          me.focus();\n        });\n        if (options.closeOnBlur !== false) CodeMirror.on(button, \"blur\", close);\n        button.focus();\n      }\n\n      return close;\n    });\n    CodeMirror.defineExtension(\"openNotification\", function (template, options) {\n      if (this.virtualSelectionMode()) return;\n      closeNotification(this, close);\n      var dialog = dialogDiv(this, template, options && options.bottom);\n      var closed = false,\n          doneTimer;\n      var duration = options && typeof options.duration !== \"undefined\" ? options.duration : 5000;\n\n      function close() {\n        if (closed) return;\n        closed = true;\n        clearTimeout(doneTimer);\n        dialog.parentNode.removeChild(dialog);\n      }\n\n      CodeMirror.on(dialog, 'click', function (e) {\n        CodeMirror.e_preventDefault(e);\n        close();\n      });\n      if (duration) doneTimer = setTimeout(close, duration);\n      return close;\n    });\n  })();\n\n  var defaultKeymap = [{\n    keys: '<Left>',\n    type: 'keyToKey',\n    toKeys: 'h'\n  }, {\n    keys: '<Right>',\n    type: 'keyToKey',\n    toKeys: 'l'\n  }, {\n    keys: '<Up>',\n    type: 'keyToKey',\n    toKeys: 'k'\n  }, {\n    keys: '<Down>',\n    type: 'keyToKey',\n    toKeys: 'j'\n  }, {\n    keys: '<Space>',\n    type: 'keyToKey',\n    toKeys: 'l'\n  }, {\n    keys: '<BS>',\n    type: 'keyToKey',\n    toKeys: 'h',\n    context: 'normal'\n  }, {\n    keys: '<Del>',\n    type: 'keyToKey',\n    toKeys: 'x',\n    context: 'normal'\n  }, {\n    keys: '<C-Space>',\n    type: 'keyToKey',\n    toKeys: 'W'\n  }, {\n    keys: '<C-BS>',\n    type: 'keyToKey',\n    toKeys: 'B',\n    context: 'normal'\n  }, {\n    keys: '<S-Space>',\n    type: 'keyToKey',\n    toKeys: 'w'\n  }, {\n    keys: '<S-BS>',\n    type: 'keyToKey',\n    toKeys: 'b',\n    context: 'normal'\n  }, {\n    keys: '<C-n>',\n    type: 'keyToKey',\n    toKeys: 'j'\n  }, {\n    keys: '<C-p>',\n    type: 'keyToKey',\n    toKeys: 'k'\n  }, {\n    keys: '<C-[>',\n    type: 'keyToKey',\n    toKeys: '<Esc>'\n  }, {\n    keys: '<C-c>',\n    type: 'keyToKey',\n    toKeys: '<Esc>'\n  }, {\n    keys: '<C-[>',\n    type: 'keyToKey',\n    toKeys: '<Esc>',\n    context: 'insert'\n  }, {\n    keys: '<C-c>',\n    type: 'keyToKey',\n    toKeys: '<Esc>',\n    context: 'insert'\n  }, {\n    keys: '<C-Esc>',\n    type: 'keyToKey',\n    toKeys: '<Esc>'\n  }, // ace_patch ipad keyboard sends C-Esc instead of C-[\n  {\n    keys: '<C-Esc>',\n    type: 'keyToKey',\n    toKeys: '<Esc>',\n    context: 'insert'\n  }, {\n    keys: 's',\n    type: 'keyToKey',\n    toKeys: 'cl',\n    context: 'normal'\n  }, {\n    keys: 's',\n    type: 'keyToKey',\n    toKeys: 'c',\n    context: 'visual'\n  }, {\n    keys: 'S',\n    type: 'keyToKey',\n    toKeys: 'cc',\n    context: 'normal'\n  }, {\n    keys: 'S',\n    type: 'keyToKey',\n    toKeys: 'VdO',\n    context: 'visual'\n  }, {\n    keys: '<Home>',\n    type: 'keyToKey',\n    toKeys: '0'\n  }, {\n    keys: '<End>',\n    type: 'keyToKey',\n    toKeys: '$'\n  }, {\n    keys: '<PageUp>',\n    type: 'keyToKey',\n    toKeys: '<C-b>'\n  }, {\n    keys: '<PageDown>',\n    type: 'keyToKey',\n    toKeys: '<C-f>'\n  }, {\n    keys: '<CR>',\n    type: 'keyToKey',\n    toKeys: 'j^',\n    context: 'normal'\n  }, {\n    keys: '<Ins>',\n    type: 'action',\n    action: 'toggleOverwrite',\n    context: 'insert'\n  }, {\n    keys: 'H',\n    type: 'motion',\n    motion: 'moveToTopLine',\n    motionArgs: {\n      linewise: true,\n      toJumplist: true\n    }\n  }, {\n    keys: 'M',\n    type: 'motion',\n    motion: 'moveToMiddleLine',\n    motionArgs: {\n      linewise: true,\n      toJumplist: true\n    }\n  }, {\n    keys: 'L',\n    type: 'motion',\n    motion: 'moveToBottomLine',\n    motionArgs: {\n      linewise: true,\n      toJumplist: true\n    }\n  }, {\n    keys: 'h',\n    type: 'motion',\n    motion: 'moveByCharacters',\n    motionArgs: {\n      forward: false\n    }\n  }, {\n    keys: 'l',\n    type: 'motion',\n    motion: 'moveByCharacters',\n    motionArgs: {\n      forward: true\n    }\n  }, {\n    keys: 'j',\n    type: 'motion',\n    motion: 'moveByLines',\n    motionArgs: {\n      forward: true,\n      linewise: true\n    }\n  }, {\n    keys: 'k',\n    type: 'motion',\n    motion: 'moveByLines',\n    motionArgs: {\n      forward: false,\n      linewise: true\n    }\n  }, {\n    keys: 'gj',\n    type: 'motion',\n    motion: 'moveByDisplayLines',\n    motionArgs: {\n      forward: true\n    }\n  }, {\n    keys: 'gk',\n    type: 'motion',\n    motion: 'moveByDisplayLines',\n    motionArgs: {\n      forward: false\n    }\n  }, {\n    keys: 'w',\n    type: 'motion',\n    motion: 'moveByWords',\n    motionArgs: {\n      forward: true,\n      wordEnd: false\n    }\n  }, {\n    keys: 'W',\n    type: 'motion',\n    motion: 'moveByWords',\n    motionArgs: {\n      forward: true,\n      wordEnd: false,\n      bigWord: true\n    }\n  }, {\n    keys: 'e',\n    type: 'motion',\n    motion: 'moveByWords',\n    motionArgs: {\n      forward: true,\n      wordEnd: true,\n      inclusive: true\n    }\n  }, {\n    keys: 'E',\n    type: 'motion',\n    motion: 'moveByWords',\n    motionArgs: {\n      forward: true,\n      wordEnd: true,\n      bigWord: true,\n      inclusive: true\n    }\n  }, {\n    keys: 'b',\n    type: 'motion',\n    motion: 'moveByWords',\n    motionArgs: {\n      forward: false,\n      wordEnd: false\n    }\n  }, {\n    keys: 'B',\n    type: 'motion',\n    motion: 'moveByWords',\n    motionArgs: {\n      forward: false,\n      wordEnd: false,\n      bigWord: true\n    }\n  }, {\n    keys: 'ge',\n    type: 'motion',\n    motion: 'moveByWords',\n    motionArgs: {\n      forward: false,\n      wordEnd: true,\n      inclusive: true\n    }\n  }, {\n    keys: 'gE',\n    type: 'motion',\n    motion: 'moveByWords',\n    motionArgs: {\n      forward: false,\n      wordEnd: true,\n      bigWord: true,\n      inclusive: true\n    }\n  }, {\n    keys: '{',\n    type: 'motion',\n    motion: 'moveByParagraph',\n    motionArgs: {\n      forward: false,\n      toJumplist: true\n    }\n  }, {\n    keys: '}',\n    type: 'motion',\n    motion: 'moveByParagraph',\n    motionArgs: {\n      forward: true,\n      toJumplist: true\n    }\n  }, {\n    keys: '(',\n    type: 'motion',\n    motion: 'moveBySentence',\n    motionArgs: {\n      forward: false\n    }\n  }, {\n    keys: ')',\n    type: 'motion',\n    motion: 'moveBySentence',\n    motionArgs: {\n      forward: true\n    }\n  }, {\n    keys: '<C-f>',\n    type: 'motion',\n    motion: 'moveByPage',\n    motionArgs: {\n      forward: true\n    }\n  }, {\n    keys: '<C-b>',\n    type: 'motion',\n    motion: 'moveByPage',\n    motionArgs: {\n      forward: false\n    }\n  }, {\n    keys: '<C-d>',\n    type: 'motion',\n    motion: 'moveByScroll',\n    motionArgs: {\n      forward: true,\n      explicitRepeat: true\n    }\n  }, {\n    keys: '<C-u>',\n    type: 'motion',\n    motion: 'moveByScroll',\n    motionArgs: {\n      forward: false,\n      explicitRepeat: true\n    }\n  }, {\n    keys: 'gg',\n    type: 'motion',\n    motion: 'moveToLineOrEdgeOfDocument',\n    motionArgs: {\n      forward: false,\n      explicitRepeat: true,\n      linewise: true,\n      toJumplist: true\n    }\n  }, {\n    keys: 'G',\n    type: 'motion',\n    motion: 'moveToLineOrEdgeOfDocument',\n    motionArgs: {\n      forward: true,\n      explicitRepeat: true,\n      linewise: true,\n      toJumplist: true\n    }\n  }, {\n    keys: '0',\n    type: 'motion',\n    motion: 'moveToStartOfLine'\n  }, {\n    keys: '^',\n    type: 'motion',\n    motion: 'moveToFirstNonWhiteSpaceCharacter'\n  }, {\n    keys: '+',\n    type: 'motion',\n    motion: 'moveByLines',\n    motionArgs: {\n      forward: true,\n      toFirstChar: true\n    }\n  }, {\n    keys: '-',\n    type: 'motion',\n    motion: 'moveByLines',\n    motionArgs: {\n      forward: false,\n      toFirstChar: true\n    }\n  }, {\n    keys: '_',\n    type: 'motion',\n    motion: 'moveByLines',\n    motionArgs: {\n      forward: true,\n      toFirstChar: true,\n      repeatOffset: -1\n    }\n  }, {\n    keys: '$',\n    type: 'motion',\n    motion: 'moveToEol',\n    motionArgs: {\n      inclusive: true\n    }\n  }, {\n    keys: '%',\n    type: 'motion',\n    motion: 'moveToMatchedSymbol',\n    motionArgs: {\n      inclusive: true,\n      toJumplist: true\n    }\n  }, {\n    keys: 'f<character>',\n    type: 'motion',\n    motion: 'moveToCharacter',\n    motionArgs: {\n      forward: true,\n      inclusive: true\n    }\n  }, {\n    keys: 'F<character>',\n    type: 'motion',\n    motion: 'moveToCharacter',\n    motionArgs: {\n      forward: false\n    }\n  }, {\n    keys: 't<character>',\n    type: 'motion',\n    motion: 'moveTillCharacter',\n    motionArgs: {\n      forward: true,\n      inclusive: true\n    }\n  }, {\n    keys: 'T<character>',\n    type: 'motion',\n    motion: 'moveTillCharacter',\n    motionArgs: {\n      forward: false\n    }\n  }, {\n    keys: ';',\n    type: 'motion',\n    motion: 'repeatLastCharacterSearch',\n    motionArgs: {\n      forward: true\n    }\n  }, {\n    keys: ',',\n    type: 'motion',\n    motion: 'repeatLastCharacterSearch',\n    motionArgs: {\n      forward: false\n    }\n  }, {\n    keys: '\\'<character>',\n    type: 'motion',\n    motion: 'goToMark',\n    motionArgs: {\n      toJumplist: true,\n      linewise: true\n    }\n  }, {\n    keys: '`<character>',\n    type: 'motion',\n    motion: 'goToMark',\n    motionArgs: {\n      toJumplist: true\n    }\n  }, {\n    keys: ']`',\n    type: 'motion',\n    motion: 'jumpToMark',\n    motionArgs: {\n      forward: true\n    }\n  }, {\n    keys: '[`',\n    type: 'motion',\n    motion: 'jumpToMark',\n    motionArgs: {\n      forward: false\n    }\n  }, {\n    keys: ']\\'',\n    type: 'motion',\n    motion: 'jumpToMark',\n    motionArgs: {\n      forward: true,\n      linewise: true\n    }\n  }, {\n    keys: '[\\'',\n    type: 'motion',\n    motion: 'jumpToMark',\n    motionArgs: {\n      forward: false,\n      linewise: true\n    }\n  }, {\n    keys: ']p',\n    type: 'action',\n    action: 'paste',\n    isEdit: true,\n    actionArgs: {\n      after: true,\n      isEdit: true,\n      matchIndent: true\n    }\n  }, {\n    keys: '[p',\n    type: 'action',\n    action: 'paste',\n    isEdit: true,\n    actionArgs: {\n      after: false,\n      isEdit: true,\n      matchIndent: true\n    }\n  }, {\n    keys: ']<character>',\n    type: 'motion',\n    motion: 'moveToSymbol',\n    motionArgs: {\n      forward: true,\n      toJumplist: true\n    }\n  }, {\n    keys: '[<character>',\n    type: 'motion',\n    motion: 'moveToSymbol',\n    motionArgs: {\n      forward: false,\n      toJumplist: true\n    }\n  }, {\n    keys: '|',\n    type: 'motion',\n    motion: 'moveToColumn'\n  }, {\n    keys: 'o',\n    type: 'motion',\n    motion: 'moveToOtherHighlightedEnd',\n    context: 'visual'\n  }, {\n    keys: 'O',\n    type: 'motion',\n    motion: 'moveToOtherHighlightedEnd',\n    motionArgs: {\n      sameLine: true\n    },\n    context: 'visual'\n  }, {\n    keys: 'd',\n    type: 'operator',\n    operator: 'delete'\n  }, {\n    keys: 'y',\n    type: 'operator',\n    operator: 'yank'\n  }, {\n    keys: 'c',\n    type: 'operator',\n    operator: 'change'\n  }, {\n    keys: '=',\n    type: 'operator',\n    operator: 'indentAuto'\n  }, {\n    keys: '>',\n    type: 'operator',\n    operator: 'indent',\n    operatorArgs: {\n      indentRight: true\n    }\n  }, {\n    keys: '<',\n    type: 'operator',\n    operator: 'indent',\n    operatorArgs: {\n      indentRight: false\n    }\n  }, {\n    keys: 'g~',\n    type: 'operator',\n    operator: 'changeCase'\n  }, {\n    keys: 'gu',\n    type: 'operator',\n    operator: 'changeCase',\n    operatorArgs: {\n      toLower: true\n    },\n    isEdit: true\n  }, {\n    keys: 'gU',\n    type: 'operator',\n    operator: 'changeCase',\n    operatorArgs: {\n      toLower: false\n    },\n    isEdit: true\n  }, {\n    keys: 'n',\n    type: 'motion',\n    motion: 'findNext',\n    motionArgs: {\n      forward: true,\n      toJumplist: true\n    }\n  }, {\n    keys: 'N',\n    type: 'motion',\n    motion: 'findNext',\n    motionArgs: {\n      forward: false,\n      toJumplist: true\n    }\n  }, {\n    keys: 'x',\n    type: 'operatorMotion',\n    operator: 'delete',\n    motion: 'moveByCharacters',\n    motionArgs: {\n      forward: true\n    },\n    operatorMotionArgs: {\n      visualLine: false\n    }\n  }, {\n    keys: 'X',\n    type: 'operatorMotion',\n    operator: 'delete',\n    motion: 'moveByCharacters',\n    motionArgs: {\n      forward: false\n    },\n    operatorMotionArgs: {\n      visualLine: true\n    }\n  }, {\n    keys: 'D',\n    type: 'operatorMotion',\n    operator: 'delete',\n    motion: 'moveToEol',\n    motionArgs: {\n      inclusive: true\n    },\n    context: 'normal'\n  }, {\n    keys: 'D',\n    type: 'operator',\n    operator: 'delete',\n    operatorArgs: {\n      linewise: true\n    },\n    context: 'visual'\n  }, {\n    keys: 'Y',\n    type: 'operatorMotion',\n    operator: 'yank',\n    motion: 'expandToLine',\n    motionArgs: {\n      linewise: true\n    },\n    context: 'normal'\n  }, {\n    keys: 'Y',\n    type: 'operator',\n    operator: 'yank',\n    operatorArgs: {\n      linewise: true\n    },\n    context: 'visual'\n  }, {\n    keys: 'C',\n    type: 'operatorMotion',\n    operator: 'change',\n    motion: 'moveToEol',\n    motionArgs: {\n      inclusive: true\n    },\n    context: 'normal'\n  }, {\n    keys: 'C',\n    type: 'operator',\n    operator: 'change',\n    operatorArgs: {\n      linewise: true\n    },\n    context: 'visual'\n  }, {\n    keys: '~',\n    type: 'operatorMotion',\n    operator: 'changeCase',\n    motion: 'moveByCharacters',\n    motionArgs: {\n      forward: true\n    },\n    operatorArgs: {\n      shouldMoveCursor: true\n    },\n    context: 'normal'\n  }, {\n    keys: '~',\n    type: 'operator',\n    operator: 'changeCase',\n    context: 'visual'\n  }, {\n    keys: '<C-w>',\n    type: 'operatorMotion',\n    operator: 'delete',\n    motion: 'moveByWords',\n    motionArgs: {\n      forward: false,\n      wordEnd: false\n    },\n    context: 'insert'\n  }, {\n    keys: '<C-w>',\n    type: 'idle',\n    context: 'normal'\n  }, {\n    keys: '<C-i>',\n    type: 'action',\n    action: 'jumpListWalk',\n    actionArgs: {\n      forward: true\n    }\n  }, {\n    keys: '<C-o>',\n    type: 'action',\n    action: 'jumpListWalk',\n    actionArgs: {\n      forward: false\n    }\n  }, {\n    keys: '<C-e>',\n    type: 'action',\n    action: 'scroll',\n    actionArgs: {\n      forward: true,\n      linewise: true\n    }\n  }, {\n    keys: '<C-y>',\n    type: 'action',\n    action: 'scroll',\n    actionArgs: {\n      forward: false,\n      linewise: true\n    }\n  }, {\n    keys: 'a',\n    type: 'action',\n    action: 'enterInsertMode',\n    isEdit: true,\n    actionArgs: {\n      insertAt: 'charAfter'\n    },\n    context: 'normal'\n  }, {\n    keys: 'A',\n    type: 'action',\n    action: 'enterInsertMode',\n    isEdit: true,\n    actionArgs: {\n      insertAt: 'eol'\n    },\n    context: 'normal'\n  }, {\n    keys: 'A',\n    type: 'action',\n    action: 'enterInsertMode',\n    isEdit: true,\n    actionArgs: {\n      insertAt: 'endOfSelectedArea'\n    },\n    context: 'visual'\n  }, {\n    keys: 'i',\n    type: 'action',\n    action: 'enterInsertMode',\n    isEdit: true,\n    actionArgs: {\n      insertAt: 'inplace'\n    },\n    context: 'normal'\n  }, {\n    keys: 'gi',\n    type: 'action',\n    action: 'enterInsertMode',\n    isEdit: true,\n    actionArgs: {\n      insertAt: 'lastEdit'\n    },\n    context: 'normal'\n  }, {\n    keys: 'I',\n    type: 'action',\n    action: 'enterInsertMode',\n    isEdit: true,\n    actionArgs: {\n      insertAt: 'firstNonBlank'\n    },\n    context: 'normal'\n  }, {\n    keys: 'gI',\n    type: 'action',\n    action: 'enterInsertMode',\n    isEdit: true,\n    actionArgs: {\n      insertAt: 'bol'\n    },\n    context: 'normal'\n  }, {\n    keys: 'I',\n    type: 'action',\n    action: 'enterInsertMode',\n    isEdit: true,\n    actionArgs: {\n      insertAt: 'startOfSelectedArea'\n    },\n    context: 'visual'\n  }, {\n    keys: 'o',\n    type: 'action',\n    action: 'newLineAndEnterInsertMode',\n    isEdit: true,\n    interlaceInsertRepeat: true,\n    actionArgs: {\n      after: true\n    },\n    context: 'normal'\n  }, {\n    keys: 'O',\n    type: 'action',\n    action: 'newLineAndEnterInsertMode',\n    isEdit: true,\n    interlaceInsertRepeat: true,\n    actionArgs: {\n      after: false\n    },\n    context: 'normal'\n  }, {\n    keys: 'v',\n    type: 'action',\n    action: 'toggleVisualMode'\n  }, {\n    keys: 'V',\n    type: 'action',\n    action: 'toggleVisualMode',\n    actionArgs: {\n      linewise: true\n    }\n  }, {\n    keys: '<C-v>',\n    type: 'action',\n    action: 'toggleVisualMode',\n    actionArgs: {\n      blockwise: true\n    }\n  }, {\n    keys: '<C-q>',\n    type: 'action',\n    action: 'toggleVisualMode',\n    actionArgs: {\n      blockwise: true\n    }\n  }, {\n    keys: 'gv',\n    type: 'action',\n    action: 'reselectLastSelection'\n  }, {\n    keys: 'J',\n    type: 'action',\n    action: 'joinLines',\n    isEdit: true\n  }, {\n    keys: 'gJ',\n    type: 'action',\n    action: 'joinLines',\n    actionArgs: {\n      keepSpaces: true\n    },\n    isEdit: true\n  }, {\n    keys: 'p',\n    type: 'action',\n    action: 'paste',\n    isEdit: true,\n    actionArgs: {\n      after: true,\n      isEdit: true\n    }\n  }, {\n    keys: 'P',\n    type: 'action',\n    action: 'paste',\n    isEdit: true,\n    actionArgs: {\n      after: false,\n      isEdit: true\n    }\n  }, {\n    keys: 'r<character>',\n    type: 'action',\n    action: 'replace',\n    isEdit: true\n  }, {\n    keys: '@<character>',\n    type: 'action',\n    action: 'replayMacro'\n  }, {\n    keys: 'q<character>',\n    type: 'action',\n    action: 'enterMacroRecordMode'\n  }, {\n    keys: 'R',\n    type: 'action',\n    action: 'enterInsertMode',\n    isEdit: true,\n    actionArgs: {\n      replace: true\n    },\n    context: 'normal'\n  }, {\n    keys: 'R',\n    type: 'operator',\n    operator: 'change',\n    operatorArgs: {\n      linewise: true,\n      fullLine: true\n    },\n    context: 'visual',\n    exitVisualBlock: true\n  }, {\n    keys: 'u',\n    type: 'action',\n    action: 'undo',\n    context: 'normal'\n  }, {\n    keys: 'u',\n    type: 'operator',\n    operator: 'changeCase',\n    operatorArgs: {\n      toLower: true\n    },\n    context: 'visual',\n    isEdit: true\n  }, {\n    keys: 'U',\n    type: 'operator',\n    operator: 'changeCase',\n    operatorArgs: {\n      toLower: false\n    },\n    context: 'visual',\n    isEdit: true\n  }, {\n    keys: '<C-r>',\n    type: 'action',\n    action: 'redo'\n  }, {\n    keys: 'm<character>',\n    type: 'action',\n    action: 'setMark'\n  }, {\n    keys: '\"<character>',\n    type: 'action',\n    action: 'setRegister'\n  }, {\n    keys: 'zz',\n    type: 'action',\n    action: 'scrollToCursor',\n    actionArgs: {\n      position: 'center'\n    }\n  }, {\n    keys: 'z.',\n    type: 'action',\n    action: 'scrollToCursor',\n    actionArgs: {\n      position: 'center'\n    },\n    motion: 'moveToFirstNonWhiteSpaceCharacter'\n  }, {\n    keys: 'zt',\n    type: 'action',\n    action: 'scrollToCursor',\n    actionArgs: {\n      position: 'top'\n    }\n  }, {\n    keys: 'z<CR>',\n    type: 'action',\n    action: 'scrollToCursor',\n    actionArgs: {\n      position: 'top'\n    },\n    motion: 'moveToFirstNonWhiteSpaceCharacter'\n  }, {\n    keys: 'z-',\n    type: 'action',\n    action: 'scrollToCursor',\n    actionArgs: {\n      position: 'bottom'\n    }\n  }, {\n    keys: 'zb',\n    type: 'action',\n    action: 'scrollToCursor',\n    actionArgs: {\n      position: 'bottom'\n    },\n    motion: 'moveToFirstNonWhiteSpaceCharacter'\n  }, {\n    keys: '.',\n    type: 'action',\n    action: 'repeatLastEdit'\n  }, {\n    keys: '<C-a>',\n    type: 'action',\n    action: 'incrementNumberToken',\n    isEdit: true,\n    actionArgs: {\n      increase: true,\n      backtrack: false\n    }\n  }, {\n    keys: '<C-x>',\n    type: 'action',\n    action: 'incrementNumberToken',\n    isEdit: true,\n    actionArgs: {\n      increase: false,\n      backtrack: false\n    }\n  }, {\n    keys: '<C-t>',\n    type: 'action',\n    action: 'indent',\n    actionArgs: {\n      indentRight: true\n    },\n    context: 'insert'\n  }, {\n    keys: '<C-d>',\n    type: 'action',\n    action: 'indent',\n    actionArgs: {\n      indentRight: false\n    },\n    context: 'insert'\n  }, {\n    keys: 'a<character>',\n    type: 'motion',\n    motion: 'textObjectManipulation'\n  }, {\n    keys: 'i<character>',\n    type: 'motion',\n    motion: 'textObjectManipulation',\n    motionArgs: {\n      textObjectInner: true\n    }\n  }, {\n    keys: '/',\n    type: 'search',\n    searchArgs: {\n      forward: true,\n      querySrc: 'prompt',\n      toJumplist: true\n    }\n  }, {\n    keys: '?',\n    type: 'search',\n    searchArgs: {\n      forward: false,\n      querySrc: 'prompt',\n      toJumplist: true\n    }\n  }, {\n    keys: '*',\n    type: 'search',\n    searchArgs: {\n      forward: true,\n      querySrc: 'wordUnderCursor',\n      wholeWordOnly: true,\n      toJumplist: true\n    }\n  }, {\n    keys: '#',\n    type: 'search',\n    searchArgs: {\n      forward: false,\n      querySrc: 'wordUnderCursor',\n      wholeWordOnly: true,\n      toJumplist: true\n    }\n  }, {\n    keys: 'g*',\n    type: 'search',\n    searchArgs: {\n      forward: true,\n      querySrc: 'wordUnderCursor',\n      toJumplist: true\n    }\n  }, {\n    keys: 'g#',\n    type: 'search',\n    searchArgs: {\n      forward: false,\n      querySrc: 'wordUnderCursor',\n      toJumplist: true\n    }\n  }, {\n    keys: ':',\n    type: 'ex'\n  }];\n  var defaultKeymapLength = defaultKeymap.length;\n  var defaultExCommandMap = [{\n    name: 'colorscheme',\n    shortName: 'colo'\n  }, {\n    name: 'map'\n  }, {\n    name: 'imap',\n    shortName: 'im'\n  }, {\n    name: 'nmap',\n    shortName: 'nm'\n  }, {\n    name: 'vmap',\n    shortName: 'vm'\n  }, {\n    name: 'unmap'\n  }, {\n    name: 'write',\n    shortName: 'w'\n  }, {\n    name: 'undo',\n    shortName: 'u'\n  }, {\n    name: 'redo',\n    shortName: 'red'\n  }, {\n    name: 'set',\n    shortName: 'se'\n  }, {\n    name: 'set',\n    shortName: 'se'\n  }, {\n    name: 'setlocal',\n    shortName: 'setl'\n  }, {\n    name: 'setglobal',\n    shortName: 'setg'\n  }, {\n    name: 'sort',\n    shortName: 'sor'\n  }, {\n    name: 'substitute',\n    shortName: 's',\n    possiblyAsync: true\n  }, {\n    name: 'nohlsearch',\n    shortName: 'noh'\n  }, {\n    name: 'yank',\n    shortName: 'y'\n  }, {\n    name: 'delmarks',\n    shortName: 'delm'\n  }, {\n    name: 'registers',\n    shortName: 'reg',\n    excludeFromCommandHistory: true\n  }, {\n    name: 'global',\n    shortName: 'g'\n  }];\n  var Pos = CodeMirror.Pos;\n\n  var Vim = function () {\n    return vimApi;\n  }; //{\n\n\n  function enterVimMode(cm) {\n    cm.setOption('disableInput', true);\n    cm.setOption('showCursorWhenSelecting', false);\n    CodeMirror.signal(cm, \"vim-mode-change\", {\n      mode: \"normal\"\n    });\n    cm.on('cursorActivity', onCursorActivity);\n    maybeInitVimState(cm);\n    CodeMirror.on(cm.getInputField(), 'paste', getOnPasteFn(cm));\n  }\n\n  function leaveVimMode(cm) {\n    cm.setOption('disableInput', false);\n    cm.off('cursorActivity', onCursorActivity);\n    CodeMirror.off(cm.getInputField(), 'paste', getOnPasteFn(cm));\n    cm.state.vim = null;\n  }\n\n  function detachVimMap(cm, next) {\n    if (this == CodeMirror.keyMap.vim) CodeMirror.rmClass(cm.getWrapperElement(), \"cm-fat-cursor\");\n    if (!next || next.attach != attachVimMap) leaveVimMode(cm);\n  }\n\n  function attachVimMap(cm, prev) {\n    if (this == CodeMirror.keyMap.vim) CodeMirror.addClass(cm.getWrapperElement(), \"cm-fat-cursor\");\n    if (!prev || prev.attach != attachVimMap) enterVimMode(cm);\n  }\n\n  CodeMirror.defineOption('vimMode', false, function (cm, val, prev) {\n    if (val && cm.getOption(\"keyMap\") != \"vim\") cm.setOption(\"keyMap\", \"vim\");else if (!val && prev != CodeMirror.Init && /^vim/.test(cm.getOption(\"keyMap\"))) cm.setOption(\"keyMap\", \"default\");\n  });\n\n  function cmKey(key, cm) {\n    if (!cm) {\n      return undefined;\n    }\n\n    if (this[key]) {\n      return this[key];\n    }\n\n    var vimKey = cmKeyToVimKey(key);\n\n    if (!vimKey) {\n      return false;\n    }\n\n    var cmd = CodeMirror.Vim.findKey(cm, vimKey);\n\n    if (typeof cmd == 'function') {\n      CodeMirror.signal(cm, 'vim-keypress', vimKey);\n    }\n\n    return cmd;\n  }\n\n  var modifiers = {\n    'Shift': 'S',\n    'Ctrl': 'C',\n    'Alt': 'A',\n    'Cmd': 'D',\n    'Mod': 'A'\n  };\n  var specialKeys = {\n    Enter: 'CR',\n    Backspace: 'BS',\n    Delete: 'Del',\n    Insert: 'Ins'\n  };\n\n  function cmKeyToVimKey(key) {\n    if (key.charAt(0) == '\\'') {\n      return key.charAt(1);\n    }\n\n    var pieces = key.split(/-(?!$)/);\n    var lastPiece = pieces[pieces.length - 1];\n\n    if (pieces.length == 1 && pieces[0].length == 1) {\n      return false;\n    } else if (pieces.length == 2 && pieces[0] == 'Shift' && lastPiece.length == 1) {\n      return false;\n    }\n\n    var hasCharacter = false;\n\n    for (var i = 0; i < pieces.length; i++) {\n      var piece = pieces[i];\n\n      if (piece in modifiers) {\n        pieces[i] = modifiers[piece];\n      } else {\n        hasCharacter = true;\n      }\n\n      if (piece in specialKeys) {\n        pieces[i] = specialKeys[piece];\n      }\n    }\n\n    if (!hasCharacter) {\n      return false;\n    }\n\n    if (isUpperCase(lastPiece)) {\n      pieces[pieces.length - 1] = lastPiece.toLowerCase();\n    }\n\n    return '<' + pieces.join('-') + '>';\n  }\n\n  function getOnPasteFn(cm) {\n    var vim = cm.state.vim;\n\n    if (!vim.onPasteFn) {\n      vim.onPasteFn = function () {\n        if (!vim.insertMode) {\n          cm.setCursor(offsetCursor(cm.getCursor(), 0, 1));\n          actions.enterInsertMode(cm, {}, vim);\n        }\n      };\n    }\n\n    return vim.onPasteFn;\n  }\n\n  var numberRegex = /[\\d]/;\n  var wordCharTest = [CodeMirror.isWordChar, function (ch) {\n    return ch && !CodeMirror.isWordChar(ch) && !/\\s/.test(ch);\n  }],\n      bigWordCharTest = [function (ch) {\n    return /\\S/.test(ch);\n  }];\n\n  function makeKeyRange(start, size) {\n    var keys = [];\n\n    for (var i = start; i < start + size; i++) {\n      keys.push(String.fromCharCode(i));\n    }\n\n    return keys;\n  }\n\n  var upperCaseAlphabet = makeKeyRange(65, 26);\n  var lowerCaseAlphabet = makeKeyRange(97, 26);\n  var numbers = makeKeyRange(48, 10);\n  var validMarks = [].concat(upperCaseAlphabet, lowerCaseAlphabet, numbers, ['<', '>']);\n  var validRegisters = [].concat(upperCaseAlphabet, lowerCaseAlphabet, numbers, ['-', '\"', '.', ':', '/']);\n\n  function isLine(cm, line) {\n    return line >= cm.firstLine() && line <= cm.lastLine();\n  }\n\n  function isLowerCase(k) {\n    return /^[a-z]$/.test(k);\n  }\n\n  function isMatchableSymbol(k) {\n    return '()[]{}'.indexOf(k) != -1;\n  }\n\n  function isNumber(k) {\n    return numberRegex.test(k);\n  }\n\n  function isUpperCase(k) {\n    return /^[A-Z]$/.test(k);\n  }\n\n  function isWhiteSpaceString(k) {\n    return /^\\s*$/.test(k);\n  }\n\n  function isEndOfSentenceSymbol(k) {\n    return '.?!'.indexOf(k) != -1;\n  }\n\n  function inArray(val, arr) {\n    for (var i = 0; i < arr.length; i++) {\n      if (arr[i] == val) {\n        return true;\n      }\n    }\n\n    return false;\n  }\n\n  var options = {};\n\n  function defineOption(name, defaultValue, type, aliases, callback) {\n    if (defaultValue === undefined && !callback) {\n      throw Error('defaultValue is required unless callback is provided');\n    }\n\n    if (!type) {\n      type = 'string';\n    }\n\n    options[name] = {\n      type: type,\n      defaultValue: defaultValue,\n      callback: callback\n    };\n\n    if (aliases) {\n      for (var i = 0; i < aliases.length; i++) {\n        options[aliases[i]] = options[name];\n      }\n    }\n\n    if (defaultValue) {\n      setOption(name, defaultValue);\n    }\n  }\n\n  function setOption(name, value, cm, cfg) {\n    var option = options[name];\n    cfg = cfg || {};\n    var scope = cfg.scope;\n\n    if (!option) {\n      return new Error('Unknown option: ' + name);\n    }\n\n    if (option.type == 'boolean') {\n      if (value && value !== true) {\n        return new Error('Invalid argument: ' + name + '=' + value);\n      } else if (value !== false) {\n        value = true;\n      }\n    }\n\n    if (option.callback) {\n      if (scope !== 'local') {\n        option.callback(value, undefined);\n      }\n\n      if (scope !== 'global' && cm) {\n        option.callback(value, cm);\n      }\n    } else {\n      if (scope !== 'local') {\n        option.value = option.type == 'boolean' ? !!value : value;\n      }\n\n      if (scope !== 'global' && cm) {\n        cm.state.vim.options[name] = {\n          value: value\n        };\n      }\n    }\n  }\n\n  function getOption(name, cm, cfg) {\n    var option = options[name];\n    cfg = cfg || {};\n    var scope = cfg.scope;\n\n    if (!option) {\n      return new Error('Unknown option: ' + name);\n    }\n\n    if (option.callback) {\n      var local = cm && option.callback(undefined, cm);\n\n      if (scope !== 'global' && local !== undefined) {\n        return local;\n      }\n\n      if (scope !== 'local') {\n        return option.callback();\n      }\n\n      return;\n    } else {\n      var local = scope !== 'global' && cm && cm.state.vim.options[name];\n      return (local || scope !== 'local' && option || {}).value;\n    }\n  }\n\n  defineOption('filetype', undefined, 'string', ['ft'], function (name, cm) {\n    if (cm === undefined) {\n      return;\n    }\n\n    if (name === undefined) {\n      var mode = cm.getOption('mode');\n      return mode == 'null' ? '' : mode;\n    } else {\n      var mode = name == '' ? 'null' : name;\n      cm.setOption('mode', mode);\n    }\n  });\n\n  var createCircularJumpList = function () {\n    var size = 100;\n    var pointer = -1;\n    var head = 0;\n    var tail = 0;\n    var buffer = new Array(size);\n\n    function add(cm, oldCur, newCur) {\n      var current = pointer % size;\n      var curMark = buffer[current];\n\n      function useNextSlot(cursor) {\n        var next = ++pointer % size;\n        var trashMark = buffer[next];\n\n        if (trashMark) {\n          trashMark.clear();\n        }\n\n        buffer[next] = cm.setBookmark(cursor);\n      }\n\n      if (curMark) {\n        var markPos = curMark.find();\n\n        if (markPos && !cursorEqual(markPos, oldCur)) {\n          useNextSlot(oldCur);\n        }\n      } else {\n        useNextSlot(oldCur);\n      }\n\n      useNextSlot(newCur);\n      head = pointer;\n      tail = pointer - size + 1;\n\n      if (tail < 0) {\n        tail = 0;\n      }\n    }\n\n    function move(cm, offset) {\n      pointer += offset;\n\n      if (pointer > head) {\n        pointer = head;\n      } else if (pointer < tail) {\n        pointer = tail;\n      }\n\n      var mark = buffer[(size + pointer) % size];\n\n      if (mark && !mark.find()) {\n        var inc = offset > 0 ? 1 : -1;\n        var newCur;\n        var oldCur = cm.getCursor();\n\n        do {\n          pointer += inc;\n          mark = buffer[(size + pointer) % size];\n\n          if (mark && (newCur = mark.find()) && !cursorEqual(oldCur, newCur)) {\n            break;\n          }\n        } while (pointer < head && pointer > tail);\n      }\n\n      return mark;\n    }\n\n    function find(cm, offset) {\n      var oldPointer = pointer;\n      var mark = move(cm, offset);\n      pointer = oldPointer;\n      return mark && mark.find();\n    }\n\n    return {\n      cachedCursor: undefined,\n      //used for # and * jumps\n      add: add,\n      find: find,\n      move: move\n    };\n  };\n\n  var createInsertModeChanges = function (c) {\n    if (c) {\n      return {\n        changes: c.changes,\n        expectCursorActivityForChange: c.expectCursorActivityForChange\n      };\n    }\n\n    return {\n      changes: [],\n      expectCursorActivityForChange: false\n    };\n  };\n\n  function MacroModeState() {\n    this.latestRegister = undefined;\n    this.isPlaying = false;\n    this.isRecording = false;\n    this.replaySearchQueries = [];\n    this.onRecordingDone = undefined;\n    this.lastInsertModeChanges = createInsertModeChanges();\n  }\n\n  MacroModeState.prototype = {\n    exitMacroRecordMode: function () {\n      var macroModeState = vimGlobalState.macroModeState;\n\n      if (macroModeState.onRecordingDone) {\n        macroModeState.onRecordingDone(); // close dialog\n      }\n\n      macroModeState.onRecordingDone = undefined;\n      macroModeState.isRecording = false;\n    },\n    enterMacroRecordMode: function (cm, registerName) {\n      var register = vimGlobalState.registerController.getRegister(registerName);\n\n      if (register) {\n        register.clear();\n        this.latestRegister = registerName;\n\n        if (cm.openDialog) {\n          this.onRecordingDone = cm.openDialog('(recording)[' + registerName + ']', null, {\n            bottom: true\n          });\n        }\n\n        this.isRecording = true;\n      }\n    }\n  };\n\n  function maybeInitVimState(cm) {\n    if (!cm.state.vim) {\n      cm.state.vim = {\n        inputState: new InputState(),\n        lastEditInputState: undefined,\n        lastEditActionCommand: undefined,\n        lastHPos: -1,\n        lastHSPos: -1,\n        lastMotion: null,\n        marks: {},\n        fakeCursor: null,\n        insertMode: false,\n        insertModeRepeat: undefined,\n        visualMode: false,\n        visualLine: false,\n        visualBlock: false,\n        lastSelection: null,\n        lastPastedText: null,\n        sel: {},\n        options: {}\n      };\n    }\n\n    return cm.state.vim;\n  }\n\n  var vimGlobalState;\n\n  function resetVimGlobalState() {\n    vimGlobalState = {\n      searchQuery: null,\n      searchIsReversed: false,\n      lastSubstituteReplacePart: undefined,\n      jumpList: createCircularJumpList(),\n      macroModeState: new MacroModeState(),\n      lastCharacterSearch: {\n        increment: 0,\n        forward: true,\n        selectedCharacter: ''\n      },\n      registerController: new RegisterController({}),\n      searchHistoryController: new HistoryController(),\n      exCommandHistoryController: new HistoryController()\n    };\n\n    for (var optionName in options) {\n      var option = options[optionName];\n      option.value = option.defaultValue;\n    }\n  }\n\n  var lastInsertModeKeyTimer;\n  var vimApi = {\n    buildKeyMap: function () {},\n    getRegisterController: function () {\n      return vimGlobalState.registerController;\n    },\n    resetVimGlobalState_: resetVimGlobalState,\n    getVimGlobalState_: function () {\n      return vimGlobalState;\n    },\n    maybeInitVimState_: maybeInitVimState,\n    suppressErrorLogging: false,\n    InsertModeKey: InsertModeKey,\n    map: function (lhs, rhs, ctx) {\n      exCommandDispatcher.map(lhs, rhs, ctx);\n    },\n    unmap: function (lhs, ctx) {\n      exCommandDispatcher.unmap(lhs, ctx);\n    },\n    noremap: function (lhs, rhs, ctx) {\n      function toCtxArray(ctx) {\n        return ctx ? [ctx] : ['normal', 'insert', 'visual'];\n      }\n\n      var ctxsToMap = toCtxArray(ctx);\n      var actualLength = defaultKeymap.length,\n          origLength = defaultKeymapLength;\n\n      for (var i = actualLength - origLength; i < actualLength && ctxsToMap.length; i++) {\n        var mapping = defaultKeymap[i];\n\n        if (mapping.keys == rhs && (!ctx || !mapping.context || mapping.context === ctx) && mapping.type.substr(0, 2) !== 'ex' && mapping.type.substr(0, 3) !== 'key') {\n          var newMapping = {};\n\n          for (var key in mapping) {\n            newMapping[key] = mapping[key];\n          }\n\n          newMapping.keys = lhs;\n\n          if (ctx && !newMapping.context) {\n            newMapping.context = ctx;\n          }\n\n          this._mapCommand(newMapping);\n\n          var mappedCtxs = toCtxArray(mapping.context);\n          ctxsToMap = ctxsToMap.filter(function (el) {\n            return mappedCtxs.indexOf(el) === -1;\n          });\n        }\n      }\n    },\n    mapclear: function (ctx) {\n      var actualLength = defaultKeymap.length,\n          origLength = defaultKeymapLength;\n      var userKeymap = defaultKeymap.slice(0, actualLength - origLength);\n      defaultKeymap = defaultKeymap.slice(actualLength - origLength);\n\n      if (ctx) {\n        for (var i = userKeymap.length - 1; i >= 0; i--) {\n          var mapping = userKeymap[i];\n\n          if (ctx !== mapping.context) {\n            if (mapping.context) {\n              this._mapCommand(mapping);\n            } else {\n              var contexts = ['normal', 'insert', 'visual'];\n\n              for (var j in contexts) {\n                if (contexts[j] !== ctx) {\n                  var newMapping = {};\n\n                  for (var key in mapping) {\n                    newMapping[key] = mapping[key];\n                  }\n\n                  newMapping.context = contexts[j];\n\n                  this._mapCommand(newMapping);\n                }\n              }\n            }\n          }\n        }\n      }\n    },\n    setOption: setOption,\n    getOption: getOption,\n    defineOption: defineOption,\n    defineEx: function (name, prefix, func) {\n      if (!prefix) {\n        prefix = name;\n      } else if (name.indexOf(prefix) !== 0) {\n        throw new Error('(Vim.defineEx) \"' + prefix + '\" is not a prefix of \"' + name + '\", command not registered');\n      }\n\n      exCommands[name] = func;\n      exCommandDispatcher.commandMap_[prefix] = {\n        name: name,\n        shortName: prefix,\n        type: 'api'\n      };\n    },\n    handleKey: function (cm, key, origin) {\n      var command = this.findKey(cm, key, origin);\n\n      if (typeof command === 'function') {\n        return command();\n      }\n    },\n    findKey: function (cm, key, origin) {\n      var vim = maybeInitVimState(cm);\n\n      function handleMacroRecording() {\n        var macroModeState = vimGlobalState.macroModeState;\n\n        if (macroModeState.isRecording) {\n          if (key == 'q') {\n            macroModeState.exitMacroRecordMode();\n            clearInputState(cm);\n            return true;\n          }\n\n          if (origin != 'mapping') {\n            logKey(macroModeState, key);\n          }\n        }\n      }\n\n      function handleEsc() {\n        if (key == '<Esc>') {\n          clearInputState(cm);\n\n          if (vim.visualMode) {\n            exitVisualMode(cm);\n          } else if (vim.insertMode) {\n            exitInsertMode(cm);\n          }\n\n          return true;\n        }\n      }\n\n      function doKeyToKey(keys) {\n        var match;\n\n        while (keys) {\n          match = /<\\w+-.+?>|<\\w+>|./.exec(keys);\n          key = match[0];\n          keys = keys.substring(match.index + key.length);\n          CodeMirror.Vim.handleKey(cm, key, 'mapping');\n        }\n      }\n\n      function handleKeyInsertMode() {\n        if (handleEsc()) {\n          return true;\n        }\n\n        var keys = vim.inputState.keyBuffer = vim.inputState.keyBuffer + key;\n        var keysAreChars = key.length == 1;\n        var match = commandDispatcher.matchCommand(keys, defaultKeymap, vim.inputState, 'insert');\n\n        while (keys.length > 1 && match.type != 'full') {\n          var keys = vim.inputState.keyBuffer = keys.slice(1);\n          var thisMatch = commandDispatcher.matchCommand(keys, defaultKeymap, vim.inputState, 'insert');\n\n          if (thisMatch.type != 'none') {\n            match = thisMatch;\n          }\n        }\n\n        if (match.type == 'none') {\n          clearInputState(cm);\n          return false;\n        } else if (match.type == 'partial') {\n          if (lastInsertModeKeyTimer) {\n            window.clearTimeout(lastInsertModeKeyTimer);\n          }\n\n          lastInsertModeKeyTimer = window.setTimeout(function () {\n            if (vim.insertMode && vim.inputState.keyBuffer) {\n              clearInputState(cm);\n            }\n          }, getOption('insertModeEscKeysTimeout'));\n          return !keysAreChars;\n        }\n\n        if (lastInsertModeKeyTimer) {\n          window.clearTimeout(lastInsertModeKeyTimer);\n        }\n\n        if (keysAreChars) {\n          var selections = cm.listSelections();\n\n          for (var i = 0; i < selections.length; i++) {\n            var here = selections[i].head;\n            cm.replaceRange('', offsetCursor(here, 0, -(keys.length - 1)), here, '+input');\n          }\n\n          vimGlobalState.macroModeState.lastInsertModeChanges.changes.pop();\n        }\n\n        clearInputState(cm);\n        return match.command;\n      }\n\n      function handleKeyNonInsertMode() {\n        if (handleMacroRecording() || handleEsc()) {\n          return true;\n        }\n\n        var keys = vim.inputState.keyBuffer = vim.inputState.keyBuffer + key;\n\n        if (/^[1-9]\\d*$/.test(keys)) {\n          return true;\n        }\n\n        var keysMatcher = /^(\\d*)(.*)$/.exec(keys);\n\n        if (!keysMatcher) {\n          clearInputState(cm);\n          return false;\n        }\n\n        var context = vim.visualMode ? 'visual' : 'normal';\n        var match = commandDispatcher.matchCommand(keysMatcher[2] || keysMatcher[1], defaultKeymap, vim.inputState, context);\n\n        if (match.type == 'none') {\n          clearInputState(cm);\n          return false;\n        } else if (match.type == 'partial') {\n          return true;\n        }\n\n        vim.inputState.keyBuffer = '';\n        var keysMatcher = /^(\\d*)(.*)$/.exec(keys);\n\n        if (keysMatcher[1] && keysMatcher[1] != '0') {\n          vim.inputState.pushRepeatDigit(keysMatcher[1]);\n        }\n\n        return match.command;\n      }\n\n      var command;\n\n      if (vim.insertMode) {\n        command = handleKeyInsertMode();\n      } else {\n        command = handleKeyNonInsertMode();\n      }\n\n      if (command === false) {\n        return undefined; //ace_patch\n      } else if (command === true) {\n        return function () {\n          return true;\n        };\n      } else {\n        return function () {\n          if ((command.operator || command.isEdit) && cm.getOption('readOnly')) return; // ace_patch\n\n          return cm.operation(function () {\n            cm.curOp.isVimOp = true;\n\n            try {\n              if (command.type == 'keyToKey') {\n                doKeyToKey(command.toKeys);\n              } else {\n                commandDispatcher.processCommand(cm, vim, command);\n              }\n            } catch (e) {\n              cm.state.vim = undefined;\n              maybeInitVimState(cm);\n\n              if (!CodeMirror.Vim.suppressErrorLogging) {\n                console['log'](e);\n              }\n\n              throw e;\n            }\n\n            return true;\n          });\n        };\n      }\n    },\n    handleEx: function (cm, input) {\n      exCommandDispatcher.processCommand(cm, input);\n    },\n    defineMotion: defineMotion,\n    defineAction: defineAction,\n    defineOperator: defineOperator,\n    mapCommand: mapCommand,\n    _mapCommand: _mapCommand,\n    defineRegister: defineRegister,\n    exitVisualMode: exitVisualMode,\n    exitInsertMode: exitInsertMode\n  };\n\n  function InputState() {\n    this.prefixRepeat = [];\n    this.motionRepeat = [];\n    this.operator = null;\n    this.operatorArgs = null;\n    this.motion = null;\n    this.motionArgs = null;\n    this.keyBuffer = []; // For matching multi-key commands.\n\n    this.registerName = null; // Defaults to the unnamed register.\n  }\n\n  InputState.prototype.pushRepeatDigit = function (n) {\n    if (!this.operator) {\n      this.prefixRepeat = this.prefixRepeat.concat(n);\n    } else {\n      this.motionRepeat = this.motionRepeat.concat(n);\n    }\n  };\n\n  InputState.prototype.getRepeat = function () {\n    var repeat = 0;\n\n    if (this.prefixRepeat.length > 0 || this.motionRepeat.length > 0) {\n      repeat = 1;\n\n      if (this.prefixRepeat.length > 0) {\n        repeat *= parseInt(this.prefixRepeat.join(''), 10);\n      }\n\n      if (this.motionRepeat.length > 0) {\n        repeat *= parseInt(this.motionRepeat.join(''), 10);\n      }\n    }\n\n    return repeat;\n  };\n\n  function clearInputState(cm, reason) {\n    cm.state.vim.inputState = new InputState();\n    CodeMirror.signal(cm, 'vim-command-done', reason);\n  }\n\n  function Register(text, linewise, blockwise) {\n    this.clear();\n    this.keyBuffer = [text || ''];\n    this.insertModeChanges = [];\n    this.searchQueries = [];\n    this.linewise = !!linewise;\n    this.blockwise = !!blockwise;\n  }\n\n  Register.prototype = {\n    setText: function (text, linewise, blockwise) {\n      this.keyBuffer = [text || ''];\n      this.linewise = !!linewise;\n      this.blockwise = !!blockwise;\n    },\n    pushText: function (text, linewise) {\n      if (linewise) {\n        if (!this.linewise) {\n          this.keyBuffer.push('\\n');\n        }\n\n        this.linewise = true;\n      }\n\n      this.keyBuffer.push(text);\n    },\n    pushInsertModeChanges: function (changes) {\n      this.insertModeChanges.push(createInsertModeChanges(changes));\n    },\n    pushSearchQuery: function (query) {\n      this.searchQueries.push(query);\n    },\n    clear: function () {\n      this.keyBuffer = [];\n      this.insertModeChanges = [];\n      this.searchQueries = [];\n      this.linewise = false;\n    },\n    toString: function () {\n      return this.keyBuffer.join('');\n    }\n  };\n\n  function defineRegister(name, register) {\n    var registers = vimGlobalState.registerController.registers;\n\n    if (!name || name.length != 1) {\n      throw Error('Register name must be 1 character');\n    }\n\n    registers[name] = register;\n    validRegisters.push(name);\n  }\n\n  function RegisterController(registers) {\n    this.registers = registers;\n    this.unnamedRegister = registers['\"'] = new Register();\n    registers['.'] = new Register();\n    registers[':'] = new Register();\n    registers['/'] = new Register();\n  }\n\n  RegisterController.prototype = {\n    pushText: function (registerName, operator, text, linewise, blockwise) {\n      if (linewise && text.charAt(text.length - 1) !== '\\n') {\n        text += '\\n';\n      }\n\n      var register = this.isValidRegister(registerName) ? this.getRegister(registerName) : null;\n\n      if (!register) {\n        switch (operator) {\n          case 'yank':\n            this.registers['0'] = new Register(text, linewise, blockwise);\n            break;\n\n          case 'delete':\n          case 'change':\n            if (text.indexOf('\\n') == -1) {\n              this.registers['-'] = new Register(text, linewise);\n            } else {\n              this.shiftNumericRegisters_();\n              this.registers['1'] = new Register(text, linewise);\n            }\n\n            break;\n        }\n\n        this.unnamedRegister.setText(text, linewise, blockwise);\n        return;\n      }\n\n      var append = isUpperCase(registerName);\n\n      if (append) {\n        register.pushText(text, linewise);\n      } else {\n        register.setText(text, linewise, blockwise);\n      }\n\n      this.unnamedRegister.setText(register.toString(), linewise);\n    },\n    getRegister: function (name) {\n      if (!this.isValidRegister(name)) {\n        return this.unnamedRegister;\n      }\n\n      name = name.toLowerCase();\n\n      if (!this.registers[name]) {\n        this.registers[name] = new Register();\n      }\n\n      return this.registers[name];\n    },\n    isValidRegister: function (name) {\n      return name && inArray(name, validRegisters);\n    },\n    shiftNumericRegisters_: function () {\n      for (var i = 9; i >= 2; i--) {\n        this.registers[i] = this.getRegister('' + (i - 1));\n      }\n    }\n  };\n\n  function HistoryController() {\n    this.historyBuffer = [];\n    this.iterator = 0;\n    this.initialPrefix = null;\n  }\n\n  HistoryController.prototype = {\n    nextMatch: function (input, up) {\n      var historyBuffer = this.historyBuffer;\n      var dir = up ? -1 : 1;\n      if (this.initialPrefix === null) this.initialPrefix = input;\n\n      for (var i = this.iterator + dir; up ? i >= 0 : i < historyBuffer.length; i += dir) {\n        var element = historyBuffer[i];\n\n        for (var j = 0; j <= element.length; j++) {\n          if (this.initialPrefix == element.substring(0, j)) {\n            this.iterator = i;\n            return element;\n          }\n        }\n      }\n\n      if (i >= historyBuffer.length) {\n        this.iterator = historyBuffer.length;\n        return this.initialPrefix;\n      }\n\n      if (i < 0) return input;\n    },\n    pushInput: function (input) {\n      var index = this.historyBuffer.indexOf(input);\n      if (index > -1) this.historyBuffer.splice(index, 1);\n      if (input.length) this.historyBuffer.push(input);\n    },\n    reset: function () {\n      this.initialPrefix = null;\n      this.iterator = this.historyBuffer.length;\n    }\n  };\n  var commandDispatcher = {\n    matchCommand: function (keys, keyMap, inputState, context) {\n      var matches = commandMatches(keys, keyMap, context, inputState);\n\n      if (!matches.full && !matches.partial) {\n        return {\n          type: 'none'\n        };\n      } else if (!matches.full && matches.partial) {\n        return {\n          type: 'partial'\n        };\n      }\n\n      var bestMatch;\n\n      for (var i = 0; i < matches.full.length; i++) {\n        var match = matches.full[i];\n\n        if (!bestMatch) {\n          bestMatch = match;\n        }\n      }\n\n      if (bestMatch.keys.slice(-11) == '<character>') {\n        var character = lastChar(keys);\n        if (/<C-.>/.test(character) || !character) return {\n          type: 'none'\n        }; //ace_patch\n\n        inputState.selectedCharacter = character;\n      }\n\n      return {\n        type: 'full',\n        command: bestMatch\n      };\n    },\n    processCommand: function (cm, vim, command) {\n      vim.inputState.repeatOverride = command.repeatOverride;\n\n      switch (command.type) {\n        case 'motion':\n          this.processMotion(cm, vim, command);\n          break;\n\n        case 'operator':\n          this.processOperator(cm, vim, command);\n          break;\n\n        case 'operatorMotion':\n          this.processOperatorMotion(cm, vim, command);\n          break;\n\n        case 'action':\n          this.processAction(cm, vim, command);\n          break;\n\n        case 'search':\n          this.processSearch(cm, vim, command);\n          break;\n\n        case 'ex':\n        case 'keyToEx':\n          this.processEx(cm, vim, command);\n          break;\n\n        default:\n          break;\n      }\n    },\n    processMotion: function (cm, vim, command) {\n      vim.inputState.motion = command.motion;\n      vim.inputState.motionArgs = copyArgs(command.motionArgs);\n      this.evalInput(cm, vim);\n    },\n    processOperator: function (cm, vim, command) {\n      var inputState = vim.inputState;\n\n      if (inputState.operator) {\n        if (inputState.operator == command.operator) {\n          inputState.motion = 'expandToLine';\n          inputState.motionArgs = {\n            linewise: true\n          };\n          this.evalInput(cm, vim);\n          return;\n        } else {\n          clearInputState(cm);\n        }\n      }\n\n      inputState.operator = command.operator;\n      inputState.operatorArgs = copyArgs(command.operatorArgs);\n\n      if (command.exitVisualBlock) {\n        vim.visualBlock = false;\n        updateCmSelection(cm);\n      }\n\n      if (vim.visualMode) {\n        this.evalInput(cm, vim);\n      }\n    },\n    processOperatorMotion: function (cm, vim, command) {\n      var visualMode = vim.visualMode;\n      var operatorMotionArgs = copyArgs(command.operatorMotionArgs);\n\n      if (operatorMotionArgs) {\n        if (visualMode && operatorMotionArgs.visualLine) {\n          vim.visualLine = true;\n        }\n      }\n\n      this.processOperator(cm, vim, command);\n\n      if (!visualMode) {\n        this.processMotion(cm, vim, command);\n      }\n    },\n    processAction: function (cm, vim, command) {\n      var inputState = vim.inputState;\n      var repeat = inputState.getRepeat();\n      var repeatIsExplicit = !!repeat;\n      var actionArgs = copyArgs(command.actionArgs) || {};\n\n      if (inputState.selectedCharacter) {\n        actionArgs.selectedCharacter = inputState.selectedCharacter;\n      }\n\n      if (command.operator) {\n        this.processOperator(cm, vim, command);\n      }\n\n      if (command.motion) {\n        this.processMotion(cm, vim, command);\n      }\n\n      if (command.motion || command.operator) {\n        this.evalInput(cm, vim);\n      }\n\n      actionArgs.repeat = repeat || 1;\n      actionArgs.repeatIsExplicit = repeatIsExplicit;\n      actionArgs.registerName = inputState.registerName;\n      clearInputState(cm);\n      vim.lastMotion = null;\n\n      if (command.isEdit) {\n        this.recordLastEdit(vim, inputState, command);\n      }\n\n      actions[command.action](cm, actionArgs, vim);\n    },\n    processSearch: function (cm, vim, command) {\n      if (!cm.getSearchCursor) {\n        return;\n      }\n\n      var forward = command.searchArgs.forward;\n      var wholeWordOnly = command.searchArgs.wholeWordOnly;\n      getSearchState(cm).setReversed(!forward);\n      var promptPrefix = forward ? '/' : '?';\n      var originalQuery = getSearchState(cm).getQuery();\n      var originalScrollPos = cm.getScrollInfo();\n\n      function handleQuery(query, ignoreCase, smartCase) {\n        vimGlobalState.searchHistoryController.pushInput(query);\n        vimGlobalState.searchHistoryController.reset();\n\n        try {\n          updateSearchQuery(cm, query, ignoreCase, smartCase);\n        } catch (e) {\n          showConfirm(cm, 'Invalid regex: ' + query);\n          clearInputState(cm);\n          return;\n        }\n\n        commandDispatcher.processMotion(cm, vim, {\n          type: 'motion',\n          motion: 'findNext',\n          motionArgs: {\n            forward: true,\n            toJumplist: command.searchArgs.toJumplist\n          }\n        });\n      }\n\n      function onPromptClose(query) {\n        cm.scrollTo(originalScrollPos.left, originalScrollPos.top);\n        handleQuery(query, true\n        /** ignoreCase */\n        , true\n        /** smartCase */\n        );\n        var macroModeState = vimGlobalState.macroModeState;\n\n        if (macroModeState.isRecording) {\n          logSearchQuery(macroModeState, query);\n        }\n      }\n\n      function onPromptKeyUp(e, query, close) {\n        var keyName = CodeMirror.keyName(e),\n            up,\n            offset;\n\n        if (keyName == 'Up' || keyName == 'Down') {\n          up = keyName == 'Up' ? true : false;\n          offset = e.target ? e.target.selectionEnd : 0;\n          query = vimGlobalState.searchHistoryController.nextMatch(query, up) || '';\n          close(query);\n          if (offset && e.target) e.target.selectionEnd = e.target.selectionStart = Math.min(offset, e.target.value.length);\n        } else {\n          if (keyName != 'Left' && keyName != 'Right' && keyName != 'Ctrl' && keyName != 'Alt' && keyName != 'Shift') vimGlobalState.searchHistoryController.reset();\n        }\n\n        var parsedQuery;\n\n        try {\n          parsedQuery = updateSearchQuery(cm, query, true\n          /** ignoreCase */\n          , true\n          /** smartCase */\n          );\n        } catch (e) {}\n\n        if (parsedQuery) {\n          cm.scrollIntoView(findNext(cm, !forward, parsedQuery), 30);\n        } else {\n          clearSearchHighlight(cm);\n          cm.scrollTo(originalScrollPos.left, originalScrollPos.top);\n        }\n      }\n\n      function onPromptKeyDown(e, query, close) {\n        var keyName = CodeMirror.keyName(e);\n\n        if (keyName == 'Esc' || keyName == 'Ctrl-C' || keyName == 'Ctrl-[' || keyName == 'Backspace' && query == '') {\n          vimGlobalState.searchHistoryController.pushInput(query);\n          vimGlobalState.searchHistoryController.reset();\n          updateSearchQuery(cm, originalQuery);\n          clearSearchHighlight(cm);\n          cm.scrollTo(originalScrollPos.left, originalScrollPos.top);\n          CodeMirror.e_stop(e);\n          clearInputState(cm);\n          close();\n          cm.focus();\n        } else if (keyName == 'Up' || keyName == 'Down') {\n          CodeMirror.e_stop(e);\n        } else if (keyName == 'Ctrl-U') {\n          CodeMirror.e_stop(e);\n          close('');\n        }\n      }\n\n      switch (command.searchArgs.querySrc) {\n        case 'prompt':\n          var macroModeState = vimGlobalState.macroModeState;\n\n          if (macroModeState.isPlaying) {\n            var query = macroModeState.replaySearchQueries.shift();\n            handleQuery(query, true\n            /** ignoreCase */\n            , false\n            /** smartCase */\n            );\n          } else {\n            showPrompt(cm, {\n              onClose: onPromptClose,\n              prefix: promptPrefix,\n              desc: searchPromptDesc,\n              onKeyUp: onPromptKeyUp,\n              onKeyDown: onPromptKeyDown\n            });\n          }\n\n          break;\n\n        case 'wordUnderCursor':\n          var word = expandWordUnderCursor(cm, false\n          /** inclusive */\n          , true\n          /** forward */\n          , false\n          /** bigWord */\n          , true\n          /** noSymbol */\n          );\n          var isKeyword = true;\n\n          if (!word) {\n            word = expandWordUnderCursor(cm, false\n            /** inclusive */\n            , true\n            /** forward */\n            , false\n            /** bigWord */\n            , false\n            /** noSymbol */\n            );\n            isKeyword = false;\n          }\n\n          if (!word) {\n            return;\n          }\n\n          var query = cm.getLine(word.start.line).substring(word.start.ch, word.end.ch);\n\n          if (isKeyword && wholeWordOnly) {\n            query = '\\\\b' + query + '\\\\b';\n          } else {\n            query = escapeRegex(query);\n          }\n\n          vimGlobalState.jumpList.cachedCursor = cm.getCursor();\n          cm.setCursor(word.start);\n          handleQuery(query, true\n          /** ignoreCase */\n          , false\n          /** smartCase */\n          );\n          break;\n      }\n    },\n    processEx: function (cm, vim, command) {\n      function onPromptClose(input) {\n        vimGlobalState.exCommandHistoryController.pushInput(input);\n        vimGlobalState.exCommandHistoryController.reset();\n        exCommandDispatcher.processCommand(cm, input);\n      }\n\n      function onPromptKeyDown(e, input, close) {\n        var keyName = CodeMirror.keyName(e),\n            up,\n            offset;\n\n        if (keyName == 'Esc' || keyName == 'Ctrl-C' || keyName == 'Ctrl-[' || keyName == 'Backspace' && input == '') {\n          vimGlobalState.exCommandHistoryController.pushInput(input);\n          vimGlobalState.exCommandHistoryController.reset();\n          CodeMirror.e_stop(e);\n          clearInputState(cm);\n          close();\n          cm.focus();\n        }\n\n        if (keyName == 'Up' || keyName == 'Down') {\n          CodeMirror.e_stop(e);\n          up = keyName == 'Up' ? true : false;\n          offset = e.target ? e.target.selectionEnd : 0;\n          input = vimGlobalState.exCommandHistoryController.nextMatch(input, up) || '';\n          close(input);\n          if (offset && e.target) e.target.selectionEnd = e.target.selectionStart = Math.min(offset, e.target.value.length);\n        } else if (keyName == 'Ctrl-U') {\n          CodeMirror.e_stop(e);\n          close('');\n        } else {\n          if (keyName != 'Left' && keyName != 'Right' && keyName != 'Ctrl' && keyName != 'Alt' && keyName != 'Shift') vimGlobalState.exCommandHistoryController.reset();\n        }\n      }\n\n      if (command.type == 'keyToEx') {\n        exCommandDispatcher.processCommand(cm, command.exArgs.input);\n      } else {\n        if (vim.visualMode) {\n          showPrompt(cm, {\n            onClose: onPromptClose,\n            prefix: ':',\n            value: '\\'<,\\'>',\n            onKeyDown: onPromptKeyDown,\n            selectValueOnOpen: false\n          });\n        } else {\n          showPrompt(cm, {\n            onClose: onPromptClose,\n            prefix: ':',\n            onKeyDown: onPromptKeyDown\n          });\n        }\n      }\n    },\n    evalInput: function (cm, vim) {\n      var inputState = vim.inputState;\n      var motion = inputState.motion;\n      var motionArgs = inputState.motionArgs || {};\n      var operator = inputState.operator;\n      var operatorArgs = inputState.operatorArgs || {};\n      var registerName = inputState.registerName;\n      var sel = vim.sel;\n      var origHead = copyCursor(vim.visualMode ? clipCursorToContent(cm, sel.head) : cm.getCursor('head'));\n      var origAnchor = copyCursor(vim.visualMode ? clipCursorToContent(cm, sel.anchor) : cm.getCursor('anchor'));\n      var oldHead = copyCursor(origHead);\n      var oldAnchor = copyCursor(origAnchor);\n      var newHead, newAnchor;\n      var repeat;\n\n      if (operator) {\n        this.recordLastEdit(vim, inputState);\n      }\n\n      if (inputState.repeatOverride !== undefined) {\n        repeat = inputState.repeatOverride;\n      } else {\n        repeat = inputState.getRepeat();\n      }\n\n      if (repeat > 0 && motionArgs.explicitRepeat) {\n        motionArgs.repeatIsExplicit = true;\n      } else if (motionArgs.noRepeat || !motionArgs.explicitRepeat && repeat === 0) {\n        repeat = 1;\n        motionArgs.repeatIsExplicit = false;\n      }\n\n      if (inputState.selectedCharacter) {\n        motionArgs.selectedCharacter = operatorArgs.selectedCharacter = inputState.selectedCharacter;\n      }\n\n      motionArgs.repeat = repeat;\n      clearInputState(cm);\n\n      if (motion) {\n        var motionResult = motions[motion](cm, origHead, motionArgs, vim);\n        vim.lastMotion = motions[motion];\n\n        if (!motionResult) {\n          return;\n        }\n\n        if (motionArgs.toJumplist) {\n          if (!operator && cm.ace.curOp != null) cm.ace.curOp.command.scrollIntoView = \"center-animate\"; // ace_patch\n\n          var jumpList = vimGlobalState.jumpList;\n          var cachedCursor = jumpList.cachedCursor;\n\n          if (cachedCursor) {\n            recordJumpPosition(cm, cachedCursor, motionResult);\n            delete jumpList.cachedCursor;\n          } else {\n            recordJumpPosition(cm, origHead, motionResult);\n          }\n        }\n\n        if (motionResult instanceof Array) {\n          newAnchor = motionResult[0];\n          newHead = motionResult[1];\n        } else {\n          newHead = motionResult;\n        }\n\n        if (!newHead) {\n          newHead = copyCursor(origHead);\n        }\n\n        if (vim.visualMode) {\n          if (!(vim.visualBlock && newHead.ch === Infinity)) {\n            newHead = clipCursorToContent(cm, newHead, vim.visualBlock);\n          }\n\n          if (newAnchor) {\n            newAnchor = clipCursorToContent(cm, newAnchor, true);\n          }\n\n          newAnchor = newAnchor || oldAnchor;\n          sel.anchor = newAnchor;\n          sel.head = newHead;\n          updateCmSelection(cm);\n          updateMark(cm, vim, '<', cursorIsBefore(newAnchor, newHead) ? newAnchor : newHead);\n          updateMark(cm, vim, '>', cursorIsBefore(newAnchor, newHead) ? newHead : newAnchor);\n        } else if (!operator) {\n          newHead = clipCursorToContent(cm, newHead);\n          cm.setCursor(newHead.line, newHead.ch);\n        }\n      }\n\n      if (operator) {\n        if (operatorArgs.lastSel) {\n          newAnchor = oldAnchor;\n          var lastSel = operatorArgs.lastSel;\n          var lineOffset = Math.abs(lastSel.head.line - lastSel.anchor.line);\n          var chOffset = Math.abs(lastSel.head.ch - lastSel.anchor.ch);\n\n          if (lastSel.visualLine) {\n            newHead = Pos(oldAnchor.line + lineOffset, oldAnchor.ch);\n          } else if (lastSel.visualBlock) {\n            newHead = Pos(oldAnchor.line + lineOffset, oldAnchor.ch + chOffset);\n          } else if (lastSel.head.line == lastSel.anchor.line) {\n            newHead = Pos(oldAnchor.line, oldAnchor.ch + chOffset);\n          } else {\n            newHead = Pos(oldAnchor.line + lineOffset, oldAnchor.ch);\n          }\n\n          vim.visualMode = true;\n          vim.visualLine = lastSel.visualLine;\n          vim.visualBlock = lastSel.visualBlock;\n          sel = vim.sel = {\n            anchor: newAnchor,\n            head: newHead\n          };\n          updateCmSelection(cm);\n        } else if (vim.visualMode) {\n          operatorArgs.lastSel = {\n            anchor: copyCursor(sel.anchor),\n            head: copyCursor(sel.head),\n            visualBlock: vim.visualBlock,\n            visualLine: vim.visualLine\n          };\n        }\n\n        var curStart, curEnd, linewise, mode;\n        var cmSel;\n\n        if (vim.visualMode) {\n          curStart = cursorMin(sel.head, sel.anchor);\n          curEnd = cursorMax(sel.head, sel.anchor);\n          linewise = vim.visualLine || operatorArgs.linewise;\n          mode = vim.visualBlock ? 'block' : linewise ? 'line' : 'char';\n          cmSel = makeCmSelection(cm, {\n            anchor: curStart,\n            head: curEnd\n          }, mode);\n\n          if (linewise) {\n            var ranges = cmSel.ranges;\n\n            if (mode == 'block') {\n              for (var i = 0; i < ranges.length; i++) {\n                ranges[i].head.ch = lineLength(cm, ranges[i].head.line);\n              }\n            } else if (mode == 'line') {\n              ranges[0].head = Pos(ranges[0].head.line + 1, 0);\n            }\n          }\n        } else {\n          curStart = copyCursor(newAnchor || oldAnchor);\n          curEnd = copyCursor(newHead || oldHead);\n\n          if (cursorIsBefore(curEnd, curStart)) {\n            var tmp = curStart;\n            curStart = curEnd;\n            curEnd = tmp;\n          }\n\n          linewise = motionArgs.linewise || operatorArgs.linewise;\n\n          if (linewise) {\n            expandSelectionToLine(cm, curStart, curEnd);\n          } else if (motionArgs.forward) {\n            clipToLine(cm, curStart, curEnd);\n          }\n\n          mode = 'char';\n          var exclusive = !motionArgs.inclusive || linewise;\n          cmSel = makeCmSelection(cm, {\n            anchor: curStart,\n            head: curEnd\n          }, mode, exclusive);\n        }\n\n        cm.setSelections(cmSel.ranges, cmSel.primary);\n        vim.lastMotion = null;\n        operatorArgs.repeat = repeat; // For indent in visual mode.\n\n        operatorArgs.registerName = registerName;\n        operatorArgs.linewise = linewise;\n        var operatorMoveTo = operators[operator](cm, operatorArgs, cmSel.ranges, oldAnchor, newHead);\n\n        if (vim.visualMode) {\n          exitVisualMode(cm, operatorMoveTo != null);\n        }\n\n        if (operatorMoveTo) {\n          cm.setCursor(operatorMoveTo);\n        }\n      }\n    },\n    recordLastEdit: function (vim, inputState, actionCommand) {\n      var macroModeState = vimGlobalState.macroModeState;\n\n      if (macroModeState.isPlaying) {\n        return;\n      }\n\n      vim.lastEditInputState = inputState;\n      vim.lastEditActionCommand = actionCommand;\n      macroModeState.lastInsertModeChanges.changes = [];\n      macroModeState.lastInsertModeChanges.expectCursorActivityForChange = false;\n      macroModeState.lastInsertModeChanges.visualBlock = vim.visualBlock ? vim.sel.head.line - vim.sel.anchor.line : 0;\n    }\n  };\n  var motions = {\n    moveToTopLine: function (cm, _head, motionArgs) {\n      var line = getUserVisibleLines(cm).top + motionArgs.repeat - 1;\n      return Pos(line, findFirstNonWhiteSpaceCharacter(cm.getLine(line)));\n    },\n    moveToMiddleLine: function (cm) {\n      var range = getUserVisibleLines(cm);\n      var line = Math.floor((range.top + range.bottom) * 0.5);\n      return Pos(line, findFirstNonWhiteSpaceCharacter(cm.getLine(line)));\n    },\n    moveToBottomLine: function (cm, _head, motionArgs) {\n      var line = getUserVisibleLines(cm).bottom - motionArgs.repeat + 1;\n      return Pos(line, findFirstNonWhiteSpaceCharacter(cm.getLine(line)));\n    },\n    expandToLine: function (_cm, head, motionArgs) {\n      var cur = head;\n      return Pos(cur.line + motionArgs.repeat - 1, Infinity);\n    },\n    findNext: function (cm, _head, motionArgs) {\n      var state = getSearchState(cm);\n      var query = state.getQuery();\n\n      if (!query) {\n        return;\n      }\n\n      var prev = !motionArgs.forward;\n      prev = state.isReversed() ? !prev : prev;\n      highlightSearchMatches(cm, query);\n      return findNext(cm, prev\n      /** prev */\n      , query, motionArgs.repeat);\n    },\n    goToMark: function (cm, _head, motionArgs, vim) {\n      var pos = getMarkPos(cm, vim, motionArgs.selectedCharacter);\n\n      if (pos) {\n        return motionArgs.linewise ? {\n          line: pos.line,\n          ch: findFirstNonWhiteSpaceCharacter(cm.getLine(pos.line))\n        } : pos;\n      }\n\n      return null;\n    },\n    moveToOtherHighlightedEnd: function (cm, _head, motionArgs, vim) {\n      if (vim.visualBlock && motionArgs.sameLine) {\n        var sel = vim.sel;\n        return [clipCursorToContent(cm, Pos(sel.anchor.line, sel.head.ch)), clipCursorToContent(cm, Pos(sel.head.line, sel.anchor.ch))];\n      } else {\n        return [vim.sel.head, vim.sel.anchor];\n      }\n    },\n    jumpToMark: function (cm, head, motionArgs, vim) {\n      var best = head;\n\n      for (var i = 0; i < motionArgs.repeat; i++) {\n        var cursor = best;\n\n        for (var key in vim.marks) {\n          if (!isLowerCase(key)) {\n            continue;\n          }\n\n          var mark = vim.marks[key].find();\n          var isWrongDirection = motionArgs.forward ? cursorIsBefore(mark, cursor) : cursorIsBefore(cursor, mark);\n\n          if (isWrongDirection) {\n            continue;\n          }\n\n          if (motionArgs.linewise && mark.line == cursor.line) {\n            continue;\n          }\n\n          var equal = cursorEqual(cursor, best);\n          var between = motionArgs.forward ? cursorIsBetween(cursor, mark, best) : cursorIsBetween(best, mark, cursor);\n\n          if (equal || between) {\n            best = mark;\n          }\n        }\n      }\n\n      if (motionArgs.linewise) {\n        best = Pos(best.line, findFirstNonWhiteSpaceCharacter(cm.getLine(best.line)));\n      }\n\n      return best;\n    },\n    moveByCharacters: function (_cm, head, motionArgs) {\n      var cur = head;\n      var repeat = motionArgs.repeat;\n      var ch = motionArgs.forward ? cur.ch + repeat : cur.ch - repeat;\n      return Pos(cur.line, ch);\n    },\n    moveByLines: function (cm, head, motionArgs, vim) {\n      var cur = head;\n      var endCh = cur.ch;\n\n      switch (vim.lastMotion) {\n        case this.moveByLines:\n        case this.moveByDisplayLines:\n        case this.moveByScroll:\n        case this.moveToColumn:\n        case this.moveToEol:\n          endCh = vim.lastHPos;\n          break;\n\n        default:\n          vim.lastHPos = endCh;\n      }\n\n      var repeat = motionArgs.repeat + (motionArgs.repeatOffset || 0);\n      var line = motionArgs.forward ? cur.line + repeat : cur.line - repeat;\n      var first = cm.firstLine();\n      var last = cm.lastLine();\n\n      if (line < first && cur.line == first) {\n        return this.moveToStartOfLine(cm, head, motionArgs, vim);\n      } else if (line > last && cur.line == last) {\n        return this.moveToEol(cm, head, motionArgs, vim, true);\n      }\n\n      var fold = cm.ace.session.getFoldLine(line);\n\n      if (fold) {\n        if (motionArgs.forward) {\n          if (line > fold.start.row) line = fold.end.row + 1;\n        } else {\n          line = fold.start.row;\n        }\n      }\n\n      if (motionArgs.toFirstChar) {\n        endCh = findFirstNonWhiteSpaceCharacter(cm.getLine(line));\n        vim.lastHPos = endCh;\n      }\n\n      vim.lastHSPos = cm.charCoords(Pos(line, endCh), 'div').left;\n      return Pos(line, endCh);\n    },\n    moveByDisplayLines: function (cm, head, motionArgs, vim) {\n      var cur = head;\n\n      switch (vim.lastMotion) {\n        case this.moveByDisplayLines:\n        case this.moveByScroll:\n        case this.moveByLines:\n        case this.moveToColumn:\n        case this.moveToEol:\n          break;\n\n        default:\n          vim.lastHSPos = cm.charCoords(cur, 'div').left;\n      }\n\n      var repeat = motionArgs.repeat;\n      var res = cm.findPosV(cur, motionArgs.forward ? repeat : -repeat, 'line', vim.lastHSPos);\n\n      if (res.hitSide) {\n        if (motionArgs.forward) {\n          var lastCharCoords = cm.charCoords(res, 'div');\n          var goalCoords = {\n            top: lastCharCoords.top + 8,\n            left: vim.lastHSPos\n          };\n          var res = cm.coordsChar(goalCoords, 'div');\n        } else {\n          var resCoords = cm.charCoords(Pos(cm.firstLine(), 0), 'div');\n          resCoords.left = vim.lastHSPos;\n          res = cm.coordsChar(resCoords, 'div');\n        }\n      }\n\n      vim.lastHPos = res.ch;\n      return res;\n    },\n    moveByPage: function (cm, head, motionArgs) {\n      var curStart = head;\n      var repeat = motionArgs.repeat;\n      return cm.findPosV(curStart, motionArgs.forward ? repeat : -repeat, 'page');\n    },\n    moveByParagraph: function (cm, head, motionArgs) {\n      var dir = motionArgs.forward ? 1 : -1;\n      return findParagraph(cm, head, motionArgs.repeat, dir);\n    },\n    moveBySentence: function (cm, head, motionArgs) {\n      var dir = motionArgs.forward ? 1 : -1;\n      return findSentence(cm, head, motionArgs.repeat, dir);\n    },\n    moveByScroll: function (cm, head, motionArgs, vim) {\n      var scrollbox = cm.getScrollInfo();\n      var curEnd = null;\n      var repeat = motionArgs.repeat;\n\n      if (!repeat) {\n        repeat = scrollbox.clientHeight / (2 * cm.defaultTextHeight());\n      }\n\n      var orig = cm.charCoords(head, 'local');\n      motionArgs.repeat = repeat;\n      var curEnd = motions.moveByDisplayLines(cm, head, motionArgs, vim);\n\n      if (!curEnd) {\n        return null;\n      }\n\n      var dest = cm.charCoords(curEnd, 'local');\n      cm.scrollTo(null, scrollbox.top + dest.top - orig.top);\n      return curEnd;\n    },\n    moveByWords: function (cm, head, motionArgs) {\n      return moveToWord(cm, head, motionArgs.repeat, !!motionArgs.forward, !!motionArgs.wordEnd, !!motionArgs.bigWord);\n    },\n    moveTillCharacter: function (cm, _head, motionArgs) {\n      var repeat = motionArgs.repeat;\n      var curEnd = moveToCharacter(cm, repeat, motionArgs.forward, motionArgs.selectedCharacter);\n      var increment = motionArgs.forward ? -1 : 1;\n      recordLastCharacterSearch(increment, motionArgs);\n      if (!curEnd) return null;\n      curEnd.ch += increment;\n      return curEnd;\n    },\n    moveToCharacter: function (cm, head, motionArgs) {\n      var repeat = motionArgs.repeat;\n      recordLastCharacterSearch(0, motionArgs);\n      return moveToCharacter(cm, repeat, motionArgs.forward, motionArgs.selectedCharacter) || head;\n    },\n    moveToSymbol: function (cm, head, motionArgs) {\n      var repeat = motionArgs.repeat;\n      return findSymbol(cm, repeat, motionArgs.forward, motionArgs.selectedCharacter) || head;\n    },\n    moveToColumn: function (cm, head, motionArgs, vim) {\n      var repeat = motionArgs.repeat;\n      vim.lastHPos = repeat - 1;\n      vim.lastHSPos = cm.charCoords(head, 'div').left;\n      return moveToColumn(cm, repeat);\n    },\n    moveToEol: function (cm, head, motionArgs, vim, keepHPos) {\n      var cur = head;\n      var retval = Pos(cur.line + motionArgs.repeat - 1, Infinity);\n      var end = cm.clipPos(retval);\n      end.ch--;\n\n      if (!keepHPos) {\n        vim.lastHPos = Infinity;\n        vim.lastHSPos = cm.charCoords(end, 'div').left;\n      }\n\n      return retval;\n    },\n    moveToFirstNonWhiteSpaceCharacter: function (cm, head) {\n      var cursor = head;\n      return Pos(cursor.line, findFirstNonWhiteSpaceCharacter(cm.getLine(cursor.line)));\n    },\n    moveToMatchedSymbol: function (cm, head) {\n      var cursor = head;\n      var line = cursor.line;\n      var ch = cursor.ch;\n      var lineText = cm.getLine(line);\n      var symbol;\n\n      for (; ch < lineText.length; ch++) {\n        symbol = lineText.charAt(ch);\n\n        if (symbol && isMatchableSymbol(symbol)) {\n          var style = cm.getTokenTypeAt(Pos(line, ch + 1));\n\n          if (style !== \"string\" && style !== \"comment\") {\n            break;\n          }\n        }\n      }\n\n      if (ch < lineText.length) {\n        var re = /[<>]/.test(lineText[ch]) ? /[(){}[\\]<>]/ : /[(){}[\\]]/; //ace_patch?\n\n        var matched = cm.findMatchingBracket(Pos(line, ch + 1), {\n          bracketRegex: re\n        });\n        return matched.to;\n      } else {\n        return cursor;\n      }\n    },\n    moveToStartOfLine: function (_cm, head) {\n      return Pos(head.line, 0);\n    },\n    moveToLineOrEdgeOfDocument: function (cm, _head, motionArgs) {\n      var lineNum = motionArgs.forward ? cm.lastLine() : cm.firstLine();\n\n      if (motionArgs.repeatIsExplicit) {\n        lineNum = motionArgs.repeat - cm.getOption('firstLineNumber');\n      }\n\n      return Pos(lineNum, findFirstNonWhiteSpaceCharacter(cm.getLine(lineNum)));\n    },\n    textObjectManipulation: function (cm, head, motionArgs, vim) {\n      var mirroredPairs = {\n        '(': ')',\n        ')': '(',\n        '{': '}',\n        '}': '{',\n        '[': ']',\n        ']': '[',\n        '<': '>',\n        '>': '<'\n      };\n      var selfPaired = {\n        '\\'': true,\n        '\"': true,\n        '`': true\n      };\n      var character = motionArgs.selectedCharacter;\n\n      if (character == 'b') {\n        character = '(';\n      } else if (character == 'B') {\n        character = '{';\n      }\n\n      var inclusive = !motionArgs.textObjectInner;\n      var tmp;\n\n      if (mirroredPairs[character]) {\n        tmp = selectCompanionObject(cm, head, character, inclusive);\n      } else if (selfPaired[character]) {\n        tmp = findBeginningAndEnd(cm, head, character, inclusive);\n      } else if (character === 'W') {\n        tmp = expandWordUnderCursor(cm, inclusive, true\n        /** forward */\n        , true\n        /** bigWord */\n        );\n      } else if (character === 'w') {\n        tmp = expandWordUnderCursor(cm, inclusive, true\n        /** forward */\n        , false\n        /** bigWord */\n        );\n      } else if (character === 'p') {\n        tmp = findParagraph(cm, head, motionArgs.repeat, 0, inclusive);\n        motionArgs.linewise = true;\n\n        if (vim.visualMode) {\n          if (!vim.visualLine) {\n            vim.visualLine = true;\n          }\n        } else {\n          var operatorArgs = vim.inputState.operatorArgs;\n\n          if (operatorArgs) {\n            operatorArgs.linewise = true;\n          }\n\n          tmp.end.line--;\n        }\n      } else {\n        return null;\n      }\n\n      if (!cm.state.vim.visualMode) {\n        return [tmp.start, tmp.end];\n      } else {\n        return expandSelection(cm, tmp.start, tmp.end);\n      }\n    },\n    repeatLastCharacterSearch: function (cm, head, motionArgs) {\n      var lastSearch = vimGlobalState.lastCharacterSearch;\n      var repeat = motionArgs.repeat;\n      var forward = motionArgs.forward === lastSearch.forward;\n      var increment = (lastSearch.increment ? 1 : 0) * (forward ? -1 : 1);\n      cm.moveH(-increment, 'char');\n      motionArgs.inclusive = forward ? true : false;\n      var curEnd = moveToCharacter(cm, repeat, forward, lastSearch.selectedCharacter);\n\n      if (!curEnd) {\n        cm.moveH(increment, 'char');\n        return head;\n      }\n\n      curEnd.ch += increment;\n      return curEnd;\n    }\n  };\n\n  function defineMotion(name, fn) {\n    motions[name] = fn;\n  }\n\n  function fillArray(val, times) {\n    var arr = [];\n\n    for (var i = 0; i < times; i++) {\n      arr.push(val);\n    }\n\n    return arr;\n  }\n\n  var operators = {\n    change: function (cm, args, ranges) {\n      var finalHead, text;\n      var vim = cm.state.vim;\n      var anchor = ranges[0].anchor,\n          head = ranges[0].head;\n\n      if (!vim.visualMode) {\n        text = cm.getRange(anchor, head);\n        var lastState = vim.lastEditInputState || {};\n\n        if (lastState.motion == \"moveByWords\" && !isWhiteSpaceString(text)) {\n          var match = /\\s+$/.exec(text);\n\n          if (match && lastState.motionArgs && lastState.motionArgs.forward) {\n            head = offsetCursor(head, 0, -match[0].length);\n            text = text.slice(0, -match[0].length);\n          }\n        }\n\n        var prevLineEnd = new Pos(anchor.line - 1, Number.MAX_VALUE);\n        var wasLastLine = cm.firstLine() == cm.lastLine();\n\n        if (head.line > cm.lastLine() && args.linewise && !wasLastLine) {\n          cm.replaceRange('', prevLineEnd, head);\n        } else {\n          cm.replaceRange('', anchor, head);\n        }\n\n        if (args.linewise) {\n          if (!wasLastLine) {\n            cm.setCursor(prevLineEnd);\n            CodeMirror.commands.newlineAndIndent(cm);\n          }\n\n          anchor.ch = Number.MAX_VALUE;\n        }\n\n        finalHead = anchor;\n      } else if (args.fullLine) {\n        head.ch = Number.MAX_VALUE;\n        head.line--;\n        cm.setSelection(anchor, head);\n        text = cm.getSelection();\n        cm.replaceSelection(\"\");\n        finalHead = anchor;\n      } else {\n        text = cm.getSelection();\n        var replacement = fillArray('', ranges.length);\n        cm.replaceSelections(replacement);\n        finalHead = cursorMin(ranges[0].head, ranges[0].anchor);\n      }\n\n      vimGlobalState.registerController.pushText(args.registerName, 'change', text, args.linewise, ranges.length > 1);\n      actions.enterInsertMode(cm, {\n        head: finalHead\n      }, cm.state.vim);\n    },\n    'delete': function (cm, args, ranges) {\n      var finalHead, text;\n      var vim = cm.state.vim;\n\n      if (!vim.visualBlock) {\n        var anchor = ranges[0].anchor,\n            head = ranges[0].head;\n\n        if (args.linewise && head.line != cm.firstLine() && anchor.line == cm.lastLine() && anchor.line == head.line - 1) {\n          if (anchor.line == cm.firstLine()) {\n            anchor.ch = 0;\n          } else {\n            anchor = Pos(anchor.line - 1, lineLength(cm, anchor.line - 1));\n          }\n        }\n\n        text = cm.getRange(anchor, head);\n        cm.replaceRange('', anchor, head);\n        finalHead = anchor;\n\n        if (args.linewise) {\n          finalHead = motions.moveToFirstNonWhiteSpaceCharacter(cm, anchor);\n        }\n      } else {\n        text = cm.getSelection();\n        var replacement = fillArray('', ranges.length);\n        cm.replaceSelections(replacement);\n        finalHead = ranges[0].anchor;\n      }\n\n      vimGlobalState.registerController.pushText(args.registerName, 'delete', text, args.linewise, vim.visualBlock);\n      var includeLineBreak = vim.insertMode;\n      return clipCursorToContent(cm, finalHead, includeLineBreak);\n    },\n    indent: function (cm, args, ranges) {\n      var vim = cm.state.vim;\n      var startLine = ranges[0].anchor.line;\n      var endLine = vim.visualBlock ? ranges[ranges.length - 1].anchor.line : ranges[0].head.line;\n      var repeat = vim.visualMode ? args.repeat : 1;\n\n      if (args.linewise) {\n        endLine--;\n      }\n\n      for (var i = startLine; i <= endLine; i++) {\n        for (var j = 0; j < repeat; j++) {\n          cm.indentLine(i, args.indentRight);\n        }\n      }\n\n      return motions.moveToFirstNonWhiteSpaceCharacter(cm, ranges[0].anchor);\n    },\n    indentAuto: function (cm, _args, ranges) {\n      cm.execCommand(\"indentAuto\");\n      return motions.moveToFirstNonWhiteSpaceCharacter(cm, ranges[0].anchor);\n    },\n    changeCase: function (cm, args, ranges, oldAnchor, newHead) {\n      var selections = cm.getSelections();\n      var swapped = [];\n      var toLower = args.toLower;\n\n      for (var j = 0; j < selections.length; j++) {\n        var toSwap = selections[j];\n        var text = '';\n\n        if (toLower === true) {\n          text = toSwap.toLowerCase();\n        } else if (toLower === false) {\n          text = toSwap.toUpperCase();\n        } else {\n          for (var i = 0; i < toSwap.length; i++) {\n            var character = toSwap.charAt(i);\n            text += isUpperCase(character) ? character.toLowerCase() : character.toUpperCase();\n          }\n        }\n\n        swapped.push(text);\n      }\n\n      cm.replaceSelections(swapped);\n\n      if (args.shouldMoveCursor) {\n        return newHead;\n      } else if (!cm.state.vim.visualMode && args.linewise && ranges[0].anchor.line + 1 == ranges[0].head.line) {\n        return motions.moveToFirstNonWhiteSpaceCharacter(cm, oldAnchor);\n      } else if (args.linewise) {\n        return oldAnchor;\n      } else {\n        return cursorMin(ranges[0].anchor, ranges[0].head);\n      }\n    },\n    yank: function (cm, args, ranges, oldAnchor) {\n      var vim = cm.state.vim;\n      var text = cm.getSelection();\n      var endPos = vim.visualMode ? cursorMin(vim.sel.anchor, vim.sel.head, ranges[0].head, ranges[0].anchor) : oldAnchor;\n      vimGlobalState.registerController.pushText(args.registerName, 'yank', text, args.linewise, vim.visualBlock);\n      return endPos;\n    }\n  };\n\n  function defineOperator(name, fn) {\n    operators[name] = fn;\n  }\n\n  var actions = {\n    jumpListWalk: function (cm, actionArgs, vim) {\n      if (vim.visualMode) {\n        return;\n      }\n\n      var repeat = actionArgs.repeat;\n      var forward = actionArgs.forward;\n      var jumpList = vimGlobalState.jumpList;\n      var mark = jumpList.move(cm, forward ? repeat : -repeat);\n      var markPos = mark ? mark.find() : undefined;\n      markPos = markPos ? markPos : cm.getCursor();\n      cm.setCursor(markPos);\n      cm.ace.curOp.command.scrollIntoView = \"center-animate\"; // ace_patch\n    },\n    scroll: function (cm, actionArgs, vim) {\n      if (vim.visualMode) {\n        return;\n      }\n\n      var repeat = actionArgs.repeat || 1;\n      var lineHeight = cm.defaultTextHeight();\n      var top = cm.getScrollInfo().top;\n      var delta = lineHeight * repeat;\n      var newPos = actionArgs.forward ? top + delta : top - delta;\n      var cursor = copyCursor(cm.getCursor());\n      var cursorCoords = cm.charCoords(cursor, 'local');\n\n      if (actionArgs.forward) {\n        if (newPos > cursorCoords.top) {\n          cursor.line += (newPos - cursorCoords.top) / lineHeight;\n          cursor.line = Math.ceil(cursor.line);\n          cm.setCursor(cursor);\n          cursorCoords = cm.charCoords(cursor, 'local');\n          cm.scrollTo(null, cursorCoords.top);\n        } else {\n          cm.scrollTo(null, newPos);\n        }\n      } else {\n        var newBottom = newPos + cm.getScrollInfo().clientHeight;\n\n        if (newBottom < cursorCoords.bottom) {\n          cursor.line -= (cursorCoords.bottom - newBottom) / lineHeight;\n          cursor.line = Math.floor(cursor.line);\n          cm.setCursor(cursor);\n          cursorCoords = cm.charCoords(cursor, 'local');\n          cm.scrollTo(null, cursorCoords.bottom - cm.getScrollInfo().clientHeight);\n        } else {\n          cm.scrollTo(null, newPos);\n        }\n      }\n    },\n    scrollToCursor: function (cm, actionArgs) {\n      var lineNum = cm.getCursor().line;\n      var charCoords = cm.charCoords(Pos(lineNum, 0), 'local');\n      var height = cm.getScrollInfo().clientHeight;\n      var y = charCoords.top;\n      var lineHeight = charCoords.bottom - y;\n\n      switch (actionArgs.position) {\n        case 'center':\n          y = y - height / 2 + lineHeight;\n          break;\n\n        case 'bottom':\n          y = y - height + lineHeight;\n          break;\n      }\n\n      cm.scrollTo(null, y);\n    },\n    replayMacro: function (cm, actionArgs, vim) {\n      var registerName = actionArgs.selectedCharacter;\n      var repeat = actionArgs.repeat;\n      var macroModeState = vimGlobalState.macroModeState;\n\n      if (registerName == '@') {\n        registerName = macroModeState.latestRegister;\n      } else {\n        macroModeState.latestRegister = registerName;\n      }\n\n      while (repeat--) {\n        executeMacroRegister(cm, vim, macroModeState, registerName);\n      }\n    },\n    enterMacroRecordMode: function (cm, actionArgs) {\n      var macroModeState = vimGlobalState.macroModeState;\n      var registerName = actionArgs.selectedCharacter;\n\n      if (vimGlobalState.registerController.isValidRegister(registerName)) {\n        macroModeState.enterMacroRecordMode(cm, registerName);\n      }\n    },\n    toggleOverwrite: function (cm) {\n      if (!cm.state.overwrite) {\n        cm.toggleOverwrite(true);\n        cm.setOption('keyMap', 'vim-replace');\n        CodeMirror.signal(cm, \"vim-mode-change\", {\n          mode: \"replace\"\n        });\n      } else {\n        cm.toggleOverwrite(false);\n        cm.setOption('keyMap', 'vim-insert');\n        CodeMirror.signal(cm, \"vim-mode-change\", {\n          mode: \"insert\"\n        });\n      }\n    },\n    enterInsertMode: function (cm, actionArgs, vim) {\n      if (cm.getOption('readOnly')) {\n        return;\n      }\n\n      vim.insertMode = true;\n      vim.insertModeRepeat = actionArgs && actionArgs.repeat || 1;\n      var insertAt = actionArgs ? actionArgs.insertAt : null;\n      var sel = vim.sel;\n      var head = actionArgs.head || cm.getCursor('head');\n      var height = cm.listSelections().length;\n\n      if (insertAt == 'eol') {\n        head = Pos(head.line, lineLength(cm, head.line));\n      } else if (insertAt == 'bol') {\n        head = Pos(head.line, 0);\n      } else if (insertAt == 'charAfter') {\n        head = offsetCursor(head, 0, 1);\n      } else if (insertAt == 'firstNonBlank') {\n        head = motions.moveToFirstNonWhiteSpaceCharacter(cm, head);\n      } else if (insertAt == 'startOfSelectedArea') {\n        if (!vim.visualMode) return;\n\n        if (!vim.visualBlock) {\n          if (sel.head.line < sel.anchor.line) {\n            head = sel.head;\n          } else {\n            head = Pos(sel.anchor.line, 0);\n          }\n        } else {\n          head = Pos(Math.min(sel.head.line, sel.anchor.line), Math.min(sel.head.ch, sel.anchor.ch));\n          height = Math.abs(sel.head.line - sel.anchor.line) + 1;\n        }\n      } else if (insertAt == 'endOfSelectedArea') {\n        if (!vim.visualMode) return;\n\n        if (!vim.visualBlock) {\n          if (sel.head.line >= sel.anchor.line) {\n            head = offsetCursor(sel.head, 0, 1);\n          } else {\n            head = Pos(sel.anchor.line, 0);\n          }\n        } else {\n          head = Pos(Math.min(sel.head.line, sel.anchor.line), Math.max(sel.head.ch + 1, sel.anchor.ch));\n          height = Math.abs(sel.head.line - sel.anchor.line) + 1;\n        }\n      } else if (insertAt == 'inplace') {\n        if (vim.visualMode) {\n          return;\n        }\n      } else if (insertAt == 'lastEdit') {\n        head = getLastEditPos(cm) || head;\n      }\n\n      cm.setOption('disableInput', false);\n\n      if (actionArgs && actionArgs.replace) {\n        cm.toggleOverwrite(true);\n        cm.setOption('keyMap', 'vim-replace');\n        CodeMirror.signal(cm, \"vim-mode-change\", {\n          mode: \"replace\"\n        });\n      } else {\n        cm.toggleOverwrite(false);\n        cm.setOption('keyMap', 'vim-insert');\n        CodeMirror.signal(cm, \"vim-mode-change\", {\n          mode: \"insert\"\n        });\n      }\n\n      if (!vimGlobalState.macroModeState.isPlaying) {\n        cm.on('change', onChange);\n        CodeMirror.on(cm.getInputField(), 'keydown', onKeyEventTargetKeyDown);\n      }\n\n      if (vim.visualMode) {\n        exitVisualMode(cm);\n      }\n\n      selectForInsert(cm, head, height);\n    },\n    toggleVisualMode: function (cm, actionArgs, vim) {\n      var repeat = actionArgs.repeat;\n      var anchor = cm.getCursor();\n      var head;\n\n      if (!vim.visualMode) {\n        vim.visualMode = true;\n        vim.visualLine = !!actionArgs.linewise;\n        vim.visualBlock = !!actionArgs.blockwise;\n        head = clipCursorToContent(cm, Pos(anchor.line, anchor.ch + repeat - 1), true\n        /** includeLineBreak */\n        );\n        vim.sel = {\n          anchor: anchor,\n          head: head\n        };\n        CodeMirror.signal(cm, \"vim-mode-change\", {\n          mode: \"visual\",\n          subMode: vim.visualLine ? \"linewise\" : vim.visualBlock ? \"blockwise\" : \"\"\n        });\n        updateCmSelection(cm);\n        updateMark(cm, vim, '<', cursorMin(anchor, head));\n        updateMark(cm, vim, '>', cursorMax(anchor, head));\n      } else if (vim.visualLine ^ actionArgs.linewise || vim.visualBlock ^ actionArgs.blockwise) {\n        vim.visualLine = !!actionArgs.linewise;\n        vim.visualBlock = !!actionArgs.blockwise;\n        CodeMirror.signal(cm, \"vim-mode-change\", {\n          mode: \"visual\",\n          subMode: vim.visualLine ? \"linewise\" : vim.visualBlock ? \"blockwise\" : \"\"\n        });\n        updateCmSelection(cm);\n      } else {\n        exitVisualMode(cm);\n      }\n    },\n    reselectLastSelection: function (cm, _actionArgs, vim) {\n      var lastSelection = vim.lastSelection;\n\n      if (vim.visualMode) {\n        updateLastSelection(cm, vim);\n      }\n\n      if (lastSelection) {\n        var anchor = lastSelection.anchorMark.find();\n        var head = lastSelection.headMark.find();\n\n        if (!anchor || !head) {\n          return;\n        }\n\n        vim.sel = {\n          anchor: anchor,\n          head: head\n        };\n        vim.visualMode = true;\n        vim.visualLine = lastSelection.visualLine;\n        vim.visualBlock = lastSelection.visualBlock;\n        updateCmSelection(cm);\n        updateMark(cm, vim, '<', cursorMin(anchor, head));\n        updateMark(cm, vim, '>', cursorMax(anchor, head));\n        CodeMirror.signal(cm, 'vim-mode-change', {\n          mode: 'visual',\n          subMode: vim.visualLine ? 'linewise' : vim.visualBlock ? 'blockwise' : ''\n        });\n      }\n    },\n    joinLines: function (cm, actionArgs, vim) {\n      var curStart, curEnd;\n\n      if (vim.visualMode) {\n        curStart = cm.getCursor('anchor');\n        curEnd = cm.getCursor('head');\n\n        if (cursorIsBefore(curEnd, curStart)) {\n          var tmp = curEnd;\n          curEnd = curStart;\n          curStart = tmp;\n        }\n\n        curEnd.ch = lineLength(cm, curEnd.line) - 1;\n      } else {\n        var repeat = Math.max(actionArgs.repeat, 2);\n        curStart = cm.getCursor();\n        curEnd = clipCursorToContent(cm, Pos(curStart.line + repeat - 1, Infinity));\n      }\n\n      var finalCh = 0;\n\n      for (var i = curStart.line; i < curEnd.line; i++) {\n        finalCh = lineLength(cm, curStart.line);\n        var tmp = Pos(curStart.line + 1, lineLength(cm, curStart.line + 1));\n        var text = cm.getRange(curStart, tmp);\n        text = actionArgs.keepSpaces ? text.replace(/\\n\\r?/g, '') : text.replace(/\\n\\s*/g, ' ');\n        cm.replaceRange(text, curStart, tmp);\n      }\n\n      var curFinalPos = Pos(curStart.line, finalCh);\n\n      if (vim.visualMode) {\n        exitVisualMode(cm, false);\n      }\n\n      cm.setCursor(curFinalPos);\n    },\n    newLineAndEnterInsertMode: function (cm, actionArgs, vim) {\n      vim.insertMode = true;\n      var insertAt = copyCursor(cm.getCursor());\n\n      if (insertAt.line === cm.firstLine() && !actionArgs.after) {\n        cm.replaceRange('\\n', Pos(cm.firstLine(), 0));\n        cm.setCursor(cm.firstLine(), 0);\n      } else {\n        insertAt.line = actionArgs.after ? insertAt.line : insertAt.line - 1;\n        insertAt.ch = lineLength(cm, insertAt.line);\n        cm.setCursor(insertAt);\n        var newlineFn = CodeMirror.commands.newlineAndIndentContinueComment || CodeMirror.commands.newlineAndIndent;\n        newlineFn(cm);\n      }\n\n      this.enterInsertMode(cm, {\n        repeat: actionArgs.repeat\n      }, vim);\n    },\n    paste: function (cm, actionArgs, vim) {\n      var cur = copyCursor(cm.getCursor());\n      var register = vimGlobalState.registerController.getRegister(actionArgs.registerName);\n      var text = register.toString();\n\n      if (!text) {\n        return;\n      }\n\n      if (actionArgs.matchIndent) {\n        var tabSize = cm.getOption(\"tabSize\");\n\n        var whitespaceLength = function (str) {\n          var tabs = str.split(\"\\t\").length - 1;\n          var spaces = str.split(\" \").length - 1;\n          return tabs * tabSize + spaces * 1;\n        };\n\n        var currentLine = cm.getLine(cm.getCursor().line);\n        var indent = whitespaceLength(currentLine.match(/^\\s*/)[0]);\n        var chompedText = text.replace(/\\n$/, '');\n        var wasChomped = text !== chompedText;\n        var firstIndent = whitespaceLength(text.match(/^\\s*/)[0]);\n        var text = chompedText.replace(/^\\s*/gm, function (wspace) {\n          var newIndent = indent + (whitespaceLength(wspace) - firstIndent);\n\n          if (newIndent < 0) {\n            return \"\";\n          } else if (cm.getOption(\"indentWithTabs\")) {\n            var quotient = Math.floor(newIndent / tabSize);\n            return Array(quotient + 1).join('\\t');\n          } else {\n            return Array(newIndent + 1).join(' ');\n          }\n        });\n        text += wasChomped ? \"\\n\" : \"\";\n      }\n\n      if (actionArgs.repeat > 1) {\n        var text = Array(actionArgs.repeat + 1).join(text);\n      }\n\n      var linewise = register.linewise;\n      var blockwise = register.blockwise;\n\n      if (blockwise) {\n        text = text.split('\\n');\n\n        if (linewise) {\n          text.pop();\n        }\n\n        for (var i = 0; i < text.length; i++) {\n          text[i] = text[i] == '' ? ' ' : text[i];\n        }\n\n        cur.ch += actionArgs.after ? 1 : 0;\n        cur.ch = Math.min(lineLength(cm, cur.line), cur.ch);\n      } else if (linewise) {\n        if (vim.visualMode) {\n          text = vim.visualLine ? text.slice(0, -1) : '\\n' + text.slice(0, text.length - 1) + '\\n';\n        } else if (actionArgs.after) {\n          text = '\\n' + text.slice(0, text.length - 1);\n          cur.ch = lineLength(cm, cur.line);\n        } else {\n          cur.ch = 0;\n        }\n      } else {\n        cur.ch += actionArgs.after ? 1 : 0;\n      }\n\n      var curPosFinal;\n      var idx;\n\n      if (vim.visualMode) {\n        vim.lastPastedText = text;\n        var lastSelectionCurEnd;\n        var selectedArea = getSelectedAreaRange(cm, vim);\n        var selectionStart = selectedArea[0];\n        var selectionEnd = selectedArea[1];\n        var selectedText = cm.getSelection();\n        var selections = cm.listSelections();\n        var emptyStrings = new Array(selections.length).join('1').split('1');\n\n        if (vim.lastSelection) {\n          lastSelectionCurEnd = vim.lastSelection.headMark.find();\n        }\n\n        vimGlobalState.registerController.unnamedRegister.setText(selectedText);\n\n        if (blockwise) {\n          cm.replaceSelections(emptyStrings);\n          selectionEnd = Pos(selectionStart.line + text.length - 1, selectionStart.ch);\n          cm.setCursor(selectionStart);\n          selectBlock(cm, selectionEnd);\n          cm.replaceSelections(text);\n          curPosFinal = selectionStart;\n        } else if (vim.visualBlock) {\n          cm.replaceSelections(emptyStrings);\n          cm.setCursor(selectionStart);\n          cm.replaceRange(text, selectionStart, selectionStart);\n          curPosFinal = selectionStart;\n        } else {\n          cm.replaceRange(text, selectionStart, selectionEnd);\n          curPosFinal = cm.posFromIndex(cm.indexFromPos(selectionStart) + text.length - 1);\n        }\n\n        if (lastSelectionCurEnd) {\n          vim.lastSelection.headMark = cm.setBookmark(lastSelectionCurEnd);\n        }\n\n        if (linewise) {\n          curPosFinal.ch = 0;\n        }\n      } else {\n        if (blockwise) {\n          cm.setCursor(cur);\n\n          for (var i = 0; i < text.length; i++) {\n            var line = cur.line + i;\n\n            if (line > cm.lastLine()) {\n              cm.replaceRange('\\n', Pos(line, 0));\n            }\n\n            var lastCh = lineLength(cm, line);\n\n            if (lastCh < cur.ch) {\n              extendLineToColumn(cm, line, cur.ch);\n            }\n          }\n\n          cm.setCursor(cur);\n          selectBlock(cm, Pos(cur.line + text.length - 1, cur.ch));\n          cm.replaceSelections(text);\n          curPosFinal = cur;\n        } else {\n          cm.replaceRange(text, cur);\n\n          if (linewise && actionArgs.after) {\n            curPosFinal = Pos(cur.line + 1, findFirstNonWhiteSpaceCharacter(cm.getLine(cur.line + 1)));\n          } else if (linewise && !actionArgs.after) {\n            curPosFinal = Pos(cur.line, findFirstNonWhiteSpaceCharacter(cm.getLine(cur.line)));\n          } else if (!linewise && actionArgs.after) {\n            idx = cm.indexFromPos(cur);\n            curPosFinal = cm.posFromIndex(idx + text.length - 1);\n          } else {\n            idx = cm.indexFromPos(cur);\n            curPosFinal = cm.posFromIndex(idx + text.length);\n          }\n        }\n      }\n\n      if (vim.visualMode) {\n        exitVisualMode(cm, false);\n      }\n\n      cm.setCursor(curPosFinal);\n    },\n    undo: function (cm, actionArgs) {\n      cm.operation(function () {\n        repeatFn(cm, CodeMirror.commands.undo, actionArgs.repeat)();\n        cm.setCursor(cm.getCursor('anchor'));\n      });\n    },\n    redo: function (cm, actionArgs) {\n      repeatFn(cm, CodeMirror.commands.redo, actionArgs.repeat)();\n    },\n    setRegister: function (_cm, actionArgs, vim) {\n      vim.inputState.registerName = actionArgs.selectedCharacter;\n    },\n    setMark: function (cm, actionArgs, vim) {\n      var markName = actionArgs.selectedCharacter;\n      updateMark(cm, vim, markName, cm.getCursor());\n    },\n    replace: function (cm, actionArgs, vim) {\n      var replaceWith = actionArgs.selectedCharacter;\n      var curStart = cm.getCursor();\n      var replaceTo;\n      var curEnd;\n      var selections = cm.listSelections();\n\n      if (vim.visualMode) {\n        curStart = cm.getCursor('start');\n        curEnd = cm.getCursor('end');\n      } else {\n        var line = cm.getLine(curStart.line);\n        replaceTo = curStart.ch + actionArgs.repeat;\n\n        if (replaceTo > line.length) {\n          replaceTo = line.length;\n        }\n\n        curEnd = Pos(curStart.line, replaceTo);\n      }\n\n      if (replaceWith == '\\n') {\n        if (!vim.visualMode) cm.replaceRange('', curStart, curEnd);\n        (CodeMirror.commands.newlineAndIndentContinueComment || CodeMirror.commands.newlineAndIndent)(cm);\n      } else {\n        var replaceWithStr = cm.getRange(curStart, curEnd);\n        replaceWithStr = replaceWithStr.replace(/[^\\n]/g, replaceWith);\n\n        if (vim.visualBlock) {\n          var spaces = new Array(cm.getOption(\"tabSize\") + 1).join(' ');\n          replaceWithStr = cm.getSelection();\n          replaceWithStr = replaceWithStr.replace(/\\t/g, spaces).replace(/[^\\n]/g, replaceWith).split('\\n');\n          cm.replaceSelections(replaceWithStr);\n        } else {\n          cm.replaceRange(replaceWithStr, curStart, curEnd);\n        }\n\n        if (vim.visualMode) {\n          curStart = cursorIsBefore(selections[0].anchor, selections[0].head) ? selections[0].anchor : selections[0].head;\n          cm.setCursor(curStart);\n          exitVisualMode(cm, false);\n        } else {\n          cm.setCursor(offsetCursor(curEnd, 0, -1));\n        }\n      }\n    },\n    incrementNumberToken: function (cm, actionArgs) {\n      var cur = cm.getCursor();\n      var lineStr = cm.getLine(cur.line);\n      var re = /(-?)(?:(0x)([\\da-f]+)|(0b|0|)(\\d+))/gi;\n      var match;\n      var start;\n      var end;\n      var numberStr;\n\n      while ((match = re.exec(lineStr)) !== null) {\n        start = match.index;\n        end = start + match[0].length;\n        if (cur.ch < end) break;\n      }\n\n      if (!actionArgs.backtrack && end <= cur.ch) return;\n\n      if (match) {\n        var baseStr = match[2] || match[4];\n        var digits = match[3] || match[5];\n        var increment = actionArgs.increase ? 1 : -1;\n        var base = {\n          '0b': 2,\n          '0': 8,\n          '': 10,\n          '0x': 16\n        }[baseStr.toLowerCase()];\n        var number = parseInt(match[1] + digits, base) + increment * actionArgs.repeat;\n        numberStr = number.toString(base);\n        var zeroPadding = baseStr ? new Array(digits.length - numberStr.length + 1 + match[1].length).join('0') : '';\n\n        if (numberStr.charAt(0) === '-') {\n          numberStr = '-' + baseStr + zeroPadding + numberStr.substr(1);\n        } else {\n          numberStr = baseStr + zeroPadding + numberStr;\n        }\n\n        var from = Pos(cur.line, start);\n        var to = Pos(cur.line, end);\n        cm.replaceRange(numberStr, from, to);\n      } else {\n        return;\n      }\n\n      cm.setCursor(Pos(cur.line, start + numberStr.length - 1));\n    },\n    repeatLastEdit: function (cm, actionArgs, vim) {\n      var lastEditInputState = vim.lastEditInputState;\n\n      if (!lastEditInputState) {\n        return;\n      }\n\n      var repeat = actionArgs.repeat;\n\n      if (repeat && actionArgs.repeatIsExplicit) {\n        vim.lastEditInputState.repeatOverride = repeat;\n      } else {\n        repeat = vim.lastEditInputState.repeatOverride || repeat;\n      }\n\n      repeatLastEdit(cm, vim, repeat, false\n      /** repeatForInsert */\n      );\n    },\n    indent: function (cm, actionArgs) {\n      cm.indentLine(cm.getCursor().line, actionArgs.indentRight);\n    },\n    exitInsertMode: exitInsertMode\n  };\n\n  function defineAction(name, fn) {\n    actions[name] = fn;\n  }\n\n  function clipCursorToContent(cm, cur, includeLineBreak) {\n    var line = Math.min(Math.max(cm.firstLine(), cur.line), cm.lastLine());\n    var maxCh = lineLength(cm, line) - 1;\n    maxCh = includeLineBreak ? maxCh + 1 : maxCh;\n    var ch = Math.min(Math.max(0, cur.ch), maxCh);\n    return Pos(line, ch);\n  }\n\n  function copyArgs(args) {\n    var ret = {};\n\n    for (var prop in args) {\n      if (args.hasOwnProperty(prop)) {\n        ret[prop] = args[prop];\n      }\n    }\n\n    return ret;\n  }\n\n  function offsetCursor(cur, offsetLine, offsetCh) {\n    if (typeof offsetLine === 'object') {\n      offsetCh = offsetLine.ch;\n      offsetLine = offsetLine.line;\n    }\n\n    return Pos(cur.line + offsetLine, cur.ch + offsetCh);\n  }\n\n  function commandMatches(keys, keyMap, context, inputState) {\n    var match,\n        partial = [],\n        full = [];\n\n    for (var i = 0; i < keyMap.length; i++) {\n      var command = keyMap[i];\n\n      if (context == 'insert' && command.context != 'insert' || command.context && command.context != context || inputState.operator && command.type == 'action' || !(match = commandMatch(keys, command.keys))) {\n        continue;\n      }\n\n      if (match == 'partial') {\n        partial.push(command);\n      }\n\n      if (match == 'full') {\n        full.push(command);\n      }\n    }\n\n    return {\n      partial: partial.length && partial,\n      full: full.length && full\n    };\n  }\n\n  function commandMatch(pressed, mapped) {\n    if (mapped.slice(-11) == '<character>') {\n      var prefixLen = mapped.length - 11;\n      var pressedPrefix = pressed.slice(0, prefixLen);\n      var mappedPrefix = mapped.slice(0, prefixLen);\n      return pressedPrefix == mappedPrefix && pressed.length > prefixLen ? 'full' : mappedPrefix.indexOf(pressedPrefix) == 0 ? 'partial' : false;\n    } else {\n      return pressed == mapped ? 'full' : mapped.indexOf(pressed) == 0 ? 'partial' : false;\n    }\n  }\n\n  function lastChar(keys) {\n    var match = /^.*(<[^>]+>)$/.exec(keys);\n    var selectedCharacter = match ? match[1] : keys.slice(-1);\n\n    if (selectedCharacter.length > 1) {\n      switch (selectedCharacter) {\n        case '<CR>':\n          selectedCharacter = '\\n';\n          break;\n\n        case '<Space>':\n          selectedCharacter = ' ';\n          break;\n\n        default:\n          selectedCharacter = '';\n          break;\n      }\n    }\n\n    return selectedCharacter;\n  }\n\n  function repeatFn(cm, fn, repeat) {\n    return function () {\n      for (var i = 0; i < repeat; i++) {\n        fn(cm);\n      }\n    };\n  }\n\n  function copyCursor(cur) {\n    return Pos(cur.line, cur.ch);\n  }\n\n  function cursorEqual(cur1, cur2) {\n    return cur1.ch == cur2.ch && cur1.line == cur2.line;\n  }\n\n  function cursorIsBefore(cur1, cur2) {\n    if (cur1.line < cur2.line) {\n      return true;\n    }\n\n    if (cur1.line == cur2.line && cur1.ch < cur2.ch) {\n      return true;\n    }\n\n    return false;\n  }\n\n  function cursorMin(cur1, cur2) {\n    if (arguments.length > 2) {\n      cur2 = cursorMin.apply(undefined, Array.prototype.slice.call(arguments, 1));\n    }\n\n    return cursorIsBefore(cur1, cur2) ? cur1 : cur2;\n  }\n\n  function cursorMax(cur1, cur2) {\n    if (arguments.length > 2) {\n      cur2 = cursorMax.apply(undefined, Array.prototype.slice.call(arguments, 1));\n    }\n\n    return cursorIsBefore(cur1, cur2) ? cur2 : cur1;\n  }\n\n  function cursorIsBetween(cur1, cur2, cur3) {\n    var cur1before2 = cursorIsBefore(cur1, cur2);\n    var cur2before3 = cursorIsBefore(cur2, cur3);\n    return cur1before2 && cur2before3;\n  }\n\n  function lineLength(cm, lineNum) {\n    return cm.getLine(lineNum).length;\n  }\n\n  function trim(s) {\n    if (s.trim) {\n      return s.trim();\n    }\n\n    return s.replace(/^\\s+|\\s+$/g, '');\n  }\n\n  function escapeRegex(s) {\n    return s.replace(/([.?*+$\\[\\]\\/\\\\(){}|\\-])/g, '\\\\$1');\n  }\n\n  function extendLineToColumn(cm, lineNum, column) {\n    var endCh = lineLength(cm, lineNum);\n    var spaces = new Array(column - endCh + 1).join(' ');\n    cm.setCursor(Pos(lineNum, endCh));\n    cm.replaceRange(spaces, cm.getCursor());\n  }\n\n  function selectBlock(cm, selectionEnd) {\n    var selections = [],\n        ranges = cm.listSelections();\n    var head = copyCursor(cm.clipPos(selectionEnd));\n    var isClipped = !cursorEqual(selectionEnd, head);\n    var curHead = cm.getCursor('head');\n    var primIndex = getIndex(ranges, curHead);\n    var wasClipped = cursorEqual(ranges[primIndex].head, ranges[primIndex].anchor);\n    var max = ranges.length - 1;\n    var index = max - primIndex > primIndex ? max : 0;\n    var base = ranges[index].anchor;\n    var firstLine = Math.min(base.line, head.line);\n    var lastLine = Math.max(base.line, head.line);\n    var baseCh = base.ch,\n        headCh = head.ch;\n    var dir = ranges[index].head.ch - baseCh;\n    var newDir = headCh - baseCh;\n\n    if (dir > 0 && newDir <= 0) {\n      baseCh++;\n\n      if (!isClipped) {\n        headCh--;\n      }\n    } else if (dir < 0 && newDir >= 0) {\n      baseCh--;\n\n      if (!wasClipped) {\n        headCh++;\n      }\n    } else if (dir < 0 && newDir == -1) {\n      baseCh--;\n      headCh++;\n    }\n\n    for (var line = firstLine; line <= lastLine; line++) {\n      var range = {\n        anchor: new Pos(line, baseCh),\n        head: new Pos(line, headCh)\n      };\n      selections.push(range);\n    }\n\n    cm.setSelections(selections);\n    selectionEnd.ch = headCh;\n    base.ch = baseCh;\n    return base;\n  }\n\n  function selectForInsert(cm, head, height) {\n    var sel = [];\n\n    for (var i = 0; i < height; i++) {\n      var lineHead = offsetCursor(head, i, 0);\n      sel.push({\n        anchor: lineHead,\n        head: lineHead\n      });\n    }\n\n    cm.setSelections(sel, 0);\n  }\n\n  function getIndex(ranges, cursor, end) {\n    for (var i = 0; i < ranges.length; i++) {\n      var atAnchor = end != 'head' && cursorEqual(ranges[i].anchor, cursor);\n      var atHead = end != 'anchor' && cursorEqual(ranges[i].head, cursor);\n\n      if (atAnchor || atHead) {\n        return i;\n      }\n    }\n\n    return -1;\n  }\n\n  function getSelectedAreaRange(cm, vim) {\n    var lastSelection = vim.lastSelection;\n\n    var getCurrentSelectedAreaRange = function () {\n      var selections = cm.listSelections();\n      var start = selections[0];\n      var end = selections[selections.length - 1];\n      var selectionStart = cursorIsBefore(start.anchor, start.head) ? start.anchor : start.head;\n      var selectionEnd = cursorIsBefore(end.anchor, end.head) ? end.head : end.anchor;\n      return [selectionStart, selectionEnd];\n    };\n\n    var getLastSelectedAreaRange = function () {\n      var selectionStart = cm.getCursor();\n      var selectionEnd = cm.getCursor();\n      var block = lastSelection.visualBlock;\n\n      if (block) {\n        var width = block.width;\n        var height = block.height;\n        selectionEnd = Pos(selectionStart.line + height, selectionStart.ch + width);\n        var selections = [];\n\n        for (var i = selectionStart.line; i < selectionEnd.line; i++) {\n          var anchor = Pos(i, selectionStart.ch);\n          var head = Pos(i, selectionEnd.ch);\n          var range = {\n            anchor: anchor,\n            head: head\n          };\n          selections.push(range);\n        }\n\n        cm.setSelections(selections);\n      } else {\n        var start = lastSelection.anchorMark.find();\n        var end = lastSelection.headMark.find();\n        var line = end.line - start.line;\n        var ch = end.ch - start.ch;\n        selectionEnd = {\n          line: selectionEnd.line + line,\n          ch: line ? selectionEnd.ch : ch + selectionEnd.ch\n        };\n\n        if (lastSelection.visualLine) {\n          selectionStart = Pos(selectionStart.line, 0);\n          selectionEnd = Pos(selectionEnd.line, lineLength(cm, selectionEnd.line));\n        }\n\n        cm.setSelection(selectionStart, selectionEnd);\n      }\n\n      return [selectionStart, selectionEnd];\n    };\n\n    if (!vim.visualMode) {\n      return getLastSelectedAreaRange();\n    } else {\n      return getCurrentSelectedAreaRange();\n    }\n  }\n\n  function updateLastSelection(cm, vim) {\n    var anchor = vim.sel.anchor;\n    var head = vim.sel.head;\n\n    if (vim.lastPastedText) {\n      head = cm.posFromIndex(cm.indexFromPos(anchor) + vim.lastPastedText.length);\n      vim.lastPastedText = null;\n    }\n\n    vim.lastSelection = {\n      'anchorMark': cm.setBookmark(anchor),\n      'headMark': cm.setBookmark(head),\n      'anchor': copyCursor(anchor),\n      'head': copyCursor(head),\n      'visualMode': vim.visualMode,\n      'visualLine': vim.visualLine,\n      'visualBlock': vim.visualBlock\n    };\n  }\n\n  function expandSelection(cm, start, end) {\n    var sel = cm.state.vim.sel;\n    var head = sel.head;\n    var anchor = sel.anchor;\n    var tmp;\n\n    if (cursorIsBefore(end, start)) {\n      tmp = end;\n      end = start;\n      start = tmp;\n    }\n\n    if (cursorIsBefore(head, anchor)) {\n      head = cursorMin(start, head);\n      anchor = cursorMax(anchor, end);\n    } else {\n      anchor = cursorMin(start, anchor);\n      head = cursorMax(head, end);\n      head = offsetCursor(head, 0, -1);\n\n      if (head.ch == -1 && head.line != cm.firstLine()) {\n        head = Pos(head.line - 1, lineLength(cm, head.line - 1));\n      }\n    }\n\n    return [anchor, head];\n  }\n\n  function updateCmSelection(cm, sel, mode) {\n    var vim = cm.state.vim;\n    sel = sel || vim.sel;\n    var mode = mode || vim.visualLine ? 'line' : vim.visualBlock ? 'block' : 'char';\n    var cmSel = makeCmSelection(cm, sel, mode);\n    cm.setSelections(cmSel.ranges, cmSel.primary);\n    updateFakeCursor(cm);\n  }\n\n  function makeCmSelection(cm, sel, mode, exclusive) {\n    var head = copyCursor(sel.head);\n    var anchor = copyCursor(sel.anchor);\n\n    if (mode == 'char') {\n      var headOffset = !exclusive && !cursorIsBefore(sel.head, sel.anchor) ? 1 : 0;\n      var anchorOffset = cursorIsBefore(sel.head, sel.anchor) ? 1 : 0;\n      head = offsetCursor(sel.head, 0, headOffset);\n      anchor = offsetCursor(sel.anchor, 0, anchorOffset);\n      return {\n        ranges: [{\n          anchor: anchor,\n          head: head\n        }],\n        primary: 0\n      };\n    } else if (mode == 'line') {\n      if (!cursorIsBefore(sel.head, sel.anchor)) {\n        anchor.ch = 0;\n        var lastLine = cm.lastLine();\n\n        if (head.line > lastLine) {\n          head.line = lastLine;\n        }\n\n        head.ch = lineLength(cm, head.line);\n      } else {\n        head.ch = 0;\n        anchor.ch = lineLength(cm, anchor.line);\n      }\n\n      return {\n        ranges: [{\n          anchor: anchor,\n          head: head\n        }],\n        primary: 0\n      };\n    } else if (mode == 'block') {\n      var top = Math.min(anchor.line, head.line),\n          left = Math.min(anchor.ch, head.ch),\n          bottom = Math.max(anchor.line, head.line),\n          right = Math.max(anchor.ch, head.ch) + 1;\n      var height = bottom - top + 1;\n      var primary = head.line == top ? 0 : height - 1;\n      var ranges = [];\n\n      for (var i = 0; i < height; i++) {\n        ranges.push({\n          anchor: Pos(top + i, left),\n          head: Pos(top + i, right)\n        });\n      }\n\n      return {\n        ranges: ranges,\n        primary: primary\n      };\n    }\n  }\n\n  function getHead(cm) {\n    var cur = cm.getCursor('head');\n\n    if (cm.getSelection().length == 1) {\n      cur = cursorMin(cur, cm.getCursor('anchor'));\n    }\n\n    return cur;\n  }\n\n  function exitVisualMode(cm, moveHead) {\n    var vim = cm.state.vim;\n\n    if (moveHead !== false) {\n      cm.setCursor(clipCursorToContent(cm, vim.sel.head));\n    }\n\n    updateLastSelection(cm, vim);\n    vim.visualMode = false;\n    vim.visualLine = false;\n    vim.visualBlock = false;\n    CodeMirror.signal(cm, \"vim-mode-change\", {\n      mode: \"normal\"\n    });\n\n    if (vim.fakeCursor) {\n      vim.fakeCursor.clear();\n    }\n  }\n\n  function clipToLine(cm, curStart, curEnd) {\n    var selection = cm.getRange(curStart, curEnd);\n\n    if (/\\n\\s*$/.test(selection)) {\n      var lines = selection.split('\\n');\n      lines.pop();\n      var line;\n\n      for (var line = lines.pop(); lines.length > 0 && line && isWhiteSpaceString(line); line = lines.pop()) {\n        curEnd.line--;\n        curEnd.ch = 0;\n      }\n\n      if (line) {\n        curEnd.line--;\n        curEnd.ch = lineLength(cm, curEnd.line);\n      } else {\n        curEnd.ch = 0;\n      }\n    }\n  }\n\n  function expandSelectionToLine(_cm, curStart, curEnd) {\n    curStart.ch = 0;\n    curEnd.ch = 0;\n    curEnd.line++;\n  }\n\n  function findFirstNonWhiteSpaceCharacter(text) {\n    if (!text) {\n      return 0;\n    }\n\n    var firstNonWS = text.search(/\\S/);\n    return firstNonWS == -1 ? text.length : firstNonWS;\n  }\n\n  function expandWordUnderCursor(cm, inclusive, _forward, bigWord, noSymbol) {\n    var cur = getHead(cm);\n    var line = cm.getLine(cur.line);\n    var idx = cur.ch;\n    var test = noSymbol ? wordCharTest[0] : bigWordCharTest[0];\n\n    while (!test(line.charAt(idx))) {\n      idx++;\n\n      if (idx >= line.length) {\n        return null;\n      }\n    }\n\n    if (bigWord) {\n      test = bigWordCharTest[0];\n    } else {\n      test = wordCharTest[0];\n\n      if (!test(line.charAt(idx))) {\n        test = wordCharTest[1];\n      }\n    }\n\n    var end = idx,\n        start = idx;\n\n    while (test(line.charAt(end)) && end < line.length) {\n      end++;\n    }\n\n    while (test(line.charAt(start)) && start >= 0) {\n      start--;\n    }\n\n    start++;\n\n    if (inclusive) {\n      var wordEnd = end;\n\n      while (/\\s/.test(line.charAt(end)) && end < line.length) {\n        end++;\n      }\n\n      if (wordEnd == end) {\n        var wordStart = start;\n\n        while (/\\s/.test(line.charAt(start - 1)) && start > 0) {\n          start--;\n        }\n\n        if (!start) {\n          start = wordStart;\n        }\n      }\n    }\n\n    return {\n      start: Pos(cur.line, start),\n      end: Pos(cur.line, end)\n    };\n  }\n\n  function recordJumpPosition(cm, oldCur, newCur) {\n    if (!cursorEqual(oldCur, newCur)) {\n      vimGlobalState.jumpList.add(cm, oldCur, newCur);\n    }\n  }\n\n  function recordLastCharacterSearch(increment, args) {\n    vimGlobalState.lastCharacterSearch.increment = increment;\n    vimGlobalState.lastCharacterSearch.forward = args.forward;\n    vimGlobalState.lastCharacterSearch.selectedCharacter = args.selectedCharacter;\n  }\n\n  var symbolToMode = {\n    '(': 'bracket',\n    ')': 'bracket',\n    '{': 'bracket',\n    '}': 'bracket',\n    '[': 'section',\n    ']': 'section',\n    '*': 'comment',\n    '/': 'comment',\n    'm': 'method',\n    'M': 'method',\n    '#': 'preprocess'\n  };\n  var findSymbolModes = {\n    bracket: {\n      isComplete: function (state) {\n        if (state.nextCh === state.symb) {\n          state.depth++;\n          if (state.depth >= 1) return true;\n        } else if (state.nextCh === state.reverseSymb) {\n          state.depth--;\n        }\n\n        return false;\n      }\n    },\n    section: {\n      init: function (state) {\n        state.curMoveThrough = true;\n        state.symb = (state.forward ? ']' : '[') === state.symb ? '{' : '}';\n      },\n      isComplete: function (state) {\n        return state.index === 0 && state.nextCh === state.symb;\n      }\n    },\n    comment: {\n      isComplete: function (state) {\n        var found = state.lastCh === '*' && state.nextCh === '/';\n        state.lastCh = state.nextCh;\n        return found;\n      }\n    },\n    method: {\n      init: function (state) {\n        state.symb = state.symb === 'm' ? '{' : '}';\n        state.reverseSymb = state.symb === '{' ? '}' : '{';\n      },\n      isComplete: function (state) {\n        if (state.nextCh === state.symb) return true;\n        return false;\n      }\n    },\n    preprocess: {\n      init: function (state) {\n        state.index = 0;\n      },\n      isComplete: function (state) {\n        if (state.nextCh === '#') {\n          var token = state.lineText.match(/#(\\w+)/)[1];\n\n          if (token === 'endif') {\n            if (state.forward && state.depth === 0) {\n              return true;\n            }\n\n            state.depth++;\n          } else if (token === 'if') {\n            if (!state.forward && state.depth === 0) {\n              return true;\n            }\n\n            state.depth--;\n          }\n\n          if (token === 'else' && state.depth === 0) return true;\n        }\n\n        return false;\n      }\n    }\n  };\n\n  function findSymbol(cm, repeat, forward, symb) {\n    var cur = copyCursor(cm.getCursor());\n    var increment = forward ? 1 : -1;\n    var endLine = forward ? cm.lineCount() : -1;\n    var curCh = cur.ch;\n    var line = cur.line;\n    var lineText = cm.getLine(line);\n    var state = {\n      lineText: lineText,\n      nextCh: lineText.charAt(curCh),\n      lastCh: null,\n      index: curCh,\n      symb: symb,\n      reverseSymb: (forward ? {\n        ')': '(',\n        '}': '{'\n      } : {\n        '(': ')',\n        '{': '}'\n      })[symb],\n      forward: forward,\n      depth: 0,\n      curMoveThrough: false\n    };\n    var mode = symbolToMode[symb];\n    if (!mode) return cur;\n    var init = findSymbolModes[mode].init;\n    var isComplete = findSymbolModes[mode].isComplete;\n\n    if (init) {\n      init(state);\n    }\n\n    while (line !== endLine && repeat) {\n      state.index += increment;\n      state.nextCh = state.lineText.charAt(state.index);\n\n      if (!state.nextCh) {\n        line += increment;\n        state.lineText = cm.getLine(line) || '';\n\n        if (increment > 0) {\n          state.index = 0;\n        } else {\n          var lineLen = state.lineText.length;\n          state.index = lineLen > 0 ? lineLen - 1 : 0;\n        }\n\n        state.nextCh = state.lineText.charAt(state.index);\n      }\n\n      if (isComplete(state)) {\n        cur.line = line;\n        cur.ch = state.index;\n        repeat--;\n      }\n    }\n\n    if (state.nextCh || state.curMoveThrough) {\n      return Pos(line, state.index);\n    }\n\n    return cur;\n  }\n\n  function findWord(cm, cur, forward, bigWord, emptyLineIsWord) {\n    var lineNum = cur.line;\n    var pos = cur.ch;\n    var line = cm.getLine(lineNum);\n    var dir = forward ? 1 : -1;\n    var charTests = bigWord ? bigWordCharTest : wordCharTest;\n\n    if (emptyLineIsWord && line == '') {\n      lineNum += dir;\n      line = cm.getLine(lineNum);\n\n      if (!isLine(cm, lineNum)) {\n        return null;\n      }\n\n      pos = forward ? 0 : line.length;\n    }\n\n    while (true) {\n      if (emptyLineIsWord && line == '') {\n        return {\n          from: 0,\n          to: 0,\n          line: lineNum\n        };\n      }\n\n      var stop = dir > 0 ? line.length : -1;\n      var wordStart = stop,\n          wordEnd = stop;\n\n      while (pos != stop) {\n        var foundWord = false;\n\n        for (var i = 0; i < charTests.length && !foundWord; ++i) {\n          if (charTests[i](line.charAt(pos))) {\n            wordStart = pos;\n\n            while (pos != stop && charTests[i](line.charAt(pos))) {\n              pos += dir;\n            }\n\n            wordEnd = pos;\n            foundWord = wordStart != wordEnd;\n\n            if (wordStart == cur.ch && lineNum == cur.line && wordEnd == wordStart + dir) {\n              continue;\n            } else {\n              return {\n                from: Math.min(wordStart, wordEnd + 1),\n                to: Math.max(wordStart, wordEnd),\n                line: lineNum\n              };\n            }\n          }\n        }\n\n        if (!foundWord) {\n          pos += dir;\n        }\n      }\n\n      lineNum += dir;\n\n      if (!isLine(cm, lineNum)) {\n        return null;\n      }\n\n      line = cm.getLine(lineNum);\n      pos = dir > 0 ? 0 : line.length;\n    }\n  }\n\n  function moveToWord(cm, cur, repeat, forward, wordEnd, bigWord) {\n    var curStart = copyCursor(cur);\n    var words = [];\n\n    if (forward && !wordEnd || !forward && wordEnd) {\n      repeat++;\n    }\n\n    var emptyLineIsWord = !(forward && wordEnd);\n\n    for (var i = 0; i < repeat; i++) {\n      var word = findWord(cm, cur, forward, bigWord, emptyLineIsWord);\n\n      if (!word) {\n        var eodCh = lineLength(cm, cm.lastLine());\n        words.push(forward ? {\n          line: cm.lastLine(),\n          from: eodCh,\n          to: eodCh\n        } : {\n          line: 0,\n          from: 0,\n          to: 0\n        });\n        break;\n      }\n\n      words.push(word);\n      cur = Pos(word.line, forward ? word.to - 1 : word.from);\n    }\n\n    var shortCircuit = words.length != repeat;\n    var firstWord = words[0];\n    var lastWord = words.pop();\n\n    if (forward && !wordEnd) {\n      if (!shortCircuit && (firstWord.from != curStart.ch || firstWord.line != curStart.line)) {\n        lastWord = words.pop();\n      }\n\n      return Pos(lastWord.line, lastWord.from);\n    } else if (forward && wordEnd) {\n      return Pos(lastWord.line, lastWord.to - 1);\n    } else if (!forward && wordEnd) {\n      if (!shortCircuit && (firstWord.to != curStart.ch || firstWord.line != curStart.line)) {\n        lastWord = words.pop();\n      }\n\n      return Pos(lastWord.line, lastWord.to);\n    } else {\n      return Pos(lastWord.line, lastWord.from);\n    }\n  }\n\n  function moveToCharacter(cm, repeat, forward, character) {\n    var cur = cm.getCursor();\n    var start = cur.ch;\n    var idx;\n\n    for (var i = 0; i < repeat; i++) {\n      var line = cm.getLine(cur.line);\n      idx = charIdxInLine(start, line, character, forward, true);\n\n      if (idx == -1) {\n        return null;\n      }\n\n      start = idx;\n    }\n\n    return Pos(cm.getCursor().line, idx);\n  }\n\n  function moveToColumn(cm, repeat) {\n    var line = cm.getCursor().line;\n    return clipCursorToContent(cm, Pos(line, repeat - 1));\n  }\n\n  function updateMark(cm, vim, markName, pos) {\n    if (!inArray(markName, validMarks)) {\n      return;\n    }\n\n    if (vim.marks[markName]) {\n      vim.marks[markName].clear();\n    }\n\n    vim.marks[markName] = cm.setBookmark(pos);\n  }\n\n  function charIdxInLine(start, line, character, forward, includeChar) {\n    var idx;\n\n    if (forward) {\n      idx = line.indexOf(character, start + 1);\n\n      if (idx != -1 && !includeChar) {\n        idx -= 1;\n      }\n    } else {\n      idx = line.lastIndexOf(character, start - 1);\n\n      if (idx != -1 && !includeChar) {\n        idx += 1;\n      }\n    }\n\n    return idx;\n  }\n\n  function findParagraph(cm, head, repeat, dir, inclusive) {\n    var line = head.line;\n    var min = cm.firstLine();\n    var max = cm.lastLine();\n    var start,\n        end,\n        i = line;\n\n    function isEmpty(i) {\n      return !/\\S/.test(cm.getLine(i));\n    } // ace_patch\n\n\n    function isBoundary(i, dir, any) {\n      if (any) {\n        return isEmpty(i) != isEmpty(i + dir);\n      }\n\n      return !isEmpty(i) && isEmpty(i + dir);\n    }\n\n    function skipFold(i) {\n      dir = dir > 0 ? 1 : -1;\n      var foldLine = cm.ace.session.getFoldLine(i);\n\n      if (foldLine) {\n        if (i + dir > foldLine.start.row && i + dir < foldLine.end.row) dir = (dir > 0 ? foldLine.end.row : foldLine.start.row) - i;\n      }\n    }\n\n    if (dir) {\n      while (min <= i && i <= max && repeat > 0) {\n        skipFold(i);\n\n        if (isBoundary(i, dir)) {\n          repeat--;\n        }\n\n        i += dir;\n      }\n\n      return new Pos(i, 0);\n    }\n\n    var vim = cm.state.vim;\n\n    if (vim.visualLine && isBoundary(line, 1, true)) {\n      var anchor = vim.sel.anchor;\n\n      if (isBoundary(anchor.line, -1, true)) {\n        if (!inclusive || anchor.line != line) {\n          line += 1;\n        }\n      }\n    }\n\n    var startState = isEmpty(line);\n\n    for (i = line; i <= max && repeat; i++) {\n      if (isBoundary(i, 1, true)) {\n        if (!inclusive || isEmpty(i) != startState) {\n          repeat--;\n        }\n      }\n    }\n\n    end = new Pos(i, 0);\n\n    if (i > max && !startState) {\n      startState = true;\n    } else {\n      inclusive = false;\n    }\n\n    for (i = line; i > min; i--) {\n      if (!inclusive || isEmpty(i) == startState || i == line) {\n        if (isBoundary(i, -1, true)) {\n          break;\n        }\n      }\n    }\n\n    start = new Pos(i, 0);\n    return {\n      start: start,\n      end: end\n    };\n  }\n\n  function findSentence(cm, cur, repeat, dir) {\n    function nextChar(cm, idx) {\n      if (idx.pos + idx.dir < 0 || idx.pos + idx.dir >= idx.line.length) {\n        idx.ln += idx.dir;\n\n        if (!isLine(cm, idx.ln)) {\n          idx.line = null;\n          idx.ln = null;\n          idx.pos = null;\n          return;\n        }\n\n        idx.line = cm.getLine(idx.ln);\n        idx.pos = idx.dir > 0 ? 0 : idx.line.length - 1;\n      } else {\n        idx.pos += idx.dir;\n      }\n    }\n\n    function forward(cm, ln, pos, dir) {\n      var line = cm.getLine(ln);\n      var stop = line === \"\";\n      var curr = {\n        line: line,\n        ln: ln,\n        pos: pos,\n        dir: dir\n      };\n      var last_valid = {\n        ln: curr.ln,\n        pos: curr.pos\n      };\n      var skip_empty_lines = curr.line === \"\";\n      nextChar(cm, curr);\n\n      while (curr.line !== null) {\n        last_valid.ln = curr.ln;\n        last_valid.pos = curr.pos;\n\n        if (curr.line === \"\" && !skip_empty_lines) {\n          return {\n            ln: curr.ln,\n            pos: curr.pos\n          };\n        } else if (stop && curr.line !== \"\" && !isWhiteSpaceString(curr.line[curr.pos])) {\n          return {\n            ln: curr.ln,\n            pos: curr.pos\n          };\n        } else if (isEndOfSentenceSymbol(curr.line[curr.pos]) && !stop && (curr.pos === curr.line.length - 1 || isWhiteSpaceString(curr.line[curr.pos + 1]))) {\n          stop = true;\n        }\n\n        nextChar(cm, curr);\n      }\n\n      var line = cm.getLine(last_valid.ln);\n      last_valid.pos = 0;\n\n      for (var i = line.length - 1; i >= 0; --i) {\n        if (!isWhiteSpaceString(line[i])) {\n          last_valid.pos = i;\n          break;\n        }\n      }\n\n      return last_valid;\n    }\n\n    function reverse(cm, ln, pos, dir) {\n      var line = cm.getLine(ln);\n      var curr = {\n        line: line,\n        ln: ln,\n        pos: pos,\n        dir: dir\n      };\n      var last_valid = {\n        ln: curr.ln,\n        pos: null\n      };\n      var skip_empty_lines = curr.line === \"\";\n      nextChar(cm, curr);\n\n      while (curr.line !== null) {\n        if (curr.line === \"\" && !skip_empty_lines) {\n          if (last_valid.pos !== null) {\n            return last_valid;\n          } else {\n            return {\n              ln: curr.ln,\n              pos: curr.pos\n            };\n          }\n        } else if (isEndOfSentenceSymbol(curr.line[curr.pos]) && last_valid.pos !== null && !(curr.ln === last_valid.ln && curr.pos + 1 === last_valid.pos)) {\n          return last_valid;\n        } else if (curr.line !== \"\" && !isWhiteSpaceString(curr.line[curr.pos])) {\n          skip_empty_lines = false;\n          last_valid = {\n            ln: curr.ln,\n            pos: curr.pos\n          };\n        }\n\n        nextChar(cm, curr);\n      }\n\n      var line = cm.getLine(last_valid.ln);\n      last_valid.pos = 0;\n\n      for (var i = 0; i < line.length; ++i) {\n        if (!isWhiteSpaceString(line[i])) {\n          last_valid.pos = i;\n          break;\n        }\n      }\n\n      return last_valid;\n    }\n\n    var curr_index = {\n      ln: cur.line,\n      pos: cur.ch\n    };\n\n    while (repeat > 0) {\n      if (dir < 0) {\n        curr_index = reverse(cm, curr_index.ln, curr_index.pos, dir);\n      } else {\n        curr_index = forward(cm, curr_index.ln, curr_index.pos, dir);\n      }\n\n      repeat--;\n    }\n\n    return Pos(curr_index.ln, curr_index.pos);\n  }\n\n  function selectCompanionObject(cm, head, symb, inclusive) {\n    var cur = head,\n        start,\n        end;\n    var bracketRegexp = {\n      '(': /[()]/,\n      ')': /[()]/,\n      '[': /[[\\]]/,\n      ']': /[[\\]]/,\n      '{': /[{}]/,\n      '}': /[{}]/,\n      '<': /[<>]/,\n      '>': /[<>]/\n    }[symb];\n    var openSym = {\n      '(': '(',\n      ')': '(',\n      '[': '[',\n      ']': '[',\n      '{': '{',\n      '}': '{',\n      '<': '<',\n      '>': '<'\n    }[symb];\n    var curChar = cm.getLine(cur.line).charAt(cur.ch);\n    var offset = curChar === openSym ? 1 : 0;\n    start = cm.scanForBracket(Pos(cur.line, cur.ch + offset), -1, undefined, {\n      'bracketRegex': bracketRegexp\n    });\n    end = cm.scanForBracket(Pos(cur.line, cur.ch + offset), 1, undefined, {\n      'bracketRegex': bracketRegexp\n    });\n\n    if (!start || !end) {\n      return {\n        start: cur,\n        end: cur\n      };\n    }\n\n    start = start.pos;\n    end = end.pos;\n\n    if (start.line == end.line && start.ch > end.ch || start.line > end.line) {\n      var tmp = start;\n      start = end;\n      end = tmp;\n    }\n\n    if (inclusive) {\n      end.ch += 1;\n    } else {\n      start.ch += 1;\n    }\n\n    return {\n      start: start,\n      end: end\n    };\n  }\n\n  function findBeginningAndEnd(cm, head, symb, inclusive) {\n    var cur = copyCursor(head);\n    var line = cm.getLine(cur.line);\n    var chars = line.split('');\n    var start, end, i, len;\n    var firstIndex = chars.indexOf(symb);\n\n    if (cur.ch < firstIndex) {\n      cur.ch = firstIndex;\n    } else if (firstIndex < cur.ch && chars[cur.ch] == symb) {\n      end = cur.ch; // assign end to the current cursor\n\n      --cur.ch; // make sure to look backwards\n    }\n\n    if (chars[cur.ch] == symb && !end) {\n      start = cur.ch + 1; // assign start to ahead of the cursor\n    } else {\n      for (i = cur.ch; i > -1 && !start; i--) {\n        if (chars[i] == symb) {\n          start = i + 1;\n        }\n      }\n    }\n\n    if (start && !end) {\n      for (i = start, len = chars.length; i < len && !end; i++) {\n        if (chars[i] == symb) {\n          end = i;\n        }\n      }\n    }\n\n    if (!start || !end) {\n      return {\n        start: cur,\n        end: cur\n      };\n    }\n\n    if (inclusive) {\n      --start;\n      ++end;\n    }\n\n    return {\n      start: Pos(cur.line, start),\n      end: Pos(cur.line, end)\n    };\n  }\n\n  defineOption('pcre', true, 'boolean');\n\n  function SearchState() {}\n\n  SearchState.prototype = {\n    getQuery: function () {\n      return vimGlobalState.query;\n    },\n    setQuery: function (query) {\n      vimGlobalState.query = query;\n    },\n    getOverlay: function () {\n      return this.searchOverlay;\n    },\n    setOverlay: function (overlay) {\n      this.searchOverlay = overlay;\n    },\n    isReversed: function () {\n      return vimGlobalState.isReversed;\n    },\n    setReversed: function (reversed) {\n      vimGlobalState.isReversed = reversed;\n    },\n    getScrollbarAnnotate: function () {\n      return this.annotate;\n    },\n    setScrollbarAnnotate: function (annotate) {\n      this.annotate = annotate;\n    }\n  };\n\n  function getSearchState(cm) {\n    var vim = cm.state.vim;\n    return vim.searchState_ || (vim.searchState_ = new SearchState());\n  }\n\n  function dialog(cm, template, shortText, onClose, options) {\n    if (cm.openDialog) {\n      cm.openDialog(template, onClose, {\n        bottom: true,\n        value: options.value,\n        onKeyDown: options.onKeyDown,\n        onKeyUp: options.onKeyUp,\n        selectValueOnOpen: false,\n        onClose: function () {\n          if (cm.state.vim) {\n            cm.state.vim.status = \"\";\n            cm.ace.renderer.$loop.schedule(cm.ace.renderer.CHANGE_CURSOR);\n          }\n        }\n      });\n    } else {\n      onClose(prompt(shortText, ''));\n    }\n  }\n\n  function splitBySlash(argString) {\n    return splitBySeparator(argString, '/');\n  }\n\n  function findUnescapedSlashes(argString) {\n    return findUnescapedSeparators(argString, '/');\n  }\n\n  function splitBySeparator(argString, separator) {\n    var slashes = findUnescapedSeparators(argString, separator) || [];\n    if (!slashes.length) return [];\n    var tokens = [];\n    if (slashes[0] !== 0) return;\n\n    for (var i = 0; i < slashes.length; i++) {\n      if (typeof slashes[i] == 'number') tokens.push(argString.substring(slashes[i] + 1, slashes[i + 1]));\n    }\n\n    return tokens;\n  }\n\n  function findUnescapedSeparators(str, separator) {\n    if (!separator) separator = '/';\n    var escapeNextChar = false;\n    var slashes = [];\n\n    for (var i = 0; i < str.length; i++) {\n      var c = str.charAt(i);\n\n      if (!escapeNextChar && c == separator) {\n        slashes.push(i);\n      }\n\n      escapeNextChar = !escapeNextChar && c == '\\\\';\n    }\n\n    return slashes;\n  }\n\n  function translateRegex(str) {\n    var specials = '|(){';\n    var unescape = '}';\n    var escapeNextChar = false;\n    var out = [];\n\n    for (var i = -1; i < str.length; i++) {\n      var c = str.charAt(i) || '';\n      var n = str.charAt(i + 1) || '';\n      var specialComesNext = n && specials.indexOf(n) != -1;\n\n      if (escapeNextChar) {\n        if (c !== '\\\\' || !specialComesNext) {\n          out.push(c);\n        }\n\n        escapeNextChar = false;\n      } else {\n        if (c === '\\\\') {\n          escapeNextChar = true;\n\n          if (n && unescape.indexOf(n) != -1) {\n            specialComesNext = true;\n          }\n\n          if (!specialComesNext || n === '\\\\') {\n            out.push(c);\n          }\n        } else {\n          out.push(c);\n\n          if (specialComesNext && n !== '\\\\') {\n            out.push('\\\\');\n          }\n        }\n      }\n    }\n\n    return out.join('');\n  }\n\n  var charUnescapes = {\n    '\\\\n': '\\n',\n    '\\\\r': '\\r',\n    '\\\\t': '\\t'\n  };\n\n  function translateRegexReplace(str) {\n    var escapeNextChar = false;\n    var out = [];\n\n    for (var i = -1; i < str.length; i++) {\n      var c = str.charAt(i) || '';\n      var n = str.charAt(i + 1) || '';\n\n      if (charUnescapes[c + n]) {\n        out.push(charUnescapes[c + n]);\n        i++;\n      } else if (escapeNextChar) {\n        out.push(c);\n        escapeNextChar = false;\n      } else {\n        if (c === '\\\\') {\n          escapeNextChar = true;\n\n          if (isNumber(n) || n === '$') {\n            out.push('$');\n          } else if (n !== '/' && n !== '\\\\') {\n            out.push('\\\\');\n          }\n        } else {\n          if (c === '$') {\n            out.push('$');\n          }\n\n          out.push(c);\n\n          if (n === '/') {\n            out.push('\\\\');\n          }\n        }\n      }\n    }\n\n    return out.join('');\n  }\n\n  var unescapes = {\n    '\\\\/': '/',\n    '\\\\\\\\': '\\\\',\n    '\\\\n': '\\n',\n    '\\\\r': '\\r',\n    '\\\\t': '\\t'\n  };\n\n  function unescapeRegexReplace(str) {\n    var stream = new CodeMirror.StringStream(str);\n    var output = [];\n\n    while (!stream.eol()) {\n      while (stream.peek() && stream.peek() != '\\\\') {\n        output.push(stream.next());\n      }\n\n      var matched = false;\n\n      for (var matcher in unescapes) {\n        if (stream.match(matcher, true)) {\n          matched = true;\n          output.push(unescapes[matcher]);\n          break;\n        }\n      }\n\n      if (!matched) {\n        output.push(stream.next());\n      }\n    }\n\n    return output.join('');\n  }\n\n  function parseQuery(query, ignoreCase, smartCase) {\n    var lastSearchRegister = vimGlobalState.registerController.getRegister('/');\n    lastSearchRegister.setText(query);\n\n    if (query instanceof RegExp) {\n      return query;\n    }\n\n    var slashes = findUnescapedSlashes(query);\n    var regexPart;\n    var forceIgnoreCase;\n\n    if (!slashes.length) {\n      regexPart = query;\n    } else {\n      regexPart = query.substring(0, slashes[0]);\n      var flagsPart = query.substring(slashes[0]);\n      forceIgnoreCase = flagsPart.indexOf('i') != -1;\n    }\n\n    if (!regexPart) {\n      return null;\n    }\n\n    if (!getOption('pcre')) {\n      regexPart = translateRegex(regexPart);\n    }\n\n    if (smartCase) {\n      ignoreCase = /^[^A-Z]*$/.test(regexPart);\n    }\n\n    var regexp = new RegExp(regexPart, ignoreCase || forceIgnoreCase ? 'i' : undefined);\n    return regexp;\n  }\n\n  function showConfirm(cm, text) {\n    if (cm.openNotification) {\n      cm.openNotification('<span style=\"color: red\">' + text + '</span>', {\n        bottom: true,\n        duration: 5000\n      });\n    } else {\n      alert(text);\n    }\n  }\n\n  function makePrompt(prefix, desc) {\n    var raw = '<span style=\"font-family: monospace; white-space: pre\">' + (prefix || \"\") + '<input type=\"text\" autocorrect=\"off\" autocapitalize=\"none\" autocomplete=\"off\"></span>';\n    if (desc) raw += ' <span style=\"color: #888\">' + desc + '</span>';\n    return raw;\n  }\n\n  var searchPromptDesc = '(Javascript regexp)';\n\n  function showPrompt(cm, options) {\n    var shortText = (options.prefix || '') + ' ' + (options.desc || '');\n    var prompt = makePrompt(options.prefix, options.desc);\n    dialog(cm, prompt, shortText, options.onClose, options);\n  }\n\n  function regexEqual(r1, r2) {\n    if (r1 instanceof RegExp && r2 instanceof RegExp) {\n      var props = ['global', 'multiline', 'ignoreCase', 'source'];\n\n      for (var i = 0; i < props.length; i++) {\n        var prop = props[i];\n\n        if (r1[prop] !== r2[prop]) {\n          return false;\n        }\n      }\n\n      return true;\n    }\n\n    return false;\n  }\n\n  function updateSearchQuery(cm, rawQuery, ignoreCase, smartCase) {\n    if (!rawQuery) {\n      return;\n    }\n\n    var state = getSearchState(cm);\n    var query = parseQuery(rawQuery, !!ignoreCase, !!smartCase);\n\n    if (!query) {\n      return;\n    }\n\n    highlightSearchMatches(cm, query);\n\n    if (regexEqual(query, state.getQuery())) {\n      return query;\n    }\n\n    state.setQuery(query);\n    return query;\n  }\n\n  function searchOverlay(query) {\n    if (query.source.charAt(0) == '^') {\n      var matchSol = true;\n    }\n\n    return {\n      token: function (stream) {\n        if (matchSol && !stream.sol()) {\n          stream.skipToEnd();\n          return;\n        }\n\n        var match = stream.match(query, false);\n\n        if (match) {\n          if (match[0].length == 0) {\n            stream.next();\n            return 'searching';\n          }\n\n          if (!stream.sol()) {\n            stream.backUp(1);\n\n            if (!query.exec(stream.next() + match[0])) {\n              stream.next();\n              return null;\n            }\n          }\n\n          stream.match(query);\n          return 'searching';\n        }\n\n        while (!stream.eol()) {\n          stream.next();\n          if (stream.match(query, false)) break;\n        }\n      },\n      query: query\n    };\n  }\n\n  function highlightSearchMatches(cm, query) {\n    var searchState = getSearchState(cm);\n    var overlay = searchState.getOverlay();\n\n    if (!overlay || query != overlay.query) {\n      if (overlay) {\n        cm.removeOverlay(overlay);\n      }\n\n      overlay = searchOverlay(query);\n      cm.addOverlay(overlay);\n\n      if (cm.showMatchesOnScrollbar) {\n        if (searchState.getScrollbarAnnotate()) {\n          searchState.getScrollbarAnnotate().clear();\n        }\n\n        searchState.setScrollbarAnnotate(cm.showMatchesOnScrollbar(query));\n      }\n\n      searchState.setOverlay(overlay);\n    }\n  }\n\n  function findNext(cm, prev, query, repeat) {\n    if (repeat === undefined) {\n      repeat = 1;\n    }\n\n    return cm.operation(function () {\n      var pos = cm.getCursor();\n      var cursor = cm.getSearchCursor(query, pos);\n\n      for (var i = 0; i < repeat; i++) {\n        var found = cursor.find(prev);\n\n        if (i == 0 && found && cursorEqual(cursor.from(), pos)) {\n          found = cursor.find(prev);\n        }\n\n        if (!found) {\n          cursor = cm.getSearchCursor(query, prev ? Pos(cm.lastLine()) : Pos(cm.firstLine(), 0));\n\n          if (!cursor.find(prev)) {\n            return;\n          }\n        }\n      }\n\n      return cursor.from();\n    });\n  }\n\n  function clearSearchHighlight(cm) {\n    var state = getSearchState(cm);\n    cm.removeOverlay(getSearchState(cm).getOverlay());\n    state.setOverlay(null);\n\n    if (state.getScrollbarAnnotate()) {\n      state.getScrollbarAnnotate().clear();\n      state.setScrollbarAnnotate(null);\n    }\n  }\n\n  function isInRange(pos, start, end) {\n    if (typeof pos != 'number') {\n      pos = pos.line;\n    }\n\n    if (start instanceof Array) {\n      return inArray(pos, start);\n    } else {\n      if (end) {\n        return pos >= start && pos <= end;\n      } else {\n        return pos == start;\n      }\n    }\n  }\n\n  function getUserVisibleLines(cm) {\n    var renderer = cm.ace.renderer;\n    return {\n      top: renderer.getFirstFullyVisibleRow(),\n      bottom: renderer.getLastFullyVisibleRow()\n    };\n  }\n\n  function getMarkPos(cm, vim, markName) {\n    if (markName == '\\'' || markName == '`') {\n      return vimGlobalState.jumpList.find(cm, -1) || Pos(0, 0);\n    } else if (markName == '.') {\n      return getLastEditPos(cm);\n    }\n\n    var mark = vim.marks[markName];\n    return mark && mark.find();\n  }\n\n  function getLastEditPos(cm) {\n    var undoManager = cm.ace.session.$undoManager;\n    if (undoManager && undoManager.$lastDelta) return toCmPos(undoManager.$lastDelta.end);\n  }\n\n  var ExCommandDispatcher = function () {\n    this.buildCommandMap_();\n  };\n\n  ExCommandDispatcher.prototype = {\n    processCommand: function (cm, input, opt_params) {\n      var that = this;\n      cm.operation(function () {\n        cm.curOp.isVimOp = true;\n\n        that._processCommand(cm, input, opt_params);\n      });\n    },\n    _processCommand: function (cm, input, opt_params) {\n      var vim = cm.state.vim;\n      var commandHistoryRegister = vimGlobalState.registerController.getRegister(':');\n      var previousCommand = commandHistoryRegister.toString();\n\n      if (vim.visualMode) {\n        exitVisualMode(cm);\n      }\n\n      var inputStream = new CodeMirror.StringStream(input);\n      commandHistoryRegister.setText(input);\n      var params = opt_params || {};\n      params.input = input;\n\n      try {\n        this.parseInput_(cm, inputStream, params);\n      } catch (e) {\n        showConfirm(cm, e);\n        throw e;\n      }\n\n      var command;\n      var commandName;\n\n      if (!params.commandName) {\n        if (params.line !== undefined) {\n          commandName = 'move';\n        }\n      } else {\n        command = this.matchCommand_(params.commandName);\n\n        if (command) {\n          commandName = command.name;\n\n          if (command.excludeFromCommandHistory) {\n            commandHistoryRegister.setText(previousCommand);\n          }\n\n          this.parseCommandArgs_(inputStream, params, command);\n\n          if (command.type == 'exToKey') {\n            for (var i = 0; i < command.toKeys.length; i++) {\n              CodeMirror.Vim.handleKey(cm, command.toKeys[i], 'mapping');\n            }\n\n            return;\n          } else if (command.type == 'exToEx') {\n            this.processCommand(cm, command.toInput);\n            return;\n          }\n        }\n      }\n\n      if (!commandName) {\n        showConfirm(cm, 'Not an editor command \":' + input + '\"');\n        return;\n      }\n\n      try {\n        exCommands[commandName](cm, params);\n\n        if ((!command || !command.possiblyAsync) && params.callback) {\n          params.callback();\n        }\n      } catch (e) {\n        showConfirm(cm, e);\n        throw e;\n      }\n    },\n    parseInput_: function (cm, inputStream, result) {\n      inputStream.eatWhile(':');\n\n      if (inputStream.eat('%')) {\n        result.line = cm.firstLine();\n        result.lineEnd = cm.lastLine();\n      } else {\n        result.line = this.parseLineSpec_(cm, inputStream);\n\n        if (result.line !== undefined && inputStream.eat(',')) {\n          result.lineEnd = this.parseLineSpec_(cm, inputStream);\n        }\n      }\n\n      var commandMatch = inputStream.match(/^(\\w+)/);\n\n      if (commandMatch) {\n        result.commandName = commandMatch[1];\n      } else {\n        result.commandName = inputStream.match(/.*/)[0];\n      }\n\n      return result;\n    },\n    parseLineSpec_: function (cm, inputStream) {\n      var numberMatch = inputStream.match(/^(\\d+)/);\n\n      if (numberMatch) {\n        return parseInt(numberMatch[1], 10) - 1;\n      }\n\n      switch (inputStream.next()) {\n        case '.':\n          return this.parseLineSpecOffset_(inputStream, cm.getCursor().line);\n\n        case '$':\n          return this.parseLineSpecOffset_(inputStream, cm.lastLine());\n\n        case '\\'':\n          var markName = inputStream.next();\n          var markPos = getMarkPos(cm, cm.state.vim, markName);\n          if (!markPos) throw new Error('Mark not set');\n          return this.parseLineSpecOffset_(inputStream, markPos.line);\n\n        case '-':\n        case '+':\n          inputStream.backUp(1);\n          return this.parseLineSpecOffset_(inputStream, cm.getCursor().line);\n\n        default:\n          inputStream.backUp(1);\n          return undefined;\n      }\n    },\n    parseLineSpecOffset_: function (inputStream, line) {\n      var offsetMatch = inputStream.match(/^([+-])?(\\d+)/);\n\n      if (offsetMatch) {\n        var offset = parseInt(offsetMatch[2], 10);\n\n        if (offsetMatch[1] == \"-\") {\n          line -= offset;\n        } else {\n          line += offset;\n        }\n      }\n\n      return line;\n    },\n    parseCommandArgs_: function (inputStream, params, command) {\n      if (inputStream.eol()) {\n        return;\n      }\n\n      params.argString = inputStream.match(/.*/)[0];\n      var delim = command.argDelimiter || /\\s+/;\n      var args = trim(params.argString).split(delim);\n\n      if (args.length && args[0]) {\n        params.args = args;\n      }\n    },\n    matchCommand_: function (commandName) {\n      for (var i = commandName.length; i > 0; i--) {\n        var prefix = commandName.substring(0, i);\n\n        if (this.commandMap_[prefix]) {\n          var command = this.commandMap_[prefix];\n\n          if (command.name.indexOf(commandName) === 0) {\n            return command;\n          }\n        }\n      }\n\n      return null;\n    },\n    buildCommandMap_: function () {\n      this.commandMap_ = {};\n\n      for (var i = 0; i < defaultExCommandMap.length; i++) {\n        var command = defaultExCommandMap[i];\n        var key = command.shortName || command.name;\n        this.commandMap_[key] = command;\n      }\n    },\n    map: function (lhs, rhs, ctx) {\n      if (lhs != ':' && lhs.charAt(0) == ':') {\n        if (ctx) {\n          throw Error('Mode not supported for ex mappings');\n        }\n\n        var commandName = lhs.substring(1);\n\n        if (rhs != ':' && rhs.charAt(0) == ':') {\n          this.commandMap_[commandName] = {\n            name: commandName,\n            type: 'exToEx',\n            toInput: rhs.substring(1),\n            user: true\n          };\n        } else {\n          this.commandMap_[commandName] = {\n            name: commandName,\n            type: 'exToKey',\n            toKeys: rhs,\n            user: true\n          };\n        }\n      } else {\n        if (rhs != ':' && rhs.charAt(0) == ':') {\n          var mapping = {\n            keys: lhs,\n            type: 'keyToEx',\n            exArgs: {\n              input: rhs.substring(1)\n            }\n          };\n\n          if (ctx) {\n            mapping.context = ctx;\n          }\n\n          defaultKeymap.unshift(mapping);\n        } else {\n          var mapping = {\n            keys: lhs,\n            type: 'keyToKey',\n            toKeys: rhs\n          };\n\n          if (ctx) {\n            mapping.context = ctx;\n          }\n\n          defaultKeymap.unshift(mapping);\n        }\n      }\n    },\n    unmap: function (lhs, ctx) {\n      if (lhs != ':' && lhs.charAt(0) == ':') {\n        if (ctx) {\n          throw Error('Mode not supported for ex mappings');\n        }\n\n        var commandName = lhs.substring(1);\n\n        if (this.commandMap_[commandName] && this.commandMap_[commandName].user) {\n          delete this.commandMap_[commandName];\n          return;\n        }\n      } else {\n        var keys = lhs;\n\n        for (var i = 0; i < defaultKeymap.length; i++) {\n          if (keys == defaultKeymap[i].keys && defaultKeymap[i].context === ctx) {\n            defaultKeymap.splice(i, 1);\n            return;\n          }\n        }\n      }\n    }\n  };\n  var exCommands = {\n    colorscheme: function (cm, params) {\n      if (!params.args || params.args.length < 1) {\n        showConfirm(cm, cm.getOption('theme'));\n        return;\n      }\n\n      cm.setOption('theme', params.args[0]);\n    },\n    map: function (cm, params, ctx) {\n      var mapArgs = params.args;\n\n      if (!mapArgs || mapArgs.length < 2) {\n        if (cm) {\n          showConfirm(cm, 'Invalid mapping: ' + params.input);\n        }\n\n        return;\n      }\n\n      exCommandDispatcher.map(mapArgs[0], mapArgs[1], ctx);\n    },\n    imap: function (cm, params) {\n      this.map(cm, params, 'insert');\n    },\n    nmap: function (cm, params) {\n      this.map(cm, params, 'normal');\n    },\n    vmap: function (cm, params) {\n      this.map(cm, params, 'visual');\n    },\n    unmap: function (cm, params, ctx) {\n      var mapArgs = params.args;\n\n      if (!mapArgs || mapArgs.length < 1) {\n        if (cm) {\n          showConfirm(cm, 'No such mapping: ' + params.input);\n        }\n\n        return;\n      }\n\n      exCommandDispatcher.unmap(mapArgs[0], ctx);\n    },\n    move: function (cm, params) {\n      commandDispatcher.processCommand(cm, cm.state.vim, {\n        type: 'motion',\n        motion: 'moveToLineOrEdgeOfDocument',\n        motionArgs: {\n          forward: false,\n          explicitRepeat: true,\n          linewise: true\n        },\n        repeatOverride: params.line + 1\n      });\n    },\n    set: function (cm, params) {\n      var setArgs = params.args;\n      var setCfg = params.setCfg || {};\n\n      if (!setArgs || setArgs.length < 1) {\n        if (cm) {\n          showConfirm(cm, 'Invalid mapping: ' + params.input);\n        }\n\n        return;\n      }\n\n      var expr = setArgs[0].split('=');\n      var optionName = expr[0];\n      var value = expr[1];\n      var forceGet = false;\n\n      if (optionName.charAt(optionName.length - 1) == '?') {\n        if (value) {\n          throw Error('Trailing characters: ' + params.argString);\n        }\n\n        optionName = optionName.substring(0, optionName.length - 1);\n        forceGet = true;\n      }\n\n      if (value === undefined && optionName.substring(0, 2) == 'no') {\n        optionName = optionName.substring(2);\n        value = false;\n      }\n\n      var optionIsBoolean = options[optionName] && options[optionName].type == 'boolean';\n\n      if (optionIsBoolean && value == undefined) {\n        value = true;\n      }\n\n      if (!optionIsBoolean && value === undefined || forceGet) {\n        var oldValue = getOption(optionName, cm, setCfg);\n\n        if (oldValue instanceof Error) {\n          showConfirm(cm, oldValue.message);\n        } else if (oldValue === true || oldValue === false) {\n          showConfirm(cm, ' ' + (oldValue ? '' : 'no') + optionName);\n        } else {\n          showConfirm(cm, '  ' + optionName + '=' + oldValue);\n        }\n      } else {\n        var setOptionReturn = setOption(optionName, value, cm, setCfg);\n\n        if (setOptionReturn instanceof Error) {\n          showConfirm(cm, setOptionReturn.message);\n        }\n      }\n    },\n    setlocal: function (cm, params) {\n      params.setCfg = {\n        scope: 'local'\n      };\n      this.set(cm, params);\n    },\n    setglobal: function (cm, params) {\n      params.setCfg = {\n        scope: 'global'\n      };\n      this.set(cm, params);\n    },\n    registers: function (cm, params) {\n      var regArgs = params.args;\n      var registers = vimGlobalState.registerController.registers;\n      var regInfo = '----------Registers----------<br><br>';\n\n      if (!regArgs) {\n        for (var registerName in registers) {\n          var text = registers[registerName].toString();\n\n          if (text.length) {\n            regInfo += '\"' + registerName + '    ' + text + '<br>';\n          }\n        }\n      } else {\n        var registerName;\n        regArgs = regArgs.join('');\n\n        for (var i = 0; i < regArgs.length; i++) {\n          registerName = regArgs.charAt(i);\n\n          if (!vimGlobalState.registerController.isValidRegister(registerName)) {\n            continue;\n          }\n\n          var register = registers[registerName] || new Register();\n          regInfo += '\"' + registerName + '    ' + register.toString() + '<br>';\n        }\n      }\n\n      showConfirm(cm, regInfo);\n    },\n    sort: function (cm, params) {\n      var reverse, ignoreCase, unique, number, pattern;\n\n      function parseArgs() {\n        if (params.argString) {\n          var args = new CodeMirror.StringStream(params.argString);\n\n          if (args.eat('!')) {\n            reverse = true;\n          }\n\n          if (args.eol()) {\n            return;\n          }\n\n          if (!args.eatSpace()) {\n            return 'Invalid arguments';\n          }\n\n          var opts = args.match(/([dinuox]+)?\\s*(\\/.+\\/)?\\s*/);\n\n          if (!opts && !args.eol()) {\n            return 'Invalid arguments';\n          }\n\n          if (opts[1]) {\n            ignoreCase = opts[1].indexOf('i') != -1;\n            unique = opts[1].indexOf('u') != -1;\n            var decimal = opts[1].indexOf('d') != -1 || opts[1].indexOf('n') != -1 && 1;\n            var hex = opts[1].indexOf('x') != -1 && 1;\n            var octal = opts[1].indexOf('o') != -1 && 1;\n\n            if (decimal + hex + octal > 1) {\n              return 'Invalid arguments';\n            }\n\n            number = decimal && 'decimal' || hex && 'hex' || octal && 'octal';\n          }\n\n          if (opts[2]) {\n            pattern = new RegExp(opts[2].substr(1, opts[2].length - 2), ignoreCase ? 'i' : '');\n          }\n        }\n      }\n\n      var err = parseArgs();\n\n      if (err) {\n        showConfirm(cm, err + ': ' + params.argString);\n        return;\n      }\n\n      var lineStart = params.line || cm.firstLine();\n      var lineEnd = params.lineEnd || params.line || cm.lastLine();\n\n      if (lineStart == lineEnd) {\n        return;\n      }\n\n      var curStart = Pos(lineStart, 0);\n      var curEnd = Pos(lineEnd, lineLength(cm, lineEnd));\n      var text = cm.getRange(curStart, curEnd).split('\\n');\n      var numberRegex = pattern ? pattern : number == 'decimal' ? /(-?)([\\d]+)/ : number == 'hex' ? /(-?)(?:0x)?([0-9a-f]+)/i : number == 'octal' ? /([0-7]+)/ : null;\n      var radix = number == 'decimal' ? 10 : number == 'hex' ? 16 : number == 'octal' ? 8 : null;\n      var numPart = [],\n          textPart = [];\n\n      if (number || pattern) {\n        for (var i = 0; i < text.length; i++) {\n          var matchPart = pattern ? text[i].match(pattern) : null;\n\n          if (matchPart && matchPart[0] != '') {\n            numPart.push(matchPart);\n          } else if (!pattern && numberRegex.exec(text[i])) {\n            numPart.push(text[i]);\n          } else {\n            textPart.push(text[i]);\n          }\n        }\n      } else {\n        textPart = text;\n      }\n\n      function compareFn(a, b) {\n        if (reverse) {\n          var tmp;\n          tmp = a;\n          a = b;\n          b = tmp;\n        }\n\n        if (ignoreCase) {\n          a = a.toLowerCase();\n          b = b.toLowerCase();\n        }\n\n        var anum = number && numberRegex.exec(a);\n        var bnum = number && numberRegex.exec(b);\n\n        if (!anum) {\n          return a < b ? -1 : 1;\n        }\n\n        anum = parseInt((anum[1] + anum[2]).toLowerCase(), radix);\n        bnum = parseInt((bnum[1] + bnum[2]).toLowerCase(), radix);\n        return anum - bnum;\n      }\n\n      function comparePatternFn(a, b) {\n        if (reverse) {\n          var tmp;\n          tmp = a;\n          a = b;\n          b = tmp;\n        }\n\n        if (ignoreCase) {\n          a[0] = a[0].toLowerCase();\n          b[0] = b[0].toLowerCase();\n        }\n\n        return a[0] < b[0] ? -1 : 1;\n      }\n\n      numPart.sort(pattern ? comparePatternFn : compareFn);\n\n      if (pattern) {\n        for (var i = 0; i < numPart.length; i++) {\n          numPart[i] = numPart[i].input;\n        }\n      } else if (!number) {\n        textPart.sort(compareFn);\n      }\n\n      text = !reverse ? textPart.concat(numPart) : numPart.concat(textPart);\n\n      if (unique) {\n        // Remove duplicate lines\n        var textOld = text;\n        var lastLine;\n        text = [];\n\n        for (var i = 0; i < textOld.length; i++) {\n          if (textOld[i] != lastLine) {\n            text.push(textOld[i]);\n          }\n\n          lastLine = textOld[i];\n        }\n      }\n\n      cm.replaceRange(text.join('\\n'), curStart, curEnd);\n    },\n    global: function (cm, params) {\n      var argString = params.argString;\n\n      if (!argString) {\n        showConfirm(cm, 'Regular Expression missing from global');\n        return;\n      }\n\n      var lineStart = params.line !== undefined ? params.line : cm.firstLine();\n      var lineEnd = params.lineEnd || params.line || cm.lastLine();\n      var tokens = splitBySlash(argString);\n      var regexPart = argString,\n          cmd;\n\n      if (tokens.length) {\n        regexPart = tokens[0];\n        cmd = tokens.slice(1, tokens.length).join('/');\n      }\n\n      if (regexPart) {\n        try {\n          updateSearchQuery(cm, regexPart, true\n          /** ignoreCase */\n          , true\n          /** smartCase */\n          );\n        } catch (e) {\n          showConfirm(cm, 'Invalid regex: ' + regexPart);\n          return;\n        }\n      }\n\n      var query = getSearchState(cm).getQuery();\n      var matchedLines = [],\n          content = '';\n\n      for (var i = lineStart; i <= lineEnd; i++) {\n        var matched = query.test(cm.getLine(i));\n\n        if (matched) {\n          matchedLines.push(i + 1);\n          content += cm.getLine(i) + '<br>';\n        }\n      }\n\n      if (!cmd) {\n        showConfirm(cm, content);\n        return;\n      }\n\n      var index = 0;\n\n      var nextCommand = function () {\n        if (index < matchedLines.length) {\n          var command = matchedLines[index] + cmd;\n          exCommandDispatcher.processCommand(cm, command, {\n            callback: nextCommand\n          });\n        }\n\n        index++;\n      };\n\n      nextCommand();\n    },\n    substitute: function (cm, params) {\n      if (!cm.getSearchCursor) {\n        throw new Error('Search feature not available. Requires searchcursor.js or ' + 'any other getSearchCursor implementation.');\n      }\n\n      var argString = params.argString;\n      var tokens = argString ? splitBySeparator(argString, argString[0]) : [];\n      var regexPart,\n          replacePart = '',\n          trailing,\n          flagsPart,\n          count;\n      var confirm = false; // Whether to confirm each replace.\n\n      var global = false; // True to replace all instances on a line, false to replace only 1.\n\n      if (tokens.length) {\n        regexPart = tokens[0];\n\n        if (getOption('pcre') && regexPart !== '') {\n          regexPart = new RegExp(regexPart).source; //normalize not escaped characters\n        }\n\n        replacePart = tokens[1];\n\n        if (regexPart && regexPart[regexPart.length - 1] === '$') {\n          regexPart = regexPart.slice(0, regexPart.length - 1) + '\\\\n';\n          replacePart = replacePart ? replacePart + '\\n' : '\\n';\n        }\n\n        if (replacePart !== undefined) {\n          if (getOption('pcre')) {\n            replacePart = unescapeRegexReplace(replacePart.replace(/([^\\\\])&/g, \"$1$$&\"));\n          } else {\n            replacePart = translateRegexReplace(replacePart);\n          }\n\n          vimGlobalState.lastSubstituteReplacePart = replacePart;\n        }\n\n        trailing = tokens[2] ? tokens[2].split(' ') : [];\n      } else {\n        if (argString && argString.length) {\n          showConfirm(cm, 'Substitutions should be of the form ' + ':s/pattern/replace/');\n          return;\n        }\n      }\n\n      if (trailing) {\n        flagsPart = trailing[0];\n        count = parseInt(trailing[1]);\n\n        if (flagsPart) {\n          if (flagsPart.indexOf('c') != -1) {\n            confirm = true;\n            flagsPart.replace('c', '');\n          }\n\n          if (flagsPart.indexOf('g') != -1) {\n            global = true;\n            flagsPart.replace('g', '');\n          }\n\n          if (getOption('pcre')) {\n            regexPart = regexPart + '/' + flagsPart;\n          } else {\n            regexPart = regexPart.replace(/\\//g, \"\\\\/\") + '/' + flagsPart;\n          }\n        }\n      }\n\n      if (regexPart) {\n        try {\n          updateSearchQuery(cm, regexPart, true\n          /** ignoreCase */\n          , true\n          /** smartCase */\n          );\n        } catch (e) {\n          showConfirm(cm, 'Invalid regex: ' + regexPart);\n          return;\n        }\n      }\n\n      replacePart = replacePart || vimGlobalState.lastSubstituteReplacePart;\n\n      if (replacePart === undefined) {\n        showConfirm(cm, 'No previous substitute regular expression');\n        return;\n      }\n\n      var state = getSearchState(cm);\n      var query = state.getQuery();\n      var lineStart = params.line !== undefined ? params.line : cm.getCursor().line;\n      var lineEnd = params.lineEnd || lineStart;\n\n      if (lineStart == cm.firstLine() && lineEnd == cm.lastLine()) {\n        lineEnd = Infinity;\n      }\n\n      if (count) {\n        lineStart = lineEnd;\n        lineEnd = lineStart + count - 1;\n      }\n\n      var startPos = clipCursorToContent(cm, Pos(lineStart, 0));\n      var cursor = cm.getSearchCursor(query, startPos);\n      doReplace(cm, confirm, global, lineStart, lineEnd, cursor, query, replacePart, params.callback);\n    },\n    redo: CodeMirror.commands.redo,\n    undo: CodeMirror.commands.undo,\n    write: function (cm) {\n      if (CodeMirror.commands.save) {\n        CodeMirror.commands.save(cm);\n      } else if (cm.save) {\n        cm.save();\n      }\n    },\n    nohlsearch: function (cm) {\n      clearSearchHighlight(cm);\n    },\n    yank: function (cm) {\n      var cur = copyCursor(cm.getCursor());\n      var line = cur.line;\n      var lineText = cm.getLine(line);\n      vimGlobalState.registerController.pushText('0', 'yank', lineText, true, true);\n    },\n    delmarks: function (cm, params) {\n      if (!params.argString || !trim(params.argString)) {\n        showConfirm(cm, 'Argument required');\n        return;\n      }\n\n      var state = cm.state.vim;\n      var stream = new CodeMirror.StringStream(trim(params.argString));\n\n      while (!stream.eol()) {\n        stream.eatSpace();\n        var count = stream.pos;\n\n        if (!stream.match(/[a-zA-Z]/, false)) {\n          showConfirm(cm, 'Invalid argument: ' + params.argString.substring(count));\n          return;\n        }\n\n        var sym = stream.next();\n\n        if (stream.match('-', true)) {\n          if (!stream.match(/[a-zA-Z]/, false)) {\n            showConfirm(cm, 'Invalid argument: ' + params.argString.substring(count));\n            return;\n          }\n\n          var startMark = sym;\n          var finishMark = stream.next();\n\n          if (isLowerCase(startMark) && isLowerCase(finishMark) || isUpperCase(startMark) && isUpperCase(finishMark)) {\n            var start = startMark.charCodeAt(0);\n            var finish = finishMark.charCodeAt(0);\n\n            if (start >= finish) {\n              showConfirm(cm, 'Invalid argument: ' + params.argString.substring(count));\n              return;\n            }\n\n            for (var j = 0; j <= finish - start; j++) {\n              var mark = String.fromCharCode(start + j);\n              delete state.marks[mark];\n            }\n          } else {\n            showConfirm(cm, 'Invalid argument: ' + startMark + '-');\n            return;\n          }\n        } else {\n          delete state.marks[sym];\n        }\n      }\n    }\n  };\n  var exCommandDispatcher = new ExCommandDispatcher();\n\n  function doReplace(cm, confirm, global, lineStart, lineEnd, searchCursor, query, replaceWith, callback) {\n    cm.state.vim.exMode = true;\n    var done = false;\n    var lastPos = searchCursor.from();\n\n    function replaceAll() {\n      cm.operation(function () {\n        while (!done) {\n          replace();\n          next();\n        }\n\n        stop();\n      });\n    }\n\n    function replace() {\n      var text = cm.getRange(searchCursor.from(), searchCursor.to());\n      var newText = text.replace(query, replaceWith);\n      searchCursor.replace(newText);\n    }\n\n    function next() {\n      while (searchCursor.findNext() && isInRange(searchCursor.from(), lineStart, lineEnd)) {\n        if (!global && lastPos && searchCursor.from().line == lastPos.line) {\n          continue;\n        }\n\n        cm.scrollIntoView(searchCursor.from(), 30);\n        cm.setSelection(searchCursor.from(), searchCursor.to());\n        lastPos = searchCursor.from();\n        done = false;\n        return;\n      }\n\n      done = true;\n    }\n\n    function stop(close) {\n      if (close) {\n        close();\n      }\n\n      cm.focus();\n\n      if (lastPos) {\n        cm.setCursor(lastPos);\n        var vim = cm.state.vim;\n        vim.exMode = false;\n        vim.lastHPos = vim.lastHSPos = lastPos.ch;\n      }\n\n      if (callback) {\n        callback();\n      }\n    }\n\n    function onPromptKeyDown(e, _value, close) {\n      CodeMirror.e_stop(e);\n      var keyName = CodeMirror.keyName(e);\n\n      switch (keyName) {\n        case 'Y':\n          replace();\n          next();\n          break;\n\n        case 'N':\n          next();\n          break;\n\n        case 'A':\n          var savedCallback = callback;\n          callback = undefined;\n          cm.operation(replaceAll);\n          callback = savedCallback;\n          break;\n\n        case 'L':\n          replace();\n\n        case 'Q':\n        case 'Esc':\n        case 'Ctrl-C':\n        case 'Ctrl-[':\n          stop(close);\n          break;\n      }\n\n      if (done) {\n        stop(close);\n      }\n\n      return true;\n    }\n\n    next();\n\n    if (done) {\n      showConfirm(cm, 'No matches for ' + query.source);\n      return;\n    }\n\n    if (!confirm) {\n      replaceAll();\n\n      if (callback) {\n        callback();\n      }\n\n      return;\n    }\n\n    showPrompt(cm, {\n      prefix: 'replace with <strong>' + replaceWith + '</strong> (y/n/a/q/l)',\n      onKeyDown: onPromptKeyDown\n    });\n  }\n\n  CodeMirror.keyMap.vim = {\n    attach: attachVimMap,\n    detach: detachVimMap,\n    call: cmKey\n  };\n\n  function exitInsertMode(cm) {\n    var vim = cm.state.vim;\n    var macroModeState = vimGlobalState.macroModeState;\n    var insertModeChangeRegister = vimGlobalState.registerController.getRegister('.');\n    var isPlaying = macroModeState.isPlaying;\n    var lastChange = macroModeState.lastInsertModeChanges;\n\n    if (!isPlaying) {\n      cm.off('change', onChange);\n      CodeMirror.off(cm.getInputField(), 'keydown', onKeyEventTargetKeyDown);\n    }\n\n    if (!isPlaying && vim.insertModeRepeat > 1) {\n      repeatLastEdit(cm, vim, vim.insertModeRepeat - 1, true\n      /** repeatForInsert */\n      );\n      vim.lastEditInputState.repeatOverride = vim.insertModeRepeat;\n    }\n\n    delete vim.insertModeRepeat;\n    vim.insertMode = false;\n    cm.setCursor(cm.getCursor().line, cm.getCursor().ch - 1);\n    cm.setOption('keyMap', 'vim');\n    cm.setOption('disableInput', true);\n    cm.toggleOverwrite(false); // exit replace mode if we were in it.\n\n    insertModeChangeRegister.setText(lastChange.changes.join(''));\n    CodeMirror.signal(cm, \"vim-mode-change\", {\n      mode: \"normal\"\n    });\n\n    if (macroModeState.isRecording) {\n      logInsertModeChange(macroModeState);\n    }\n  }\n\n  function _mapCommand(command) {\n    defaultKeymap.unshift(command);\n  }\n\n  function mapCommand(keys, type, name, args, extra) {\n    var command = {\n      keys: keys,\n      type: type\n    };\n    command[type] = name;\n    command[type + \"Args\"] = args;\n\n    for (var key in extra) command[key] = extra[key];\n\n    _mapCommand(command);\n  }\n\n  defineOption('insertModeEscKeysTimeout', 200, 'number');\n  CodeMirror.keyMap['vim-insert'] = {\n    fallthrough: ['default'],\n    attach: attachVimMap,\n    detach: detachVimMap,\n    call: cmKey\n  };\n  CodeMirror.keyMap['vim-replace'] = {\n    'Backspace': 'goCharLeft',\n    fallthrough: ['vim-insert'],\n    attach: attachVimMap,\n    detach: detachVimMap,\n    call: cmKey\n  };\n\n  function executeMacroRegister(cm, vim, macroModeState, registerName) {\n    var register = vimGlobalState.registerController.getRegister(registerName);\n\n    if (registerName == ':') {\n      if (register.keyBuffer[0]) {\n        exCommandDispatcher.processCommand(cm, register.keyBuffer[0]);\n      }\n\n      macroModeState.isPlaying = false;\n      return;\n    }\n\n    var keyBuffer = register.keyBuffer;\n    var imc = 0;\n    macroModeState.isPlaying = true;\n    macroModeState.replaySearchQueries = register.searchQueries.slice(0);\n\n    for (var i = 0; i < keyBuffer.length; i++) {\n      var text = keyBuffer[i];\n      var match, key;\n\n      while (text) {\n        match = /<\\w+-.+?>|<\\w+>|./.exec(text);\n        key = match[0];\n        text = text.substring(match.index + key.length);\n        CodeMirror.Vim.handleKey(cm, key, 'macro');\n\n        if (vim.insertMode) {\n          var changes = register.insertModeChanges[imc++].changes;\n          vimGlobalState.macroModeState.lastInsertModeChanges.changes = changes;\n          repeatInsertModeChanges(cm, changes, 1);\n          exitInsertMode(cm);\n        }\n      }\n    }\n\n    macroModeState.isPlaying = false;\n  }\n\n  function logKey(macroModeState, key) {\n    if (macroModeState.isPlaying) {\n      return;\n    }\n\n    var registerName = macroModeState.latestRegister;\n    var register = vimGlobalState.registerController.getRegister(registerName);\n\n    if (register) {\n      register.pushText(key);\n    }\n  }\n\n  function logInsertModeChange(macroModeState) {\n    if (macroModeState.isPlaying) {\n      return;\n    }\n\n    var registerName = macroModeState.latestRegister;\n    var register = vimGlobalState.registerController.getRegister(registerName);\n\n    if (register && register.pushInsertModeChanges) {\n      register.pushInsertModeChanges(macroModeState.lastInsertModeChanges);\n    }\n  }\n\n  function logSearchQuery(macroModeState, query) {\n    if (macroModeState.isPlaying) {\n      return;\n    }\n\n    var registerName = macroModeState.latestRegister;\n    var register = vimGlobalState.registerController.getRegister(registerName);\n\n    if (register && register.pushSearchQuery) {\n      register.pushSearchQuery(query);\n    }\n  }\n\n  function onChange(cm, changeObj) {\n    var macroModeState = vimGlobalState.macroModeState;\n    var lastChange = macroModeState.lastInsertModeChanges;\n\n    if (!macroModeState.isPlaying) {\n      while (changeObj) {\n        lastChange.expectCursorActivityForChange = true;\n\n        if (lastChange.ignoreCount > 1) {\n          lastChange.ignoreCount--;\n        } else if (changeObj.origin == '+input' || changeObj.origin == 'paste' || changeObj.origin === undefined\n        /* only in testing */\n        ) {\n            var selectionCount = cm.listSelections().length;\n            if (selectionCount > 1) lastChange.ignoreCount = selectionCount;\n            var text = changeObj.text.join('\\n');\n\n            if (lastChange.maybeReset) {\n              lastChange.changes = [];\n              lastChange.maybeReset = false;\n            }\n\n            if (text) {\n              if (cm.state.overwrite && !/\\n/.test(text)) {\n                lastChange.changes.push([text]);\n              } else {\n                lastChange.changes.push(text);\n              }\n            }\n          }\n\n        changeObj = changeObj.next;\n      }\n    }\n  }\n\n  function onCursorActivity(cm) {\n    var vim = cm.state.vim;\n\n    if (vim.insertMode) {\n      var macroModeState = vimGlobalState.macroModeState;\n\n      if (macroModeState.isPlaying) {\n        return;\n      }\n\n      var lastChange = macroModeState.lastInsertModeChanges;\n\n      if (lastChange.expectCursorActivityForChange) {\n        lastChange.expectCursorActivityForChange = false;\n      } else {\n        lastChange.maybeReset = true;\n      }\n    } else if (!cm.curOp.isVimOp) {\n      handleExternalSelection(cm, vim);\n    }\n\n    if (vim.visualMode) {\n      updateFakeCursor(cm);\n    }\n  }\n\n  function updateFakeCursor(cm) {\n    var vim = cm.state.vim;\n    var from = clipCursorToContent(cm, copyCursor(vim.sel.head));\n    var to = offsetCursor(from, 0, 1);\n\n    if (vim.fakeCursor) {\n      vim.fakeCursor.clear();\n    }\n\n    vim.fakeCursor = cm.markText(from, to, {\n      className: 'cm-animate-fat-cursor'\n    });\n  }\n\n  function handleExternalSelection(cm, vim, keepHPos) {\n    var anchor = cm.getCursor('anchor');\n    var head = cm.getCursor('head');\n\n    if (vim.visualMode && !cm.somethingSelected()) {\n      exitVisualMode(cm, false);\n    } else if (!vim.visualMode && !vim.insertMode && cm.somethingSelected()) {\n      vim.visualMode = true;\n      vim.visualLine = false;\n      CodeMirror.signal(cm, \"vim-mode-change\", {\n        mode: \"visual\"\n      });\n    }\n\n    if (vim.visualMode) {\n      var headOffset = !cursorIsBefore(head, anchor) ? -1 : 0;\n      var anchorOffset = cursorIsBefore(head, anchor) ? -1 : 0;\n      head = offsetCursor(head, 0, headOffset);\n      anchor = offsetCursor(anchor, 0, anchorOffset);\n      vim.sel = {\n        anchor: anchor,\n        head: head\n      };\n      updateMark(cm, vim, '<', cursorMin(head, anchor));\n      updateMark(cm, vim, '>', cursorMax(head, anchor));\n    } else if (!vim.insertMode && !keepHPos) {\n      vim.lastHPos = cm.getCursor().ch;\n    }\n  }\n\n  function InsertModeKey(keyName) {\n    this.keyName = keyName;\n  }\n\n  function onKeyEventTargetKeyDown(e) {\n    var macroModeState = vimGlobalState.macroModeState;\n    var lastChange = macroModeState.lastInsertModeChanges;\n    var keyName = CodeMirror.keyName(e);\n\n    if (!keyName) {\n      return;\n    }\n\n    function onKeyFound() {\n      if (lastChange.maybeReset) {\n        lastChange.changes = [];\n        lastChange.maybeReset = false;\n      }\n\n      lastChange.changes.push(new InsertModeKey(keyName));\n      return true;\n    }\n\n    if (keyName.indexOf('Delete') != -1 || keyName.indexOf('Backspace') != -1) {\n      CodeMirror.lookupKey(keyName, 'vim-insert', onKeyFound);\n    }\n  }\n\n  function repeatLastEdit(cm, vim, repeat, repeatForInsert) {\n    var macroModeState = vimGlobalState.macroModeState;\n    macroModeState.isPlaying = true;\n    var isAction = !!vim.lastEditActionCommand;\n    var cachedInputState = vim.inputState;\n\n    function repeatCommand() {\n      if (isAction) {\n        commandDispatcher.processAction(cm, vim, vim.lastEditActionCommand);\n      } else {\n        commandDispatcher.evalInput(cm, vim);\n      }\n    }\n\n    function repeatInsert(repeat) {\n      if (macroModeState.lastInsertModeChanges.changes.length > 0) {\n        repeat = !vim.lastEditActionCommand ? 1 : repeat;\n        var changeObject = macroModeState.lastInsertModeChanges;\n        repeatInsertModeChanges(cm, changeObject.changes, repeat);\n      }\n    }\n\n    vim.inputState = vim.lastEditInputState;\n\n    if (isAction && vim.lastEditActionCommand.interlaceInsertRepeat) {\n      for (var i = 0; i < repeat; i++) {\n        repeatCommand();\n        repeatInsert(1);\n      }\n    } else {\n      if (!repeatForInsert) {\n        repeatCommand();\n      }\n\n      repeatInsert(repeat);\n    }\n\n    vim.inputState = cachedInputState;\n\n    if (vim.insertMode && !repeatForInsert) {\n      exitInsertMode(cm);\n    }\n\n    macroModeState.isPlaying = false;\n  }\n\n  function repeatInsertModeChanges(cm, changes, repeat) {\n    function keyHandler(binding) {\n      if (typeof binding == 'string') {\n        CodeMirror.commands[binding](cm);\n      } else {\n        binding(cm);\n      }\n\n      return true;\n    }\n\n    var head = cm.getCursor('head');\n    var visualBlock = vimGlobalState.macroModeState.lastInsertModeChanges.visualBlock;\n\n    if (visualBlock) {\n      selectForInsert(cm, head, visualBlock + 1);\n      repeat = cm.listSelections().length;\n      cm.setCursor(head);\n    }\n\n    for (var i = 0; i < repeat; i++) {\n      if (visualBlock) {\n        cm.setCursor(offsetCursor(head, i, 0));\n      }\n\n      for (var j = 0; j < changes.length; j++) {\n        var change = changes[j];\n\n        if (change instanceof InsertModeKey) {\n          CodeMirror.lookupKey(change.keyName, 'vim-insert', keyHandler);\n        } else if (typeof change == \"string\") {\n          var cur = cm.getCursor();\n          cm.replaceRange(change, cur, cur);\n        } else {\n          var start = cm.getCursor();\n          var end = offsetCursor(start, 0, change[0].length);\n          cm.replaceRange(change[0], start, end);\n        }\n      }\n    }\n\n    if (visualBlock) {\n      cm.setCursor(offsetCursor(head, 0, 1));\n    }\n  }\n\n  resetVimGlobalState();\n  CodeMirror.Vim = Vim();\n  Vim = CodeMirror.Vim;\n  var specialKey = {\n    'return': 'CR',\n    backspace: 'BS',\n    'delete': 'Del',\n    esc: 'Esc',\n    left: 'Left',\n    right: 'Right',\n    up: 'Up',\n    down: 'Down',\n    space: 'Space',\n    home: 'Home',\n    end: 'End',\n    pageup: 'PageUp',\n    pagedown: 'PageDown',\n    enter: 'CR'\n  };\n\n  function lookupKey(hashId, key, e) {\n    if (key.length > 1 && key[0] == \"n\") {\n      key = key.replace(\"numpad\", \"\");\n    }\n\n    key = specialKey[key] || key;\n    var name = '';\n\n    if (e.ctrlKey) {\n      name += 'C-';\n    }\n\n    if (e.altKey) {\n      name += 'A-';\n    }\n\n    if ((name || key.length > 1) && e.shiftKey) {\n      name += 'S-';\n    }\n\n    name += key;\n\n    if (name.length > 1) {\n      name = '<' + name + '>';\n    }\n\n    return name;\n  }\n\n  var handleKey = Vim.handleKey.bind(Vim);\n\n  Vim.handleKey = function (cm, key, origin) {\n    return cm.operation(function () {\n      return handleKey(cm, key, origin);\n    }, true);\n  };\n\n  function cloneVimState(state) {\n    var n = new state.constructor();\n    Object.keys(state).forEach(function (key) {\n      var o = state[key];\n      if (Array.isArray(o)) o = o.slice();else if (o && typeof o == \"object\" && o.constructor != Object) o = cloneVimState(o);\n      n[key] = o;\n    });\n\n    if (state.sel) {\n      n.sel = {\n        head: state.sel.head && copyCursor(state.sel.head),\n        anchor: state.sel.anchor && copyCursor(state.sel.anchor)\n      };\n    }\n\n    return n;\n  }\n\n  function multiSelectHandleKey(cm, key, origin) {\n    var isHandled = false;\n    var vim = Vim.maybeInitVimState_(cm);\n    var visualBlock = vim.visualBlock || vim.wasInVisualBlock;\n    var wasMultiselect = cm.ace.inMultiSelectMode;\n\n    if (vim.wasInVisualBlock && !wasMultiselect) {\n      vim.wasInVisualBlock = false;\n    } else if (wasMultiselect && vim.visualBlock) {\n      vim.wasInVisualBlock = true;\n    }\n\n    if (key == '<Esc>' && !vim.insertMode && !vim.visualMode && wasMultiselect) {\n      cm.ace.exitMultiSelectMode();\n    } else if (visualBlock || !wasMultiselect || cm.ace.inVirtualSelectionMode) {\n      isHandled = Vim.handleKey(cm, key, origin);\n    } else {\n      var old = cloneVimState(vim);\n      cm.operation(function () {\n        cm.ace.forEachSelection(function () {\n          var sel = cm.ace.selection;\n          cm.state.vim.lastHPos = sel.$desiredColumn == null ? sel.lead.column : sel.$desiredColumn;\n          var head = cm.getCursor(\"head\");\n          var anchor = cm.getCursor(\"anchor\");\n          var headOffset = !cursorIsBefore(head, anchor) ? -1 : 0;\n          var anchorOffset = cursorIsBefore(head, anchor) ? -1 : 0;\n          head = offsetCursor(head, 0, headOffset);\n          anchor = offsetCursor(anchor, 0, anchorOffset);\n          cm.state.vim.sel.head = head;\n          cm.state.vim.sel.anchor = anchor;\n          isHandled = handleKey(cm, key, origin);\n          sel.$desiredColumn = cm.state.vim.lastHPos == -1 ? null : cm.state.vim.lastHPos;\n\n          if (cm.virtualSelectionMode()) {\n            cm.state.vim = cloneVimState(old);\n          }\n        });\n        if (cm.curOp.cursorActivity && !isHandled) cm.curOp.cursorActivity = false;\n      }, true);\n    }\n\n    if (isHandled && !vim.visualMode && !vim.insert && vim.visualMode != cm.somethingSelected()) {\n      handleExternalSelection(cm, vim, true);\n    }\n\n    return isHandled;\n  }\n\n  exports.CodeMirror = CodeMirror;\n  var getVim = Vim.maybeInitVimState_;\n  exports.handler = {\n    $id: \"ace/keyboard/vim\",\n    drawCursor: function (element, pixelPos, config, sel, session) {\n      var vim = this.state.vim || {};\n      var w = config.characterWidth;\n      var h = config.lineHeight;\n      var top = pixelPos.top;\n      var left = pixelPos.left;\n\n      if (!vim.insertMode) {\n        var isbackwards = !sel.cursor ? session.selection.isBackwards() || session.selection.isEmpty() : Range.comparePoints(sel.cursor, sel.start) <= 0;\n        if (!isbackwards && left > w) left -= w;\n      }\n\n      if (!vim.insertMode && vim.status) {\n        h = h / 2;\n        top += h;\n      }\n\n      dom.translate(element, left, top);\n      dom.setStyle(element.style, \"width\", w + \"px\");\n      dom.setStyle(element.style, \"height\", h + \"px\");\n    },\n    handleKeyboard: function (data, hashId, key, keyCode, e) {\n      var editor = data.editor;\n      var cm = editor.state.cm;\n      var vim = getVim(cm);\n      if (keyCode == -1) return;\n\n      if (!vim.insertMode) {\n        if (hashId == -1) {\n          if (key.charCodeAt(0) > 0xFF) {\n            if (data.inputKey) {\n              key = data.inputKey;\n              if (key && data.inputHash == 4) key = key.toUpperCase();\n            }\n          }\n\n          data.inputChar = key;\n        } else if (hashId == 4 || hashId == 0) {\n          if (data.inputKey == key && data.inputHash == hashId && data.inputChar) {\n            key = data.inputChar;\n            hashId = -1;\n          } else {\n            data.inputChar = null;\n            data.inputKey = key;\n            data.inputHash = hashId;\n          }\n        } else {\n          data.inputChar = data.inputKey = null;\n        }\n      }\n\n      if (key == \"c\" && hashId == 1) {\n        // key == \"ctrl-c\"\n        if (!useragent.isMac && editor.getCopyText()) {\n          editor.once(\"copy\", function () {\n            editor.selection.clearSelection();\n          });\n          return {\n            command: \"null\",\n            passEvent: true\n          };\n        }\n      }\n\n      if (key == \"esc\" && !vim.insertMode && !vim.visualMode && !cm.ace.inMultiSelectMode) {\n        var searchState = getSearchState(cm);\n        var overlay = searchState.getOverlay();\n        if (overlay) cm.removeOverlay(overlay);\n      }\n\n      if (hashId == -1 || hashId & 1 || hashId === 0 && key.length > 1) {\n        var insertMode = vim.insertMode;\n        var name = lookupKey(hashId, key, e || {});\n        if (vim.status == null) vim.status = \"\";\n        var isHandled = multiSelectHandleKey(cm, name, 'user');\n        vim = getVim(cm); // may be changed by multiSelectHandleKey\n\n        if (isHandled && vim.status != null) vim.status += name;else if (vim.status == null) vim.status = \"\";\n\n        cm._signal(\"changeStatus\");\n\n        if (!isHandled && (hashId != -1 || insertMode)) return;\n        return {\n          command: \"null\",\n          passEvent: !isHandled\n        };\n      }\n    },\n    attach: function (editor) {\n      if (!editor.state) editor.state = {};\n      var cm = new CodeMirror(editor);\n      editor.state.cm = cm;\n      editor.$vimModeHandler = this;\n      CodeMirror.keyMap.vim.attach(cm);\n      getVim(cm).status = null;\n      cm.on('vim-command-done', function () {\n        if (cm.virtualSelectionMode()) return;\n        getVim(cm).status = null;\n\n        cm.ace._signal(\"changeStatus\");\n\n        cm.ace.session.markUndoGroup();\n      });\n      cm.on(\"changeStatus\", function () {\n        cm.ace.renderer.updateCursor();\n\n        cm.ace._signal(\"changeStatus\");\n      });\n      cm.on(\"vim-mode-change\", function () {\n        if (cm.virtualSelectionMode()) return;\n        updateInputMode();\n\n        cm._signal(\"changeStatus\");\n      });\n\n      function updateInputMode() {\n        var isIntsert = getVim(cm).insertMode;\n        cm.ace.renderer.setStyle(\"normal-mode\", !isIntsert);\n        editor.textInput.setCommandMode(!isIntsert);\n        editor.renderer.$keepTextAreaAtCursor = isIntsert;\n        editor.renderer.$blockCursor = !isIntsert;\n      }\n\n      updateInputMode();\n      editor.renderer.$cursorLayer.drawCursor = this.drawCursor.bind(cm);\n    },\n    detach: function (editor) {\n      var cm = editor.state.cm;\n      CodeMirror.keyMap.vim.detach(cm);\n      cm.destroy();\n      editor.state.cm = null;\n      editor.$vimModeHandler = null;\n      editor.renderer.$cursorLayer.drawCursor = null;\n      editor.renderer.setStyle(\"normal-mode\", false);\n      editor.textInput.setCommandMode(false);\n      editor.renderer.$keepTextAreaAtCursor = true;\n    },\n    getStatusText: function (editor) {\n      var cm = editor.state.cm;\n      var vim = getVim(cm);\n      if (vim.insertMode) return \"INSERT\";\n      var status = \"\";\n\n      if (vim.visualMode) {\n        status += \"VISUAL\";\n        if (vim.visualLine) status += \" LINE\";\n        if (vim.visualBlock) status += \" BLOCK\";\n      }\n\n      if (vim.status) status += (status ? \" \" : \"\") + vim.status;\n      return status;\n    }\n  };\n  Vim.defineOption({\n    name: \"wrap\",\n    set: function (value, cm) {\n      if (cm) {\n        cm.ace.setOption(\"wrap\", value);\n      }\n    },\n    type: \"boolean\"\n  }, false);\n  Vim.defineEx('write', 'w', function () {\n    console.log(':write is not implemented');\n  });\n  defaultKeymap.push({\n    keys: 'zc',\n    type: 'action',\n    action: 'fold',\n    actionArgs: {\n      open: false\n    }\n  }, {\n    keys: 'zC',\n    type: 'action',\n    action: 'fold',\n    actionArgs: {\n      open: false,\n      all: true\n    }\n  }, {\n    keys: 'zo',\n    type: 'action',\n    action: 'fold',\n    actionArgs: {\n      open: true\n    }\n  }, {\n    keys: 'zO',\n    type: 'action',\n    action: 'fold',\n    actionArgs: {\n      open: true,\n      all: true\n    }\n  }, {\n    keys: 'za',\n    type: 'action',\n    action: 'fold',\n    actionArgs: {\n      toggle: true\n    }\n  }, {\n    keys: 'zA',\n    type: 'action',\n    action: 'fold',\n    actionArgs: {\n      toggle: true,\n      all: true\n    }\n  }, {\n    keys: 'zf',\n    type: 'action',\n    action: 'fold',\n    actionArgs: {\n      open: true,\n      all: true\n    }\n  }, {\n    keys: 'zd',\n    type: 'action',\n    action: 'fold',\n    actionArgs: {\n      open: true,\n      all: true\n    }\n  }, {\n    keys: '<C-A-k>',\n    type: 'action',\n    action: 'aceCommand',\n    actionArgs: {\n      name: \"addCursorAbove\"\n    }\n  }, {\n    keys: '<C-A-j>',\n    type: 'action',\n    action: 'aceCommand',\n    actionArgs: {\n      name: \"addCursorBelow\"\n    }\n  }, {\n    keys: '<C-A-S-k>',\n    type: 'action',\n    action: 'aceCommand',\n    actionArgs: {\n      name: \"addCursorAboveSkipCurrent\"\n    }\n  }, {\n    keys: '<C-A-S-j>',\n    type: 'action',\n    action: 'aceCommand',\n    actionArgs: {\n      name: \"addCursorBelowSkipCurrent\"\n    }\n  }, {\n    keys: '<C-A-h>',\n    type: 'action',\n    action: 'aceCommand',\n    actionArgs: {\n      name: \"selectMoreBefore\"\n    }\n  }, {\n    keys: '<C-A-l>',\n    type: 'action',\n    action: 'aceCommand',\n    actionArgs: {\n      name: \"selectMoreAfter\"\n    }\n  }, {\n    keys: '<C-A-S-h>',\n    type: 'action',\n    action: 'aceCommand',\n    actionArgs: {\n      name: \"selectNextBefore\"\n    }\n  }, {\n    keys: '<C-A-S-l>',\n    type: 'action',\n    action: 'aceCommand',\n    actionArgs: {\n      name: \"selectNextAfter\"\n    }\n  });\n\n  actions.aceCommand = function (cm, actionArgs, vim) {\n    cm.vimCmd = actionArgs;\n    if (cm.ace.inVirtualSelectionMode) cm.ace.on(\"beforeEndOperation\", delayedExecAceCommand);else delayedExecAceCommand(null, cm.ace);\n  };\n\n  function delayedExecAceCommand(op, ace) {\n    ace.off(\"beforeEndOperation\", delayedExecAceCommand);\n    var cmd = ace.state.cm.vimCmd;\n\n    if (cmd) {\n      ace.execCommand(cmd.exec ? cmd : cmd.name, cmd.args);\n    }\n\n    ace.curOp = ace.prevOp;\n  }\n\n  actions.fold = function (cm, actionArgs, vim) {\n    cm.ace.execCommand(['toggleFoldWidget', 'toggleFoldWidget', 'foldOther', 'unfoldall'][(actionArgs.all ? 2 : 0) + (actionArgs.open ? 1 : 0)]);\n  };\n\n  exports.handler.defaultKeymap = defaultKeymap;\n  exports.handler.actions = actions;\n  exports.Vim = Vim;\n});\n\n(function () {\n  ace.require([\"ace/keyboard/vim\"], function (m) {\n    if (typeof module == \"object\" && typeof exports == \"object\" && module) {\n      module.exports = m;\n    }\n  });\n})();","map":{"version":3,"sources":["/home/magoo/projects/keyrier-json/node_modules/ace-builds/src-noconflict/keybinding-vim.js"],"names":["ace","define","require","exports","module","log","d","format","p","line","ch","anchor","head","Array","isArray","map","x","JSON","stringify","i","arguments","length","f","console","Range","EventEmitter","dom","oop","KEYS","event","Search","useragent","SearchHighlight","multiSelectCommands","TextModeTokenRe","Mode","prototype","tokenRe","CodeMirror","state","marks","$uid","onChange","bind","onSelectionChange","onBeforeEndOperation","on","Pos","defineOption","name","val","setter","commands","redo","cm","undo","newlineAndIndent","insert","keyMap","addClass","rmClass","e_stop","e_preventDefault","stopEvent","keyName","e","key","keyCode","toUpperCase","getModifierString","replace","m","cmd","commandKeyBinding","toLowerCase","execCommand","lookupKey","handle","found","fallthrough","result","signal","o","_signal","addListener","off","removeListener","isWordChar","test","lastIndex","implement","destroy","removeOverlay","virtualSelectionMode","inVirtualSelectionMode","selection","index","delta","change","text","action","lines","curOp","changeHandlers","_eventRegistry","slice","lastChange","next","$updateMarkers","cursorActivityHandlers","cursorActivity","inMultiSelectMode","keyBinding","removeKeyboardHandler","keyboardHandler","operation","fn","force","prevOp","startOperation","command","scrollIntoView","dialog","endOperation","op","eventName","handlers","listeners","firstLine","lastLine","session","getLength","lineCount","setCursor","exitMultiSelectMode","unfold","row","column","moveTo","getCursor","sel","pos","isEmpty","lead","getRange","toCmPos","listSelections","ranges","multiSelect","rangeList","r","clipPos","cursor","end","start","setSelections","primIndex","toAcePos","comparePoints","fromPoints","fromOrientedRange","reverse","push","splice","toSingleRange","clone","range","$clipRangeToDocument","addRange","setSelection","a","h","options","selectTo","origin","somethingSelected","$clipPositionToDocument","markText","clear","find","isInsert","rowShift","colShift","point","cmp","bias","cmp2","Marker","id","setBookmark","bm","insertLeft","$insertRight","moveH","increment","unit","clearSelection","moveCursorBy","findPosV","amount","goalColumn","renderer","config","layerConfig","Math","floor","height","lineHeight","screenPos","documentToScreenPosition","min","max","getScreenLength","screenToDocumentPosition","charCoords","mode","sc","left","top","lh","cw","characterWidth","bottom","coordsChar","col","getSearchCursor","query","caseFold","caseSensitive","isRegexp","RegExp","global","ignoreCase","source","search","undefined","Number","MAX_VALUE","acePos","last","findNext","findPrevious","back","setOptions","needle","wrap","backwards","regExp","getLine","$options","from","to","doc","scrollTo","y","maxHeight","$size","scrollerHeight","$scrollPastEnd","setScrollTop","setScrollLeft","width","scrollInfo","margin","viewMargin","scrollCursorIntoView","s","getTextRange","replaceRange","replaceSelection","replaceSelections","getSelection","getSelectedText","getSelections","getInputField","textInput","getElement","getWrapperElement","container","optMap","indentWithTabs","indentUnit","tabSize","firstLineNumber","readOnly","setOption","$keyMap","getOption","aceOpt","toggleOverwrite","overwrite","setOverwrite","addOverlay","$searchHighlight","highlight","marker","addDynamicMarker","updateOnChange","removeMarker","cache","re","setRegexp","updateBackMarkers","getScrollInfo","scrollLeft","scrollTop","clientHeight","clientWidth","getValue","setValue","v","getTokenTypeAt","token","getTokenAt","type","findMatchingBracket","indentLine","method","indentRows","outdentRows","indexFromPos","positionToIndex","posFromIndex","indexToPosition","focus","blur","defaultTextHeight","scanForBracket","dir","_","bracketRegex","$findClosingBracket","$findOpeningBracket","refresh","resize","getMode","call","cmPos","StringStream","string","lastColumnPos","lastColumnValue","lineStart","eol","sol","peek","charAt","eat","match","ok","eatWhile","eatSpace","skipToEnd","skipTo","indexOf","backUp","n","indentation","pattern","consume","caseInsensitive","cased","str","substr","current","hideFirstChars","inner","defineExtension","importCssString","dialogDiv","template","appendChild","document","createElement","className","innerHTML","closeNotification","newVal","currentNotificationClose","callback","closed","me","close","inp","value","activeElement","parentNode","removeChild","onClose","getElementsByTagName","button","selectValueOnOpen","select","onInput","onKeyUp","onKeyDown","closeOnEnter","closeOnBlur","doneTimer","duration","clearTimeout","setTimeout","defaultKeymap","keys","toKeys","context","motion","motionArgs","linewise","toJumplist","forward","wordEnd","bigWord","inclusive","explicitRepeat","toFirstChar","repeatOffset","isEdit","actionArgs","after","matchIndent","sameLine","operator","operatorArgs","indentRight","toLower","operatorMotionArgs","visualLine","shouldMoveCursor","insertAt","interlaceInsertRepeat","blockwise","keepSpaces","fullLine","exitVisualBlock","position","increase","backtrack","textObjectInner","searchArgs","querySrc","wholeWordOnly","defaultKeymapLength","defaultExCommandMap","shortName","possiblyAsync","excludeFromCommandHistory","Vim","vimApi","enterVimMode","onCursorActivity","maybeInitVimState","getOnPasteFn","leaveVimMode","vim","detachVimMap","attach","attachVimMap","prev","Init","cmKey","vimKey","cmKeyToVimKey","findKey","modifiers","specialKeys","Enter","Backspace","Delete","Insert","pieces","split","lastPiece","hasCharacter","piece","isUpperCase","join","onPasteFn","insertMode","offsetCursor","actions","enterInsertMode","numberRegex","wordCharTest","bigWordCharTest","makeKeyRange","size","String","fromCharCode","upperCaseAlphabet","lowerCaseAlphabet","numbers","validMarks","concat","validRegisters","isLine","isLowerCase","k","isMatchableSymbol","isNumber","isWhiteSpaceString","isEndOfSentenceSymbol","inArray","arr","defaultValue","aliases","Error","cfg","option","scope","local","createCircularJumpList","pointer","tail","buffer","add","oldCur","newCur","curMark","useNextSlot","trashMark","markPos","cursorEqual","move","offset","mark","inc","oldPointer","cachedCursor","createInsertModeChanges","c","changes","expectCursorActivityForChange","MacroModeState","latestRegister","isPlaying","isRecording","replaySearchQueries","onRecordingDone","lastInsertModeChanges","exitMacroRecordMode","macroModeState","vimGlobalState","enterMacroRecordMode","registerName","register","registerController","getRegister","openDialog","inputState","InputState","lastEditInputState","lastEditActionCommand","lastHPos","lastHSPos","lastMotion","fakeCursor","insertModeRepeat","visualMode","visualBlock","lastSelection","lastPastedText","resetVimGlobalState","searchQuery","searchIsReversed","lastSubstituteReplacePart","jumpList","lastCharacterSearch","selectedCharacter","RegisterController","searchHistoryController","HistoryController","exCommandHistoryController","optionName","lastInsertModeKeyTimer","buildKeyMap","getRegisterController","resetVimGlobalState_","getVimGlobalState_","maybeInitVimState_","suppressErrorLogging","InsertModeKey","lhs","rhs","ctx","exCommandDispatcher","unmap","noremap","toCtxArray","ctxsToMap","actualLength","origLength","mapping","newMapping","_mapCommand","mappedCtxs","filter","el","mapclear","userKeymap","contexts","j","defineEx","prefix","func","exCommands","commandMap_","handleKey","handleMacroRecording","clearInputState","logKey","handleEsc","exitVisualMode","exitInsertMode","doKeyToKey","exec","substring","handleKeyInsertMode","keyBuffer","keysAreChars","commandDispatcher","matchCommand","thisMatch","window","selections","here","pop","handleKeyNonInsertMode","keysMatcher","pushRepeatDigit","isVimOp","processCommand","handleEx","input","defineMotion","defineAction","defineOperator","mapCommand","defineRegister","prefixRepeat","motionRepeat","getRepeat","repeat","parseInt","reason","Register","insertModeChanges","searchQueries","setText","pushText","pushInsertModeChanges","pushSearchQuery","toString","registers","unnamedRegister","isValidRegister","shiftNumericRegisters_","append","historyBuffer","iterator","initialPrefix","nextMatch","up","element","pushInput","reset","matches","commandMatches","full","partial","bestMatch","character","lastChar","repeatOverride","processMotion","processOperator","processOperatorMotion","processAction","processSearch","processEx","copyArgs","evalInput","updateCmSelection","repeatIsExplicit","recordLastEdit","getSearchState","setReversed","promptPrefix","originalQuery","getQuery","originalScrollPos","handleQuery","smartCase","updateSearchQuery","showConfirm","onPromptClose","logSearchQuery","onPromptKeyUp","target","selectionEnd","selectionStart","parsedQuery","clearSearchHighlight","onPromptKeyDown","shift","showPrompt","desc","searchPromptDesc","word","expandWordUnderCursor","isKeyword","escapeRegex","exArgs","origHead","copyCursor","clipCursorToContent","origAnchor","oldHead","oldAnchor","newHead","newAnchor","noRepeat","motionResult","motions","recordJumpPosition","Infinity","updateMark","cursorIsBefore","lastSel","lineOffset","abs","chOffset","curStart","curEnd","cmSel","cursorMin","cursorMax","makeCmSelection","lineLength","tmp","expandSelectionToLine","clipToLine","exclusive","primary","operatorMoveTo","operators","actionCommand","moveToTopLine","_head","getUserVisibleLines","findFirstNonWhiteSpaceCharacter","moveToMiddleLine","moveToBottomLine","expandToLine","_cm","cur","isReversed","highlightSearchMatches","goToMark","getMarkPos","moveToOtherHighlightedEnd","jumpToMark","best","isWrongDirection","equal","between","cursorIsBetween","moveByCharacters","moveByLines","endCh","moveByDisplayLines","moveByScroll","moveToColumn","moveToEol","first","moveToStartOfLine","fold","getFoldLine","res","hitSide","lastCharCoords","goalCoords","resCoords","moveByPage","moveByParagraph","findParagraph","moveBySentence","findSentence","scrollbox","orig","dest","moveByWords","moveToWord","moveTillCharacter","moveToCharacter","recordLastCharacterSearch","moveToSymbol","findSymbol","keepHPos","retval","moveToFirstNonWhiteSpaceCharacter","moveToMatchedSymbol","lineText","symbol","style","matched","moveToLineOrEdgeOfDocument","lineNum","textObjectManipulation","mirroredPairs","selfPaired","selectCompanionObject","findBeginningAndEnd","expandSelection","repeatLastCharacterSearch","lastSearch","fillArray","times","args","finalHead","lastState","prevLineEnd","wasLastLine","replacement","includeLineBreak","indent","startLine","endLine","indentAuto","_args","changeCase","swapped","toSwap","yank","endPos","jumpListWalk","scroll","newPos","cursorCoords","ceil","newBottom","scrollToCursor","replayMacro","executeMacroRegister","getLastEditPos","onKeyEventTargetKeyDown","selectForInsert","toggleVisualMode","subMode","reselectLastSelection","_actionArgs","updateLastSelection","anchorMark","headMark","joinLines","finalCh","curFinalPos","newLineAndEnterInsertMode","newlineFn","newlineAndIndentContinueComment","paste","whitespaceLength","tabs","spaces","currentLine","chompedText","wasChomped","firstIndent","wspace","newIndent","quotient","curPosFinal","idx","lastSelectionCurEnd","selectedArea","getSelectedAreaRange","selectedText","emptyStrings","selectBlock","lastCh","extendLineToColumn","repeatFn","setRegister","setMark","markName","replaceWith","replaceTo","replaceWithStr","incrementNumberToken","lineStr","numberStr","baseStr","digits","base","number","zeroPadding","repeatLastEdit","maxCh","ret","prop","hasOwnProperty","offsetLine","offsetCh","commandMatch","pressed","mapped","prefixLen","pressedPrefix","mappedPrefix","cur1","cur2","apply","cur3","cur1before2","cur2before3","trim","isClipped","curHead","getIndex","wasClipped","baseCh","headCh","newDir","lineHead","atAnchor","atHead","getCurrentSelectedAreaRange","getLastSelectedAreaRange","block","updateFakeCursor","headOffset","anchorOffset","right","getHead","moveHead","firstNonWS","_forward","noSymbol","wordStart","symbolToMode","findSymbolModes","bracket","isComplete","nextCh","symb","depth","reverseSymb","section","init","curMoveThrough","comment","preprocess","curCh","lineLen","findWord","emptyLineIsWord","charTests","stop","foundWord","words","eodCh","shortCircuit","firstWord","lastWord","charIdxInLine","includeChar","lastIndexOf","isBoundary","any","skipFold","foldLine","startState","nextChar","ln","curr","last_valid","skip_empty_lines","curr_index","bracketRegexp","openSym","curChar","chars","len","firstIndex","SearchState","setQuery","getOverlay","searchOverlay","setOverlay","overlay","reversed","getScrollbarAnnotate","annotate","setScrollbarAnnotate","searchState_","shortText","status","$loop","schedule","CHANGE_CURSOR","prompt","splitBySlash","argString","splitBySeparator","findUnescapedSlashes","findUnescapedSeparators","separator","slashes","tokens","escapeNextChar","translateRegex","specials","unescape","out","specialComesNext","charUnescapes","translateRegexReplace","unescapes","unescapeRegexReplace","stream","output","matcher","parseQuery","lastSearchRegister","regexPart","forceIgnoreCase","flagsPart","regexp","openNotification","alert","makePrompt","raw","regexEqual","r1","r2","props","rawQuery","matchSol","searchState","showMatchesOnScrollbar","isInRange","getFirstFullyVisibleRow","getLastFullyVisibleRow","undoManager","$undoManager","$lastDelta","ExCommandDispatcher","buildCommandMap_","opt_params","that","_processCommand","commandHistoryRegister","previousCommand","inputStream","params","parseInput_","commandName","matchCommand_","parseCommandArgs_","toInput","lineEnd","parseLineSpec_","numberMatch","parseLineSpecOffset_","offsetMatch","delim","argDelimiter","user","unshift","colorscheme","mapArgs","imap","nmap","vmap","set","setArgs","setCfg","expr","forceGet","optionIsBoolean","oldValue","message","setOptionReturn","setlocal","setglobal","regArgs","regInfo","sort","unique","parseArgs","opts","decimal","hex","octal","err","radix","numPart","textPart","matchPart","compareFn","b","anum","bnum","comparePatternFn","textOld","matchedLines","content","nextCommand","substitute","replacePart","trailing","count","confirm","startPos","doReplace","write","save","nohlsearch","delmarks","sym","startMark","finishMark","charCodeAt","finish","searchCursor","exMode","done","lastPos","replaceAll","newText","_value","savedCallback","detach","insertModeChangeRegister","logInsertModeChange","extra","imc","repeatInsertModeChanges","changeObj","ignoreCount","selectionCount","maybeReset","handleExternalSelection","onKeyFound","repeatForInsert","isAction","cachedInputState","repeatCommand","repeatInsert","changeObject","keyHandler","binding","specialKey","backspace","esc","down","space","home","pageup","pagedown","enter","hashId","ctrlKey","altKey","shiftKey","cloneVimState","constructor","Object","forEach","multiSelectHandleKey","isHandled","wasInVisualBlock","wasMultiselect","old","forEachSelection","$desiredColumn","getVim","handler","$id","drawCursor","pixelPos","w","isbackwards","isBackwards","translate","setStyle","handleKeyboard","data","editor","inputKey","inputHash","inputChar","isMac","getCopyText","once","passEvent","$vimModeHandler","markUndoGroup","updateCursor","updateInputMode","isIntsert","setCommandMode","$keepTextAreaAtCursor","$blockCursor","$cursorLayer","getStatusText","open","all","toggle","aceCommand","vimCmd","delayedExecAceCommand"],"mappings":"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","sourcesContent":["ace.define(\"ace/keyboard/vim\",[\"require\",\"exports\",\"module\",\"ace/range\",\"ace/lib/event_emitter\",\"ace/lib/dom\",\"ace/lib/oop\",\"ace/lib/keys\",\"ace/lib/event\",\"ace/search\",\"ace/lib/useragent\",\"ace/search_highlight\",\"ace/commands/multi_select_commands\",\"ace/mode/text\",\"ace/multi_select\"], function(require, exports, module) {\n  'use strict';\n\n  function log() {\n    var d = \"\";\n    function format(p) {\n      if (typeof p != \"object\")\n        return p + \"\";\n      if (\"line\" in p) {\n        return p.line + \":\" + p.ch;\n      }\n      if (\"anchor\" in p) {\n        return format(p.anchor) + \"->\" + format(p.head);\n      }\n      if (Array.isArray(p))\n        return \"[\" + p.map(function(x) {\n          return format(x);\n        }) + \"]\";\n      return JSON.stringify(p);\n    }\n    for (var i = 0; i < arguments.length; i++) {\n      var p = arguments[i];\n      var f = format(p);\n      d += f + \"  \";\n    }\n    console.log(d);\n  }\n  var Range = require(\"../range\").Range;\n  var EventEmitter = require(\"../lib/event_emitter\").EventEmitter;\n  var dom = require(\"../lib/dom\");\n  var oop = require(\"../lib/oop\");\n  var KEYS = require(\"../lib/keys\");\n  var event = require(\"../lib/event\");\n  var Search = require(\"../search\").Search;\n  var useragent = require(\"../lib/useragent\");\n  var SearchHighlight = require(\"../search_highlight\").SearchHighlight;\n  var multiSelectCommands = require(\"../commands/multi_select_commands\");\n  var TextModeTokenRe = require(\"../mode/text\").Mode.prototype.tokenRe;\n  require(\"../multi_select\");\n\n  var CodeMirror = function(ace) {\n    this.ace = ace;\n    this.state = {};\n    this.marks = {};\n    this.$uid = 0;\n    this.onChange = this.onChange.bind(this);\n    this.onSelectionChange = this.onSelectionChange.bind(this);\n    this.onBeforeEndOperation = this.onBeforeEndOperation.bind(this);\n    this.ace.on('change', this.onChange);\n    this.ace.on('changeSelection', this.onSelectionChange);\n    this.ace.on('beforeEndOperation', this.onBeforeEndOperation);\n  };\n  CodeMirror.Pos = function(line, ch) {\n    if (!(this instanceof Pos)) return new Pos(line, ch);\n    this.line = line; this.ch = ch;\n  };\n  CodeMirror.defineOption = function(name, val, setter) {};\n  CodeMirror.commands = {\n    redo: function(cm) { cm.ace.redo(); },\n    undo: function(cm) { cm.ace.undo(); },\n    newlineAndIndent: function(cm) { cm.ace.insert(\"\\n\"); }\n  };\n  CodeMirror.keyMap = {};\n  CodeMirror.addClass = CodeMirror.rmClass = function() {};\n  CodeMirror.e_stop = CodeMirror.e_preventDefault = event.stopEvent;\n  CodeMirror.keyName = function(e) {\n    var key = (KEYS[e.keyCode] || e.key || \"\");\n    if (key.length == 1) key = key.toUpperCase();\n    key = event.getModifierString(e).replace(/(^|-)\\w/g, function(m) {\n      return m.toUpperCase();\n    }) + key;\n    return key;\n  };\n  CodeMirror.keyMap['default'] = function(key) {\n    return function(cm) {\n      var cmd = cm.ace.commands.commandKeyBinding[key.toLowerCase()];\n      return cmd && cm.ace.execCommand(cmd) !== false;\n    };\n  };\n  CodeMirror.lookupKey = function lookupKey(key, map, handle) {\n    if (!map) map = \"default\";\n    if (typeof map == \"string\")\n      map = CodeMirror.keyMap[map];\n    var found = typeof map == \"function\" ? map(key) : map[key];\n    if (found === false) return \"nothing\";\n    if (found === \"...\") return \"multi\";\n    if (found != null && handle(found)) return \"handled\";\n\n    if (map.fallthrough) {\n      if (!Array.isArray(map.fallthrough))\n        return lookupKey(key, map.fallthrough, handle);\n      for (var i = 0; i < map.fallthrough.length; i++) {\n        var result = lookupKey(key, map.fallthrough[i], handle);\n        if (result) return result;\n      }\n    }\n  };\n\n  CodeMirror.signal = function(o, name, e) { return o._signal(name, e) };\n  CodeMirror.on = event.addListener;\n  CodeMirror.off = event.removeListener;\n  CodeMirror.isWordChar = function(ch) {\n    if (ch < \"\\x7f\") return /^\\w$/.test(ch);\n    TextModeTokenRe.lastIndex = 0;\n    return TextModeTokenRe.test(ch);\n  };\n  \n(function() {\n  oop.implement(CodeMirror.prototype, EventEmitter);\n  \n  this.destroy = function() {\n    this.ace.off('change', this.onChange);\n    this.ace.off('changeSelection', this.onSelectionChange);\n    this.ace.off('beforeEndOperation', this.onBeforeEndOperation);\n    this.removeOverlay();\n  };\n  this.virtualSelectionMode = function() {\n    return this.ace.inVirtualSelectionMode && this.ace.selection.index;\n  };\n  this.onChange = function(delta) {\n    var change = { text: delta.action[0] == 'i' ? delta.lines : [] };\n    var curOp = this.curOp = this.curOp || {};\n    if (!curOp.changeHandlers)\n      curOp.changeHandlers = this._eventRegistry[\"change\"] && this._eventRegistry[\"change\"].slice();\n    if (!curOp.lastChange) {\n      curOp.lastChange = curOp.change = change;\n    } else {\n      curOp.lastChange.next = curOp.lastChange = change;\n    }\n    this.$updateMarkers(delta);\n  };\n  this.onSelectionChange = function() {\n    var curOp = this.curOp = this.curOp || {};\n    if (!curOp.cursorActivityHandlers)\n      curOp.cursorActivityHandlers = this._eventRegistry[\"cursorActivity\"] && this._eventRegistry[\"cursorActivity\"].slice();\n    this.curOp.cursorActivity = true;\n    if (this.ace.inMultiSelectMode) {\n      this.ace.keyBinding.removeKeyboardHandler(multiSelectCommands.keyboardHandler);\n    }\n  };\n  this.operation = function(fn, force) {\n    if (!force && this.curOp || force && this.curOp && this.curOp.force) {\n      return fn();\n    }\n    if (force || !this.ace.curOp) {\n      if (this.curOp)\n        this.onBeforeEndOperation();\n    }\n    if (!this.ace.curOp) {\n      var prevOp = this.ace.prevOp;\n      this.ace.startOperation({\n        command: { name: \"vim\",  scrollIntoView: \"cursor\" }\n      });\n    }\n    var curOp = this.curOp = this.curOp || {};\n    this.curOp.force = force;\n    var result = fn();\n    if (this.ace.curOp && this.ace.curOp.command.name == \"vim\") {\n      if (this.state.dialog)\n        this.ace.curOp.command.scrollIntoView = false;\n      this.ace.endOperation();\n      if (!curOp.cursorActivity && !curOp.lastChange && prevOp)\n        this.ace.prevOp = prevOp;\n    }\n    if (force || !this.ace.curOp) {\n      if (this.curOp)\n        this.onBeforeEndOperation();\n    }\n    return result;\n  };\n  this.onBeforeEndOperation = function() {\n    var op = this.curOp;\n    if (op) {\n      if (op.change) { this.signal(\"change\", op.change, op); }\n      if (op && op.cursorActivity) { this.signal(\"cursorActivity\", null, op); }\n      this.curOp = null;\n    }\n  };\n\n  this.signal = function(eventName, e, handlers) {\n    var listeners = handlers ? handlers[eventName + \"Handlers\"]\n        : (this._eventRegistry || {})[eventName];\n    if (!listeners)\n        return;\n    listeners = listeners.slice();\n    for (var i=0; i<listeners.length; i++)\n        listeners[i](this, e);\n  };\n  this.firstLine = function() { return 0; };\n  this.lastLine = function() { return this.ace.session.getLength() - 1; };\n  this.lineCount = function() { return this.ace.session.getLength(); };\n  this.setCursor = function(line, ch) {\n    if (typeof line === 'object') {\n      ch = line.ch;\n      line = line.line;\n    }\n    if (!this.ace.inVirtualSelectionMode)\n      this.ace.exitMultiSelectMode();\n    this.ace.session.unfold({row: line, column: ch});\n    this.ace.selection.moveTo(line, ch);\n  };\n  this.getCursor = function(p) {\n    var sel = this.ace.selection;\n    var pos = p == 'anchor' ? (sel.isEmpty() ? sel.lead : sel.anchor) :\n        p == 'head' || !p ? sel.lead : sel.getRange()[p];\n    return toCmPos(pos);\n  };\n  this.listSelections = function(p) {\n    var ranges = this.ace.multiSelect.rangeList.ranges;\n    if (!ranges.length || this.ace.inVirtualSelectionMode)\n      return [{anchor: this.getCursor('anchor'), head: this.getCursor('head')}];\n    return ranges.map(function(r) {\n      return {\n        anchor: this.clipPos(toCmPos(r.cursor == r.end ? r.start : r.end)),\n        head: this.clipPos(toCmPos(r.cursor))\n      };\n    }, this);\n  };\n  this.setSelections = function(p, primIndex) {\n    var sel = this.ace.multiSelect;\n    var ranges = p.map(function(x) {\n      var anchor = toAcePos(x.anchor);\n      var head = toAcePos(x.head);\n      var r = Range.comparePoints(anchor, head) < 0\n        ? new Range.fromPoints(anchor, head)\n        : new Range.fromPoints(head, anchor);\n      r.cursor = Range.comparePoints(r.start, head) ? r.end : r.start;\n      return r;\n    });\n    \n    if (this.ace.inVirtualSelectionMode) {\n      this.ace.selection.fromOrientedRange(ranges[0]);\n      return;\n    }\n    if (!primIndex) {\n        ranges = ranges.reverse();\n    } else if (ranges[primIndex]) {\n       ranges.push(ranges.splice(primIndex, 1)[0]);\n    }\n    sel.toSingleRange(ranges[0].clone());\n    var session = this.ace.session;\n    for (var i = 0; i < ranges.length; i++) {\n      var range = session.$clipRangeToDocument(ranges[i]); // todo why ace doesn't do this?\n      sel.addRange(range);\n    }\n  };\n  this.setSelection = function(a, h, options) {\n    var sel = this.ace.selection;\n    sel.moveTo(a.line, a.ch);\n    sel.selectTo(h.line, h.ch);\n    if (options && options.origin == '*mouse') {\n      this.onBeforeEndOperation();\n    }\n  };\n  this.somethingSelected = function(p) {\n    return !this.ace.selection.isEmpty();\n  };\n  this.clipPos = function(p) {\n    var pos = this.ace.session.$clipPositionToDocument(p.line, p.ch);\n    return toCmPos(pos);\n  };\n  this.markText = function(cursor) {\n    return {clear: function() {}, find: function() {}};\n  };\n  this.$updateMarkers = function(delta) {\n    var isInsert = delta.action == \"insert\";\n    var start = delta.start;\n    var end = delta.end;\n    var rowShift = (end.row - start.row) * (isInsert ? 1 : -1);\n    var colShift = (end.column - start.column) * (isInsert ? 1 : -1);\n    if (isInsert) end = start;\n    \n    for (var i in this.marks) {\n      var point = this.marks[i];\n      var cmp = Range.comparePoints(point, start);\n      if (cmp < 0) {\n        continue; // delta starts after the range\n      }\n      if (cmp === 0) {\n        if (isInsert) {\n          if (point.bias == 1) {\n            cmp = 1;\n          } else {\n            point.bias = -1;\n            continue;\n          }\n        }\n      }\n      var cmp2 = isInsert ? cmp : Range.comparePoints(point, end);\n      if (cmp2 > 0) {\n        point.row += rowShift;\n        point.column += point.row == end.row ? colShift : 0;\n        continue;\n      }\n      if (!isInsert && cmp2 <= 0) {\n        point.row = start.row;\n        point.column = start.column;\n        if (cmp2 === 0)\n          point.bias = 1;\n      }\n    }\n  };\n  var Marker = function(cm, id, row, column) {\n    this.cm = cm;\n    this.id = id;\n    this.row = row;\n    this.column = column;\n    cm.marks[this.id] = this;\n  };\n  Marker.prototype.clear = function() { delete this.cm.marks[this.id] };\n  Marker.prototype.find = function() { return toCmPos(this) };\n  this.setBookmark = function(cursor, options) {\n    var bm = new Marker(this, this.$uid++, cursor.line, cursor.ch);\n    if (!options || !options.insertLeft)\n      bm.$insertRight = true;\n    this.marks[bm.id] = bm;\n    return bm;\n  };\n  this.moveH = function(increment, unit) {\n    if (unit == 'char') {\n      var sel = this.ace.selection;\n      sel.clearSelection();\n      sel.moveCursorBy(0, increment);\n    }\n  };\n  this.findPosV = function(start, amount, unit, goalColumn) {\n    if (unit == 'page') {\n      var renderer = this.ace.renderer;\n      var config = renderer.layerConfig;\n      amount = amount * Math.floor(config.height / config.lineHeight);\n      unit = 'line';\n    }\n    if (unit == 'line') {\n      var screenPos = this.ace.session.documentToScreenPosition(start.line, start.ch);\n      if (goalColumn != null)\n        screenPos.column = goalColumn;\n      screenPos.row += amount;\n      screenPos.row = Math.min(Math.max(0, screenPos.row), this.ace.session.getScreenLength() - 1);\n      var pos = this.ace.session.screenToDocumentPosition(screenPos.row, screenPos.column);\n      return toCmPos(pos);\n    } else {\n      debugger;\n    }\n  };\n  this.charCoords = function(pos, mode) {\n    if (mode == 'div' || !mode) {\n      var sc = this.ace.session.documentToScreenPosition(pos.line, pos.ch);\n      return {left: sc.column, top: sc.row};\n    }if (mode == 'local') {\n      var renderer = this.ace.renderer;\n      var sc = this.ace.session.documentToScreenPosition(pos.line, pos.ch);\n      var lh = renderer.layerConfig.lineHeight;\n      var cw = renderer.layerConfig.characterWidth;\n      var top = lh * sc.row;\n      return {left: sc.column * cw, top: top, bottom: top + lh};\n    }\n  };\n  this.coordsChar = function(pos, mode) {\n    var renderer = this.ace.renderer;\n    if (mode == 'local') {\n      var row = Math.max(0, Math.floor(pos.top / renderer.lineHeight));\n      var col = Math.max(0, Math.floor(pos.left / renderer.characterWidth));\n      var ch = renderer.session.screenToDocumentPosition(row, col);\n      return toCmPos(ch);\n    } else if (mode == 'div') {\n      throw \"not implemented\";\n    }\n  };\n  this.getSearchCursor = function(query, pos, caseFold) {\n    var caseSensitive = false;\n    var isRegexp = false;\n    if (query instanceof RegExp && !query.global) {\n      caseSensitive = !query.ignoreCase;\n      query = query.source;\n      isRegexp = true;\n    }\n    var search = new Search();\n    if (pos.ch == undefined) pos.ch = Number.MAX_VALUE;\n    var acePos = {row: pos.line, column: pos.ch};\n    var cm = this;\n    var last = null;\n    return {\n      findNext: function() { return this.find(false) },\n      findPrevious: function() {return this.find(true) },\n      find: function(back) {\n        search.setOptions({\n          needle: query,\n          caseSensitive: caseSensitive,\n          wrap: false,\n          backwards: back,\n          regExp: isRegexp,\n          start: last || acePos\n        });\n        var range = search.find(cm.ace.session);\n        if (range && range.isEmpty()) {\n          if (cm.getLine(range.start.row).length == range.start.column) {\n            search.$options.start = range;\n            range = search.find(cm.ace.session);\n          }\n        }\n        last = range;\n        return last;\n      },\n      from: function() { return last && toCmPos(last.start) },\n      to: function() { return last && toCmPos(last.end) },\n      replace: function(text) {\n        if (last) {\n          last.end = cm.ace.session.doc.replace(last, text);\n        }\n      }\n    };\n  };\n  this.scrollTo = function(x, y) {\n    var renderer = this.ace.renderer;\n    var config = renderer.layerConfig;\n    var maxHeight = config.maxHeight;\n    maxHeight -= (renderer.$size.scrollerHeight - renderer.lineHeight) * renderer.$scrollPastEnd;\n    if (y != null) this.ace.session.setScrollTop(Math.max(0, Math.min(y, maxHeight)));\n    if (x != null) this.ace.session.setScrollLeft(Math.max(0, Math.min(x, config.width)));\n  };\n  this.scrollInfo = function() { return 0; };\n  this.scrollIntoView = function(pos, margin) {\n    if (pos) {\n      var renderer = this.ace.renderer;\n      var viewMargin = { \"top\": 0, \"bottom\": margin };\n      renderer.scrollCursorIntoView(toAcePos(pos),\n        (renderer.lineHeight * 2) / renderer.$size.scrollerHeight, viewMargin);\n    }\n  };\n  this.getLine = function(row) { return this.ace.session.getLine(row) };\n  this.getRange = function(s, e) {\n    return this.ace.session.getTextRange(new Range(s.line, s.ch, e.line, e.ch));\n  };\n  this.replaceRange = function(text, s, e) {\n    if (!e) e = s;\n    return this.ace.session.replace(new Range(s.line, s.ch, e.line, e.ch), text);\n  };\n  this.replaceSelection = \n  this.replaceSelections = function(p) {\n    var sel = this.ace.selection;\n    if (this.ace.inVirtualSelectionMode) {\n      this.ace.session.replace(sel.getRange(), p[0] || \"\");\n      return;\n    }\n    sel.inVirtualSelectionMode = true;\n    var ranges = sel.rangeList.ranges;\n    if (!ranges.length) ranges = [this.ace.multiSelect.getRange()];\n    for (var i = ranges.length; i--;)\n       this.ace.session.replace(ranges[i], p[i] || \"\");\n    sel.inVirtualSelectionMode = false;\n  };\n  this.getSelection = function() {\n    return this.ace.getSelectedText();\n  };\n  this.getSelections = function() {\n    return this.listSelections().map(function(x) {\n      return this.getRange(x.anchor, x.head);\n    }, this);\n  };\n  this.getInputField = function() {\n    return this.ace.textInput.getElement();\n  };\n  this.getWrapperElement = function() {\n    return this.ace.container;\n  };\n  var optMap = {\n    indentWithTabs: \"useSoftTabs\",\n    indentUnit: \"tabSize\",\n    tabSize: \"tabSize\",\n    firstLineNumber: \"firstLineNumber\",\n    readOnly: \"readOnly\"\n  };\n  this.setOption = function(name, val) {\n    this.state[name] = val;\n    switch (name) {\n      case 'indentWithTabs':\n        name = optMap[name];\n        val = !val;\n      break;\n      case 'keyMap':\n        this.state.$keyMap = val;\n        return;\n      break;\n      default:\n        name = optMap[name];\n    }\n    if (name)\n      this.ace.setOption(name, val);\n  };\n  this.getOption = function(name, val) {\n    var aceOpt = optMap[name];\n    if (aceOpt)\n      val = this.ace.getOption(aceOpt);\n    switch (name) {\n      case 'indentWithTabs':\n        name = optMap[name];\n        return !val;\n      case 'keyMap':\n        return this.state.$keyMap;\n    }\n    return aceOpt ? val : this.state[name];\n  };\n  this.toggleOverwrite = function(on) {\n    this.state.overwrite = on;\n    return this.ace.setOverwrite(on);\n  };\n  this.addOverlay = function(o) {\n    if (!this.$searchHighlight || !this.$searchHighlight.session) {\n      var highlight = new SearchHighlight(null, \"ace_highlight-marker\", \"text\");\n      var marker = this.ace.session.addDynamicMarker(highlight);\n      highlight.id = marker.id;\n      highlight.session = this.ace.session;\n      highlight.destroy = function(o) {\n        highlight.session.off(\"change\", highlight.updateOnChange);\n        highlight.session.off(\"changeEditor\", highlight.destroy);\n        highlight.session.removeMarker(highlight.id);\n        highlight.session = null;\n      };\n      highlight.updateOnChange = function(delta) {\n        var row = delta.start.row;\n        if (row == delta.end.row) highlight.cache[row] = undefined;\n        else highlight.cache.splice(row, highlight.cache.length);\n      };\n      highlight.session.on(\"changeEditor\", highlight.destroy);\n      highlight.session.on(\"change\", highlight.updateOnChange);\n    }\n    var re = new RegExp(o.query.source, \"gmi\");\n    this.$searchHighlight = o.highlight = highlight;\n    this.$searchHighlight.setRegexp(re);\n    this.ace.renderer.updateBackMarkers();\n  };\n  this.removeOverlay = function(o) {\n    if (this.$searchHighlight && this.$searchHighlight.session) {\n      this.$searchHighlight.destroy();\n    }\n  };\n  this.getScrollInfo = function() {\n    var renderer = this.ace.renderer;\n    var config = renderer.layerConfig;\n    return {\n      left: renderer.scrollLeft,\n      top: renderer.scrollTop,\n      height: config.maxHeight,\n      width: config.width,\n      clientHeight: config.height,\n      clientWidth: config.width\n    };\n  };\n  this.getValue = function() {\n    return this.ace.getValue();\n  };\n  this.setValue = function(v) {\n    return this.ace.setValue(v, -1);\n  };\n  this.getTokenTypeAt = function(pos) {\n    var token = this.ace.session.getTokenAt(pos.line, pos.ch);\n    return token && /comment|string/.test(token.type) ? \"string\" : \"\";\n  };\n  this.findMatchingBracket = function(pos) {\n    var m = this.ace.session.findMatchingBracket(toAcePos(pos));\n    return {to: m && toCmPos(m)};\n  };\n  this.indentLine = function(line, method) {\n    if (method === true)\n        this.ace.session.indentRows(line, line, \"\\t\");\n    else if (method === false)\n        this.ace.session.outdentRows(new Range(line, 0, line, 0));\n  };\n  this.indexFromPos = function(pos) {\n    return this.ace.session.doc.positionToIndex(toAcePos(pos));\n  };\n  this.posFromIndex = function(index) {\n    return toCmPos(this.ace.session.doc.indexToPosition(index));\n  };\n  this.focus = function(index) {\n    return this.ace.textInput.focus();\n  };\n  this.blur = function(index) {\n    return this.ace.blur();\n  };\n  this.defaultTextHeight = function(index) {\n    return this.ace.renderer.layerConfig.lineHeight;\n  };\n  this.scanForBracket = function(pos, dir, _, options) {\n    var re = options.bracketRegex.source;\n    var tokenRe = /paren|text|operator|tag/;\n    if (dir == 1) {\n      var m = this.ace.session.$findClosingBracket(re.slice(1, 2), toAcePos(pos), tokenRe);\n    } else {\n      var m = this.ace.session.$findOpeningBracket(re.slice(-2, -1), {row: pos.line, column: pos.ch + 1}, tokenRe);\n    }\n    return m && {pos: toCmPos(m)};\n  };\n  this.refresh = function() {\n    return this.ace.resize(true);\n  };\n  this.getMode = function() {\n    return { name : this.getOption(\"mode\") };\n  };\n  this.execCommand = function(name) {\n    if (name == \"indentAuto\") this.ace.execCommand(\"autoindent\");\n    else console.log(name + \" is not implemented\");\n  };\n}).call(CodeMirror.prototype);\n  function toAcePos(cmPos) {\n    return {row: cmPos.line, column: cmPos.ch};\n  }\n  function toCmPos(acePos) {\n    return new Pos(acePos.row, acePos.column);\n  }\n\n  var StringStream = CodeMirror.StringStream = function(string, tabSize) {\n    this.pos = this.start = 0;\n    this.string = string;\n    this.tabSize = tabSize || 8;\n    this.lastColumnPos = this.lastColumnValue = 0;\n    this.lineStart = 0;\n  };\n\n  StringStream.prototype = {\n    eol: function() {return this.pos >= this.string.length;},\n    sol: function() {return this.pos == this.lineStart;},\n    peek: function() {return this.string.charAt(this.pos) || undefined;},\n    next: function() {\n      if (this.pos < this.string.length)\n        return this.string.charAt(this.pos++);\n    },\n    eat: function(match) {\n      var ch = this.string.charAt(this.pos);\n      if (typeof match == \"string\") var ok = ch == match;\n      else var ok = ch && (match.test ? match.test(ch) : match(ch));\n      if (ok) {++this.pos; return ch;}\n    },\n    eatWhile: function(match) {\n      var start = this.pos;\n      while (this.eat(match)){}\n      return this.pos > start;\n    },\n    eatSpace: function() {\n      var start = this.pos;\n      while (/[\\s\\u00a0]/.test(this.string.charAt(this.pos))) ++this.pos;\n      return this.pos > start;\n    },\n    skipToEnd: function() {this.pos = this.string.length;},\n    skipTo: function(ch) {\n      var found = this.string.indexOf(ch, this.pos);\n      if (found > -1) {this.pos = found; return true;}\n    },\n    backUp: function(n) {this.pos -= n;},\n    column: function() {\n      throw \"not implemented\";\n    },\n    indentation: function() {\n      throw \"not implemented\";\n    },\n    match: function(pattern, consume, caseInsensitive) {\n      if (typeof pattern == \"string\") {\n        var cased = function(str) {return caseInsensitive ? str.toLowerCase() : str;};\n        var substr = this.string.substr(this.pos, pattern.length);\n        if (cased(substr) == cased(pattern)) {\n          if (consume !== false) this.pos += pattern.length;\n          return true;\n        }\n      } else {\n        var match = this.string.slice(this.pos).match(pattern);\n        if (match && match.index > 0) return null;\n        if (match && consume !== false) this.pos += match[0].length;\n        return match;\n      }\n    },\n    current: function(){return this.string.slice(this.start, this.pos);},\n    hideFirstChars: function(n, inner) {\n      this.lineStart += n;\n      try { return inner(); }\n      finally { this.lineStart -= n; }\n    }\n  };\nCodeMirror.defineExtension = function(name, fn) {\n  CodeMirror.prototype[name] = fn;\n};\ndom.importCssString(\".normal-mode .ace_cursor{\\\n    border: none;\\\n    background-color: rgba(255,0,0,0.5);\\\n}\\\n.normal-mode .ace_hidden-cursors .ace_cursor{\\\n  background-color: transparent;\\\n  border: 1px solid red;\\\n  opacity: 0.7\\\n}\\\n.ace_dialog {\\\n  position: absolute;\\\n  left: 0; right: 0;\\\n  background: inherit;\\\n  z-index: 15;\\\n  padding: .1em .8em;\\\n  overflow: hidden;\\\n  color: inherit;\\\n}\\\n.ace_dialog-top {\\\n  border-bottom: 1px solid #444;\\\n  top: 0;\\\n}\\\n.ace_dialog-bottom {\\\n  border-top: 1px solid #444;\\\n  bottom: 0;\\\n}\\\n.ace_dialog input {\\\n  border: none;\\\n  outline: none;\\\n  background: transparent;\\\n  width: 20em;\\\n  color: inherit;\\\n  font-family: monospace;\\\n}\", \"vimMode\");\n(function() {\n  function dialogDiv(cm, template, bottom) {\n    var wrap = cm.ace.container;\n    var dialog;\n    dialog = wrap.appendChild(document.createElement(\"div\"));\n    if (bottom)\n      dialog.className = \"ace_dialog ace_dialog-bottom\";\n    else\n      dialog.className = \"ace_dialog ace_dialog-top\";\n\n    if (typeof template == \"string\") {\n      dialog.innerHTML = template;\n    } else { // Assuming it's a detached DOM element.\n      dialog.appendChild(template);\n    }\n    return dialog;\n  }\n\n  function closeNotification(cm, newVal) {\n    if (cm.state.currentNotificationClose)\n      cm.state.currentNotificationClose();\n    cm.state.currentNotificationClose = newVal;\n  }\n\n  CodeMirror.defineExtension(\"openDialog\", function(template, callback, options) {\n    if (this.virtualSelectionMode()) return;\n    if (!options) options = {};\n\n    closeNotification(this, null);\n\n    var dialog = dialogDiv(this, template, options.bottom);\n    var closed = false, me = this;\n    this.state.dialog = dialog;\n    function close(newVal) {\n      if (typeof newVal == 'string') {\n        inp.value = newVal;\n      } else {\n        if (closed) return;\n        \n        if (newVal && newVal.type == \"blur\") {\n          if (document.activeElement === inp)\n            return;\n        }\n        \n        me.state.dialog = null;\n        closed = true;\n        dialog.parentNode.removeChild(dialog);\n        me.focus();\n\n        if (options.onClose) options.onClose(dialog);\n      }\n    }\n\n    var inp = dialog.getElementsByTagName(\"input\")[0], button;\n    if (inp) {\n      if (options.value) {\n        inp.value = options.value;\n        if (options.selectValueOnOpen !== false) inp.select();\n      }\n\n      if (options.onInput)\n        CodeMirror.on(inp, \"input\", function(e) { options.onInput(e, inp.value, close);});\n      if (options.onKeyUp)\n        CodeMirror.on(inp, \"keyup\", function(e) {options.onKeyUp(e, inp.value, close);});\n\n      CodeMirror.on(inp, \"keydown\", function(e) {\n        if (options && options.onKeyDown && options.onKeyDown(e, inp.value, close)) { return; }\n        if (e.keyCode == 13) callback(inp.value);\n        if (e.keyCode == 27 || (options.closeOnEnter !== false && e.keyCode == 13)) {\n          inp.blur();\n          CodeMirror.e_stop(e);\n          close();\n        }\n      });\n\n      if (options.closeOnBlur !== false) CodeMirror.on(inp, \"blur\", close);\n\n      inp.focus();\n    } else if (button = dialog.getElementsByTagName(\"button\")[0]) {\n      CodeMirror.on(button, \"click\", function() {\n        close();\n        me.focus();\n      });\n\n      if (options.closeOnBlur !== false) CodeMirror.on(button, \"blur\", close);\n\n      button.focus();\n    }\n    return close;\n  });\n\n  CodeMirror.defineExtension(\"openNotification\", function(template, options) {\n    if (this.virtualSelectionMode()) return;\n    closeNotification(this, close);\n    var dialog = dialogDiv(this, template, options && options.bottom);\n    var closed = false, doneTimer;\n    var duration = options && typeof options.duration !== \"undefined\" ? options.duration : 5000;\n\n    function close() {\n      if (closed) return;\n      closed = true;\n      clearTimeout(doneTimer);\n      dialog.parentNode.removeChild(dialog);\n    }\n\n    CodeMirror.on(dialog, 'click', function(e) {\n      CodeMirror.e_preventDefault(e);\n      close();\n    });\n\n    if (duration)\n      doneTimer = setTimeout(close, duration);\n\n    return close;\n  });\n})();\n\n  \n  var defaultKeymap = [\n    { keys: '<Left>', type: 'keyToKey', toKeys: 'h' },\n    { keys: '<Right>', type: 'keyToKey', toKeys: 'l' },\n    { keys: '<Up>', type: 'keyToKey', toKeys: 'k' },\n    { keys: '<Down>', type: 'keyToKey', toKeys: 'j' },\n    { keys: '<Space>', type: 'keyToKey', toKeys: 'l' },\n    { keys: '<BS>', type: 'keyToKey', toKeys: 'h', context: 'normal'},\n    { keys: '<Del>', type: 'keyToKey', toKeys: 'x', context: 'normal'},\n    { keys: '<C-Space>', type: 'keyToKey', toKeys: 'W' },\n    { keys: '<C-BS>', type: 'keyToKey', toKeys: 'B', context: 'normal' },\n    { keys: '<S-Space>', type: 'keyToKey', toKeys: 'w' },\n    { keys: '<S-BS>', type: 'keyToKey', toKeys: 'b', context: 'normal' },\n    { keys: '<C-n>', type: 'keyToKey', toKeys: 'j' },\n    { keys: '<C-p>', type: 'keyToKey', toKeys: 'k' },\n    { keys: '<C-[>', type: 'keyToKey', toKeys: '<Esc>' },\n    { keys: '<C-c>', type: 'keyToKey', toKeys: '<Esc>' },\n    { keys: '<C-[>', type: 'keyToKey', toKeys: '<Esc>', context: 'insert' },\n    { keys: '<C-c>', type: 'keyToKey', toKeys: '<Esc>', context: 'insert' },\n    { keys: '<C-Esc>', type: 'keyToKey', toKeys: '<Esc>' }, // ace_patch ipad keyboard sends C-Esc instead of C-[\n    { keys: '<C-Esc>', type: 'keyToKey', toKeys: '<Esc>', context: 'insert' },\n    { keys: 's', type: 'keyToKey', toKeys: 'cl', context: 'normal' },\n    { keys: 's', type: 'keyToKey', toKeys: 'c', context: 'visual'},\n    { keys: 'S', type: 'keyToKey', toKeys: 'cc', context: 'normal' },\n    { keys: 'S', type: 'keyToKey', toKeys: 'VdO', context: 'visual' },\n    { keys: '<Home>', type: 'keyToKey', toKeys: '0' },\n    { keys: '<End>', type: 'keyToKey', toKeys: '$' },\n    { keys: '<PageUp>', type: 'keyToKey', toKeys: '<C-b>' },\n    { keys: '<PageDown>', type: 'keyToKey', toKeys: '<C-f>' },\n    { keys: '<CR>', type: 'keyToKey', toKeys: 'j^', context: 'normal' },\n    { keys: '<Ins>', type: 'action', action: 'toggleOverwrite', context: 'insert' },\n    { keys: 'H', type: 'motion', motion: 'moveToTopLine', motionArgs: { linewise: true, toJumplist: true }},\n    { keys: 'M', type: 'motion', motion: 'moveToMiddleLine', motionArgs: { linewise: true, toJumplist: true }},\n    { keys: 'L', type: 'motion', motion: 'moveToBottomLine', motionArgs: { linewise: true, toJumplist: true }},\n    { keys: 'h', type: 'motion', motion: 'moveByCharacters', motionArgs: { forward: false }},\n    { keys: 'l', type: 'motion', motion: 'moveByCharacters', motionArgs: { forward: true }},\n    { keys: 'j', type: 'motion', motion: 'moveByLines', motionArgs: { forward: true, linewise: true }},\n    { keys: 'k', type: 'motion', motion: 'moveByLines', motionArgs: { forward: false, linewise: true }},\n    { keys: 'gj', type: 'motion', motion: 'moveByDisplayLines', motionArgs: { forward: true }},\n    { keys: 'gk', type: 'motion', motion: 'moveByDisplayLines', motionArgs: { forward: false }},\n    { keys: 'w', type: 'motion', motion: 'moveByWords', motionArgs: { forward: true, wordEnd: false }},\n    { keys: 'W', type: 'motion', motion: 'moveByWords', motionArgs: { forward: true, wordEnd: false, bigWord: true }},\n    { keys: 'e', type: 'motion', motion: 'moveByWords', motionArgs: { forward: true, wordEnd: true, inclusive: true }},\n    { keys: 'E', type: 'motion', motion: 'moveByWords', motionArgs: { forward: true, wordEnd: true, bigWord: true, inclusive: true }},\n    { keys: 'b', type: 'motion', motion: 'moveByWords', motionArgs: { forward: false, wordEnd: false }},\n    { keys: 'B', type: 'motion', motion: 'moveByWords', motionArgs: { forward: false, wordEnd: false, bigWord: true }},\n    { keys: 'ge', type: 'motion', motion: 'moveByWords', motionArgs: { forward: false, wordEnd: true, inclusive: true }},\n    { keys: 'gE', type: 'motion', motion: 'moveByWords', motionArgs: { forward: false, wordEnd: true, bigWord: true, inclusive: true }},\n    { keys: '{', type: 'motion', motion: 'moveByParagraph', motionArgs: { forward: false, toJumplist: true }},\n    { keys: '}', type: 'motion', motion: 'moveByParagraph', motionArgs: { forward: true, toJumplist: true }},\n    { keys: '(', type: 'motion', motion: 'moveBySentence', motionArgs: { forward: false }},\n    { keys: ')', type: 'motion', motion: 'moveBySentence', motionArgs: { forward: true }},\n    { keys: '<C-f>', type: 'motion', motion: 'moveByPage', motionArgs: { forward: true }},\n    { keys: '<C-b>', type: 'motion', motion: 'moveByPage', motionArgs: { forward: false }},\n    { keys: '<C-d>', type: 'motion', motion: 'moveByScroll', motionArgs: { forward: true, explicitRepeat: true }},\n    { keys: '<C-u>', type: 'motion', motion: 'moveByScroll', motionArgs: { forward: false, explicitRepeat: true }},\n    { keys: 'gg', type: 'motion', motion: 'moveToLineOrEdgeOfDocument', motionArgs: { forward: false, explicitRepeat: true, linewise: true, toJumplist: true }},\n    { keys: 'G', type: 'motion', motion: 'moveToLineOrEdgeOfDocument', motionArgs: { forward: true, explicitRepeat: true, linewise: true, toJumplist: true }},\n    { keys: '0', type: 'motion', motion: 'moveToStartOfLine' },\n    { keys: '^', type: 'motion', motion: 'moveToFirstNonWhiteSpaceCharacter' },\n    { keys: '+', type: 'motion', motion: 'moveByLines', motionArgs: { forward: true, toFirstChar:true }},\n    { keys: '-', type: 'motion', motion: 'moveByLines', motionArgs: { forward: false, toFirstChar:true }},\n    { keys: '_', type: 'motion', motion: 'moveByLines', motionArgs: { forward: true, toFirstChar:true, repeatOffset:-1 }},\n    { keys: '$', type: 'motion', motion: 'moveToEol', motionArgs: { inclusive: true }},\n    { keys: '%', type: 'motion', motion: 'moveToMatchedSymbol', motionArgs: { inclusive: true, toJumplist: true }},\n    { keys: 'f<character>', type: 'motion', motion: 'moveToCharacter', motionArgs: { forward: true , inclusive: true }},\n    { keys: 'F<character>', type: 'motion', motion: 'moveToCharacter', motionArgs: { forward: false }},\n    { keys: 't<character>', type: 'motion', motion: 'moveTillCharacter', motionArgs: { forward: true, inclusive: true }},\n    { keys: 'T<character>', type: 'motion', motion: 'moveTillCharacter', motionArgs: { forward: false }},\n    { keys: ';', type: 'motion', motion: 'repeatLastCharacterSearch', motionArgs: { forward: true }},\n    { keys: ',', type: 'motion', motion: 'repeatLastCharacterSearch', motionArgs: { forward: false }},\n    { keys: '\\'<character>', type: 'motion', motion: 'goToMark', motionArgs: {toJumplist: true, linewise: true}},\n    { keys: '`<character>', type: 'motion', motion: 'goToMark', motionArgs: {toJumplist: true}},\n    { keys: ']`', type: 'motion', motion: 'jumpToMark', motionArgs: { forward: true } },\n    { keys: '[`', type: 'motion', motion: 'jumpToMark', motionArgs: { forward: false } },\n    { keys: ']\\'', type: 'motion', motion: 'jumpToMark', motionArgs: { forward: true, linewise: true } },\n    { keys: '[\\'', type: 'motion', motion: 'jumpToMark', motionArgs: { forward: false, linewise: true } },\n    { keys: ']p', type: 'action', action: 'paste', isEdit: true, actionArgs: { after: true, isEdit: true, matchIndent: true}},\n    { keys: '[p', type: 'action', action: 'paste', isEdit: true, actionArgs: { after: false, isEdit: true, matchIndent: true}},\n    { keys: ']<character>', type: 'motion', motion: 'moveToSymbol', motionArgs: { forward: true, toJumplist: true}},\n    { keys: '[<character>', type: 'motion', motion: 'moveToSymbol', motionArgs: { forward: false, toJumplist: true}},\n    { keys: '|', type: 'motion', motion: 'moveToColumn'},\n    { keys: 'o', type: 'motion', motion: 'moveToOtherHighlightedEnd', context:'visual'},\n    { keys: 'O', type: 'motion', motion: 'moveToOtherHighlightedEnd', motionArgs: {sameLine: true}, context:'visual'},\n    { keys: 'd', type: 'operator', operator: 'delete' },\n    { keys: 'y', type: 'operator', operator: 'yank' },\n    { keys: 'c', type: 'operator', operator: 'change' },\n    { keys: '=', type: 'operator', operator: 'indentAuto' },\n    { keys: '>', type: 'operator', operator: 'indent', operatorArgs: { indentRight: true }},\n    { keys: '<', type: 'operator', operator: 'indent', operatorArgs: { indentRight: false }},\n    { keys: 'g~', type: 'operator', operator: 'changeCase' },\n    { keys: 'gu', type: 'operator', operator: 'changeCase', operatorArgs: {toLower: true}, isEdit: true },\n    { keys: 'gU', type: 'operator', operator: 'changeCase', operatorArgs: {toLower: false}, isEdit: true },\n    { keys: 'n', type: 'motion', motion: 'findNext', motionArgs: { forward: true, toJumplist: true }},\n    { keys: 'N', type: 'motion', motion: 'findNext', motionArgs: { forward: false, toJumplist: true }},\n    { keys: 'x', type: 'operatorMotion', operator: 'delete', motion: 'moveByCharacters', motionArgs: { forward: true }, operatorMotionArgs: { visualLine: false }},\n    { keys: 'X', type: 'operatorMotion', operator: 'delete', motion: 'moveByCharacters', motionArgs: { forward: false }, operatorMotionArgs: { visualLine: true }},\n    { keys: 'D', type: 'operatorMotion', operator: 'delete', motion: 'moveToEol', motionArgs: { inclusive: true }, context: 'normal'},\n    { keys: 'D', type: 'operator', operator: 'delete', operatorArgs: { linewise: true }, context: 'visual'},\n    { keys: 'Y', type: 'operatorMotion', operator: 'yank', motion: 'expandToLine', motionArgs: { linewise: true }, context: 'normal'},\n    { keys: 'Y', type: 'operator', operator: 'yank', operatorArgs: { linewise: true }, context: 'visual'},\n    { keys: 'C', type: 'operatorMotion', operator: 'change', motion: 'moveToEol', motionArgs: { inclusive: true }, context: 'normal'},\n    { keys: 'C', type: 'operator', operator: 'change', operatorArgs: { linewise: true }, context: 'visual'},\n    { keys: '~', type: 'operatorMotion', operator: 'changeCase', motion: 'moveByCharacters', motionArgs: { forward: true }, operatorArgs: { shouldMoveCursor: true }, context: 'normal'},\n    { keys: '~', type: 'operator', operator: 'changeCase', context: 'visual'},\n    { keys: '<C-w>', type: 'operatorMotion', operator: 'delete', motion: 'moveByWords', motionArgs: { forward: false, wordEnd: false }, context: 'insert' },\n    { keys: '<C-w>', type: 'idle', context: 'normal' },\n    { keys: '<C-i>', type: 'action', action: 'jumpListWalk', actionArgs: { forward: true }},\n    { keys: '<C-o>', type: 'action', action: 'jumpListWalk', actionArgs: { forward: false }},\n    { keys: '<C-e>', type: 'action', action: 'scroll', actionArgs: { forward: true, linewise: true }},\n    { keys: '<C-y>', type: 'action', action: 'scroll', actionArgs: { forward: false, linewise: true }},\n    { keys: 'a', type: 'action', action: 'enterInsertMode', isEdit: true, actionArgs: { insertAt: 'charAfter' }, context: 'normal' },\n    { keys: 'A', type: 'action', action: 'enterInsertMode', isEdit: true, actionArgs: { insertAt: 'eol' }, context: 'normal' },\n    { keys: 'A', type: 'action', action: 'enterInsertMode', isEdit: true, actionArgs: { insertAt: 'endOfSelectedArea' }, context: 'visual' },\n    { keys: 'i', type: 'action', action: 'enterInsertMode', isEdit: true, actionArgs: { insertAt: 'inplace' }, context: 'normal' },\n    { keys: 'gi', type: 'action', action: 'enterInsertMode', isEdit: true, actionArgs: { insertAt: 'lastEdit' }, context: 'normal' },\n    { keys: 'I', type: 'action', action: 'enterInsertMode', isEdit: true, actionArgs: { insertAt: 'firstNonBlank'}, context: 'normal' },\n    { keys: 'gI', type: 'action', action: 'enterInsertMode', isEdit: true, actionArgs: { insertAt: 'bol'}, context: 'normal' },\n    { keys: 'I', type: 'action', action: 'enterInsertMode', isEdit: true, actionArgs: { insertAt: 'startOfSelectedArea' }, context: 'visual' },\n    { keys: 'o', type: 'action', action: 'newLineAndEnterInsertMode', isEdit: true, interlaceInsertRepeat: true, actionArgs: { after: true }, context: 'normal' },\n    { keys: 'O', type: 'action', action: 'newLineAndEnterInsertMode', isEdit: true, interlaceInsertRepeat: true, actionArgs: { after: false }, context: 'normal' },\n    { keys: 'v', type: 'action', action: 'toggleVisualMode' },\n    { keys: 'V', type: 'action', action: 'toggleVisualMode', actionArgs: { linewise: true }},\n    { keys: '<C-v>', type: 'action', action: 'toggleVisualMode', actionArgs: { blockwise: true }},\n    { keys: '<C-q>', type: 'action', action: 'toggleVisualMode', actionArgs: { blockwise: true }},\n    { keys: 'gv', type: 'action', action: 'reselectLastSelection' },\n    { keys: 'J', type: 'action', action: 'joinLines', isEdit: true },\n    { keys: 'gJ', type: 'action', action: 'joinLines', actionArgs: { keepSpaces: true }, isEdit: true },\n    { keys: 'p', type: 'action', action: 'paste', isEdit: true, actionArgs: { after: true, isEdit: true }},\n    { keys: 'P', type: 'action', action: 'paste', isEdit: true, actionArgs: { after: false, isEdit: true }},\n    { keys: 'r<character>', type: 'action', action: 'replace', isEdit: true },\n    { keys: '@<character>', type: 'action', action: 'replayMacro' },\n    { keys: 'q<character>', type: 'action', action: 'enterMacroRecordMode' },\n    { keys: 'R', type: 'action', action: 'enterInsertMode', isEdit: true, actionArgs: { replace: true }, context: 'normal'},\n    { keys: 'R', type: 'operator', operator: 'change', operatorArgs: { linewise: true, fullLine: true }, context: 'visual', exitVisualBlock: true},\n    { keys: 'u', type: 'action', action: 'undo', context: 'normal' },\n    { keys: 'u', type: 'operator', operator: 'changeCase', operatorArgs: {toLower: true}, context: 'visual', isEdit: true },\n    { keys: 'U', type: 'operator', operator: 'changeCase', operatorArgs: {toLower: false}, context: 'visual', isEdit: true },\n    { keys: '<C-r>', type: 'action', action: 'redo' },\n    { keys: 'm<character>', type: 'action', action: 'setMark' },\n    { keys: '\"<character>', type: 'action', action: 'setRegister' },\n    { keys: 'zz', type: 'action', action: 'scrollToCursor', actionArgs: { position: 'center' }},\n    { keys: 'z.', type: 'action', action: 'scrollToCursor', actionArgs: { position: 'center' }, motion: 'moveToFirstNonWhiteSpaceCharacter' },\n    { keys: 'zt', type: 'action', action: 'scrollToCursor', actionArgs: { position: 'top' }},\n    { keys: 'z<CR>', type: 'action', action: 'scrollToCursor', actionArgs: { position: 'top' }, motion: 'moveToFirstNonWhiteSpaceCharacter' },\n    { keys: 'z-', type: 'action', action: 'scrollToCursor', actionArgs: { position: 'bottom' }},\n    { keys: 'zb', type: 'action', action: 'scrollToCursor', actionArgs: { position: 'bottom' }, motion: 'moveToFirstNonWhiteSpaceCharacter' },\n    { keys: '.', type: 'action', action: 'repeatLastEdit' },\n    { keys: '<C-a>', type: 'action', action: 'incrementNumberToken', isEdit: true, actionArgs: {increase: true, backtrack: false}},\n    { keys: '<C-x>', type: 'action', action: 'incrementNumberToken', isEdit: true, actionArgs: {increase: false, backtrack: false}},\n    { keys: '<C-t>', type: 'action', action: 'indent', actionArgs: { indentRight: true }, context: 'insert' },\n    { keys: '<C-d>', type: 'action', action: 'indent', actionArgs: { indentRight: false }, context: 'insert' },\n    { keys: 'a<character>', type: 'motion', motion: 'textObjectManipulation' },\n    { keys: 'i<character>', type: 'motion', motion: 'textObjectManipulation', motionArgs: { textObjectInner: true }},\n    { keys: '/', type: 'search', searchArgs: { forward: true, querySrc: 'prompt', toJumplist: true }},\n    { keys: '?', type: 'search', searchArgs: { forward: false, querySrc: 'prompt', toJumplist: true }},\n    { keys: '*', type: 'search', searchArgs: { forward: true, querySrc: 'wordUnderCursor', wholeWordOnly: true, toJumplist: true }},\n    { keys: '#', type: 'search', searchArgs: { forward: false, querySrc: 'wordUnderCursor', wholeWordOnly: true, toJumplist: true }},\n    { keys: 'g*', type: 'search', searchArgs: { forward: true, querySrc: 'wordUnderCursor', toJumplist: true }},\n    { keys: 'g#', type: 'search', searchArgs: { forward: false, querySrc: 'wordUnderCursor', toJumplist: true }},\n    { keys: ':', type: 'ex' }\n  ];\n  var defaultKeymapLength = defaultKeymap.length;\n  var defaultExCommandMap = [\n    { name: 'colorscheme', shortName: 'colo' },\n    { name: 'map' },\n    { name: 'imap', shortName: 'im' },\n    { name: 'nmap', shortName: 'nm' },\n    { name: 'vmap', shortName: 'vm' },\n    { name: 'unmap' },\n    { name: 'write', shortName: 'w' },\n    { name: 'undo', shortName: 'u' },\n    { name: 'redo', shortName: 'red' },\n    { name: 'set', shortName: 'se' },\n    { name: 'set', shortName: 'se' },\n    { name: 'setlocal', shortName: 'setl' },\n    { name: 'setglobal', shortName: 'setg' },\n    { name: 'sort', shortName: 'sor' },\n    { name: 'substitute', shortName: 's', possiblyAsync: true },\n    { name: 'nohlsearch', shortName: 'noh' },\n    { name: 'yank', shortName: 'y' },\n    { name: 'delmarks', shortName: 'delm' },\n    { name: 'registers', shortName: 'reg', excludeFromCommandHistory: true },\n    { name: 'global', shortName: 'g' }\n  ];\n\n  var Pos = CodeMirror.Pos;\n\n  var Vim = function() { return vimApi; } //{\n    function enterVimMode(cm) {\n      cm.setOption('disableInput', true);\n      cm.setOption('showCursorWhenSelecting', false);\n      CodeMirror.signal(cm, \"vim-mode-change\", {mode: \"normal\"});\n      cm.on('cursorActivity', onCursorActivity);\n      maybeInitVimState(cm);\n      CodeMirror.on(cm.getInputField(), 'paste', getOnPasteFn(cm));\n    }\n\n    function leaveVimMode(cm) {\n      cm.setOption('disableInput', false);\n      cm.off('cursorActivity', onCursorActivity);\n      CodeMirror.off(cm.getInputField(), 'paste', getOnPasteFn(cm));\n      cm.state.vim = null;\n    }\n    function detachVimMap(cm, next) {\n      if (this == CodeMirror.keyMap.vim)\n        CodeMirror.rmClass(cm.getWrapperElement(), \"cm-fat-cursor\");\n\n      if (!next || next.attach != attachVimMap)\n        leaveVimMode(cm);\n    }\n    function attachVimMap(cm, prev) {\n      if (this == CodeMirror.keyMap.vim)\n        CodeMirror.addClass(cm.getWrapperElement(), \"cm-fat-cursor\");\n\n      if (!prev || prev.attach != attachVimMap)\n        enterVimMode(cm);\n    }\n    CodeMirror.defineOption('vimMode', false, function(cm, val, prev) {\n      if (val && cm.getOption(\"keyMap\") != \"vim\")\n        cm.setOption(\"keyMap\", \"vim\");\n      else if (!val && prev != CodeMirror.Init && /^vim/.test(cm.getOption(\"keyMap\")))\n        cm.setOption(\"keyMap\", \"default\");\n    });\n\n    function cmKey(key, cm) {\n      if (!cm) { return undefined; }\n      if (this[key]) { return this[key]; }\n      var vimKey = cmKeyToVimKey(key);\n      if (!vimKey) {\n        return false;\n      }\n      var cmd = CodeMirror.Vim.findKey(cm, vimKey);\n      if (typeof cmd == 'function') {\n        CodeMirror.signal(cm, 'vim-keypress', vimKey);\n      }\n      return cmd;\n    }\n\n    var modifiers = {'Shift': 'S', 'Ctrl': 'C', 'Alt': 'A', 'Cmd': 'D', 'Mod': 'A'};\n    var specialKeys = {Enter:'CR',Backspace:'BS',Delete:'Del',Insert:'Ins'};\n    function cmKeyToVimKey(key) {\n      if (key.charAt(0) == '\\'') {\n        return key.charAt(1);\n      }\n      var pieces = key.split(/-(?!$)/);\n      var lastPiece = pieces[pieces.length - 1];\n      if (pieces.length == 1 && pieces[0].length == 1) {\n        return false;\n      } else if (pieces.length == 2 && pieces[0] == 'Shift' && lastPiece.length == 1) {\n        return false;\n      }\n      var hasCharacter = false;\n      for (var i = 0; i < pieces.length; i++) {\n        var piece = pieces[i];\n        if (piece in modifiers) { pieces[i] = modifiers[piece]; }\n        else { hasCharacter = true; }\n        if (piece in specialKeys) { pieces[i] = specialKeys[piece]; }\n      }\n      if (!hasCharacter) {\n        return false;\n      }\n      if (isUpperCase(lastPiece)) {\n        pieces[pieces.length - 1] = lastPiece.toLowerCase();\n      }\n      return '<' + pieces.join('-') + '>';\n    }\n\n    function getOnPasteFn(cm) {\n      var vim = cm.state.vim;\n      if (!vim.onPasteFn) {\n        vim.onPasteFn = function() {\n          if (!vim.insertMode) {\n            cm.setCursor(offsetCursor(cm.getCursor(), 0, 1));\n            actions.enterInsertMode(cm, {}, vim);\n          }\n        };\n      }\n      return vim.onPasteFn;\n    }\n\n    var numberRegex = /[\\d]/;\n    var wordCharTest = [CodeMirror.isWordChar, function(ch) {\n      return ch && !CodeMirror.isWordChar(ch) && !/\\s/.test(ch);\n    }], bigWordCharTest = [function(ch) {\n      return /\\S/.test(ch);\n    }];\n    function makeKeyRange(start, size) {\n      var keys = [];\n      for (var i = start; i < start + size; i++) {\n        keys.push(String.fromCharCode(i));\n      }\n      return keys;\n    }\n    var upperCaseAlphabet = makeKeyRange(65, 26);\n    var lowerCaseAlphabet = makeKeyRange(97, 26);\n    var numbers = makeKeyRange(48, 10);\n    var validMarks = [].concat(upperCaseAlphabet, lowerCaseAlphabet, numbers, ['<', '>']);\n    var validRegisters = [].concat(upperCaseAlphabet, lowerCaseAlphabet, numbers, ['-', '\"', '.', ':', '/']);\n\n    function isLine(cm, line) {\n      return line >= cm.firstLine() && line <= cm.lastLine();\n    }\n    function isLowerCase(k) {\n      return (/^[a-z]$/).test(k);\n    }\n    function isMatchableSymbol(k) {\n      return '()[]{}'.indexOf(k) != -1;\n    }\n    function isNumber(k) {\n      return numberRegex.test(k);\n    }\n    function isUpperCase(k) {\n      return (/^[A-Z]$/).test(k);\n    }\n    function isWhiteSpaceString(k) {\n      return (/^\\s*$/).test(k);\n    }\n    function isEndOfSentenceSymbol(k) {\n      return '.?!'.indexOf(k) != -1;\n    }\n    function inArray(val, arr) {\n      for (var i = 0; i < arr.length; i++) {\n        if (arr[i] == val) {\n          return true;\n        }\n      }\n      return false;\n    }\n\n    var options = {};\n    function defineOption(name, defaultValue, type, aliases, callback) {\n      if (defaultValue === undefined && !callback) {\n        throw Error('defaultValue is required unless callback is provided');\n      }\n      if (!type) { type = 'string'; }\n      options[name] = {\n        type: type,\n        defaultValue: defaultValue,\n        callback: callback\n      };\n      if (aliases) {\n        for (var i = 0; i < aliases.length; i++) {\n          options[aliases[i]] = options[name];\n        }\n      }\n      if (defaultValue) {\n        setOption(name, defaultValue);\n      }\n    }\n\n    function setOption(name, value, cm, cfg) {\n      var option = options[name];\n      cfg = cfg || {};\n      var scope = cfg.scope;\n      if (!option) {\n        return new Error('Unknown option: ' + name);\n      }\n      if (option.type == 'boolean') {\n        if (value && value !== true) {\n          return new Error('Invalid argument: ' + name + '=' + value);\n        } else if (value !== false) {\n          value = true;\n        }\n      }\n      if (option.callback) {\n        if (scope !== 'local') {\n          option.callback(value, undefined);\n        }\n        if (scope !== 'global' && cm) {\n          option.callback(value, cm);\n        }\n      } else {\n        if (scope !== 'local') {\n          option.value = option.type == 'boolean' ? !!value : value;\n        }\n        if (scope !== 'global' && cm) {\n          cm.state.vim.options[name] = {value: value};\n        }\n      }\n    }\n\n    function getOption(name, cm, cfg) {\n      var option = options[name];\n      cfg = cfg || {};\n      var scope = cfg.scope;\n      if (!option) {\n        return new Error('Unknown option: ' + name);\n      }\n      if (option.callback) {\n        var local = cm && option.callback(undefined, cm);\n        if (scope !== 'global' && local !== undefined) {\n          return local;\n        }\n        if (scope !== 'local') {\n          return option.callback();\n        }\n        return;\n      } else {\n        var local = (scope !== 'global') && (cm && cm.state.vim.options[name]);\n        return (local || (scope !== 'local') && option || {}).value;\n      }\n    }\n\n    defineOption('filetype', undefined, 'string', ['ft'], function(name, cm) {\n      if (cm === undefined) {\n        return;\n      }\n      if (name === undefined) {\n        var mode = cm.getOption('mode');\n        return mode == 'null' ? '' : mode;\n      } else {\n        var mode = name == '' ? 'null' : name;\n        cm.setOption('mode', mode);\n      }\n    });\n\n    var createCircularJumpList = function() {\n      var size = 100;\n      var pointer = -1;\n      var head = 0;\n      var tail = 0;\n      var buffer = new Array(size);\n      function add(cm, oldCur, newCur) {\n        var current = pointer % size;\n        var curMark = buffer[current];\n        function useNextSlot(cursor) {\n          var next = ++pointer % size;\n          var trashMark = buffer[next];\n          if (trashMark) {\n            trashMark.clear();\n          }\n          buffer[next] = cm.setBookmark(cursor);\n        }\n        if (curMark) {\n          var markPos = curMark.find();\n          if (markPos && !cursorEqual(markPos, oldCur)) {\n            useNextSlot(oldCur);\n          }\n        } else {\n          useNextSlot(oldCur);\n        }\n        useNextSlot(newCur);\n        head = pointer;\n        tail = pointer - size + 1;\n        if (tail < 0) {\n          tail = 0;\n        }\n      }\n      function move(cm, offset) {\n        pointer += offset;\n        if (pointer > head) {\n          pointer = head;\n        } else if (pointer < tail) {\n          pointer = tail;\n        }\n        var mark = buffer[(size + pointer) % size];\n        if (mark && !mark.find()) {\n          var inc = offset > 0 ? 1 : -1;\n          var newCur;\n          var oldCur = cm.getCursor();\n          do {\n            pointer += inc;\n            mark = buffer[(size + pointer) % size];\n            if (mark &&\n                (newCur = mark.find()) &&\n                !cursorEqual(oldCur, newCur)) {\n              break;\n            }\n          } while (pointer < head && pointer > tail);\n        }\n        return mark;\n      }\n      function find(cm, offset) {\n        var oldPointer = pointer;\n        var mark = move(cm, offset);\n        pointer = oldPointer;\n        return mark && mark.find();\n      }\n      return {\n        cachedCursor: undefined, //used for # and * jumps\n        add: add,\n        find: find,\n        move: move\n      };\n    };\n    var createInsertModeChanges = function(c) {\n      if (c) {\n        return {\n          changes: c.changes,\n          expectCursorActivityForChange: c.expectCursorActivityForChange\n        };\n      }\n      return {\n        changes: [],\n        expectCursorActivityForChange: false\n      };\n    };\n\n    function MacroModeState() {\n      this.latestRegister = undefined;\n      this.isPlaying = false;\n      this.isRecording = false;\n      this.replaySearchQueries = [];\n      this.onRecordingDone = undefined;\n      this.lastInsertModeChanges = createInsertModeChanges();\n    }\n    MacroModeState.prototype = {\n      exitMacroRecordMode: function() {\n        var macroModeState = vimGlobalState.macroModeState;\n        if (macroModeState.onRecordingDone) {\n          macroModeState.onRecordingDone(); // close dialog\n        }\n        macroModeState.onRecordingDone = undefined;\n        macroModeState.isRecording = false;\n      },\n      enterMacroRecordMode: function(cm, registerName) {\n        var register =\n            vimGlobalState.registerController.getRegister(registerName);\n        if (register) {\n          register.clear();\n          this.latestRegister = registerName;\n          if (cm.openDialog) {\n            this.onRecordingDone = cm.openDialog(\n                '(recording)['+registerName+']', null, {bottom:true});\n          }\n          this.isRecording = true;\n        }\n      }\n    };\n\n    function maybeInitVimState(cm) {\n      if (!cm.state.vim) {\n        cm.state.vim = {\n          inputState: new InputState(),\n          lastEditInputState: undefined,\n          lastEditActionCommand: undefined,\n          lastHPos: -1,\n          lastHSPos: -1,\n          lastMotion: null,\n          marks: {},\n          fakeCursor: null,\n          insertMode: false,\n          insertModeRepeat: undefined,\n          visualMode: false,\n          visualLine: false,\n          visualBlock: false,\n          lastSelection: null,\n          lastPastedText: null,\n          sel: {},\n          options: {}\n        };\n      }\n      return cm.state.vim;\n    }\n    var vimGlobalState;\n    function resetVimGlobalState() {\n      vimGlobalState = {\n        searchQuery: null,\n        searchIsReversed: false,\n        lastSubstituteReplacePart: undefined,\n        jumpList: createCircularJumpList(),\n        macroModeState: new MacroModeState,\n        lastCharacterSearch: {increment:0, forward:true, selectedCharacter:''},\n        registerController: new RegisterController({}),\n        searchHistoryController: new HistoryController(),\n        exCommandHistoryController : new HistoryController()\n      };\n      for (var optionName in options) {\n        var option = options[optionName];\n        option.value = option.defaultValue;\n      }\n    }\n\n    var lastInsertModeKeyTimer;\n    var vimApi= {\n      buildKeyMap: function() {\n      },\n      getRegisterController: function() {\n        return vimGlobalState.registerController;\n      },\n      resetVimGlobalState_: resetVimGlobalState,\n      getVimGlobalState_: function() {\n        return vimGlobalState;\n      },\n      maybeInitVimState_: maybeInitVimState,\n\n      suppressErrorLogging: false,\n\n      InsertModeKey: InsertModeKey,\n      map: function(lhs, rhs, ctx) {\n        exCommandDispatcher.map(lhs, rhs, ctx);\n      },\n      unmap: function(lhs, ctx) {\n        exCommandDispatcher.unmap(lhs, ctx);\n      },\n      noremap: function(lhs, rhs, ctx) {\n        function toCtxArray(ctx) {\n          return ctx ? [ctx] : ['normal', 'insert', 'visual'];\n        }\n        var ctxsToMap = toCtxArray(ctx);\n        var actualLength = defaultKeymap.length, origLength = defaultKeymapLength;\n        for (var i = actualLength - origLength;\n             i < actualLength && ctxsToMap.length;\n             i++) {\n          var mapping = defaultKeymap[i];\n          if (mapping.keys == rhs &&\n              (!ctx || !mapping.context || mapping.context === ctx) &&\n              mapping.type.substr(0, 2) !== 'ex' &&\n              mapping.type.substr(0, 3) !== 'key') {\n            var newMapping = {};\n            for (var key in mapping) {\n              newMapping[key] = mapping[key];\n            }\n            newMapping.keys = lhs;\n            if (ctx && !newMapping.context) {\n              newMapping.context = ctx;\n            }\n            this._mapCommand(newMapping);\n            var mappedCtxs = toCtxArray(mapping.context);\n            ctxsToMap = ctxsToMap.filter(function(el) { return mappedCtxs.indexOf(el) === -1; });\n          }\n        }\n      },\n      mapclear: function(ctx) {\n        var actualLength = defaultKeymap.length,\n            origLength = defaultKeymapLength;\n        var userKeymap = defaultKeymap.slice(0, actualLength - origLength);\n        defaultKeymap = defaultKeymap.slice(actualLength - origLength);\n        if (ctx) {\n          for (var i = userKeymap.length - 1; i >= 0; i--) {\n            var mapping = userKeymap[i];\n            if (ctx !== mapping.context) {\n              if (mapping.context) {\n                this._mapCommand(mapping);\n              } else {\n                var contexts = ['normal', 'insert', 'visual'];\n                for (var j in contexts) {\n                  if (contexts[j] !== ctx) {\n                    var newMapping = {};\n                    for (var key in mapping) {\n                      newMapping[key] = mapping[key];\n                    }\n                    newMapping.context = contexts[j];\n                    this._mapCommand(newMapping);\n                  }\n                }\n              }\n            }\n          }\n        }\n      },\n      setOption: setOption,\n      getOption: getOption,\n      defineOption: defineOption,\n      defineEx: function(name, prefix, func){\n        if (!prefix) {\n          prefix = name;\n        } else if (name.indexOf(prefix) !== 0) {\n          throw new Error('(Vim.defineEx) \"'+prefix+'\" is not a prefix of \"'+name+'\", command not registered');\n        }\n        exCommands[name]=func;\n        exCommandDispatcher.commandMap_[prefix]={name:name, shortName:prefix, type:'api'};\n      },\n      handleKey: function (cm, key, origin) {\n        var command = this.findKey(cm, key, origin);\n        if (typeof command === 'function') {\n          return command();\n        }\n      },\n      findKey: function(cm, key, origin) {\n        var vim = maybeInitVimState(cm);\n        function handleMacroRecording() {\n          var macroModeState = vimGlobalState.macroModeState;\n          if (macroModeState.isRecording) {\n            if (key == 'q') {\n              macroModeState.exitMacroRecordMode();\n              clearInputState(cm);\n              return true;\n            }\n            if (origin != 'mapping') {\n              logKey(macroModeState, key);\n            }\n          }\n        }\n        function handleEsc() {\n          if (key == '<Esc>') {\n            clearInputState(cm);\n            if (vim.visualMode) {\n              exitVisualMode(cm);\n            } else if (vim.insertMode) {\n              exitInsertMode(cm);\n            }\n            return true;\n          }\n        }\n        function doKeyToKey(keys) {\n          var match;\n          while (keys) {\n            match = (/<\\w+-.+?>|<\\w+>|./).exec(keys);\n            key = match[0];\n            keys = keys.substring(match.index + key.length);\n            CodeMirror.Vim.handleKey(cm, key, 'mapping');\n          }\n        }\n\n        function handleKeyInsertMode() {\n          if (handleEsc()) { return true; }\n          var keys = vim.inputState.keyBuffer = vim.inputState.keyBuffer + key;\n          var keysAreChars = key.length == 1;\n          var match = commandDispatcher.matchCommand(keys, defaultKeymap, vim.inputState, 'insert');\n          while (keys.length > 1 && match.type != 'full') {\n            var keys = vim.inputState.keyBuffer = keys.slice(1);\n            var thisMatch = commandDispatcher.matchCommand(keys, defaultKeymap, vim.inputState, 'insert');\n            if (thisMatch.type != 'none') { match = thisMatch; }\n          }\n          if (match.type == 'none') { clearInputState(cm); return false; }\n          else if (match.type == 'partial') {\n            if (lastInsertModeKeyTimer) { window.clearTimeout(lastInsertModeKeyTimer); }\n            lastInsertModeKeyTimer = window.setTimeout(\n              function() { if (vim.insertMode && vim.inputState.keyBuffer) { clearInputState(cm); } },\n              getOption('insertModeEscKeysTimeout'));\n            return !keysAreChars;\n          }\n\n          if (lastInsertModeKeyTimer) { window.clearTimeout(lastInsertModeKeyTimer); }\n          if (keysAreChars) {\n            var selections = cm.listSelections();\n            for (var i = 0; i < selections.length; i++) {\n              var here = selections[i].head;\n              cm.replaceRange('', offsetCursor(here, 0, -(keys.length - 1)), here, '+input');\n            }\n            vimGlobalState.macroModeState.lastInsertModeChanges.changes.pop();\n          }\n          clearInputState(cm);\n          return match.command;\n        }\n\n        function handleKeyNonInsertMode() {\n          if (handleMacroRecording() || handleEsc()) { return true; }\n\n          var keys = vim.inputState.keyBuffer = vim.inputState.keyBuffer + key;\n          if (/^[1-9]\\d*$/.test(keys)) { return true; }\n\n          var keysMatcher = /^(\\d*)(.*)$/.exec(keys);\n          if (!keysMatcher) { clearInputState(cm); return false; }\n          var context = vim.visualMode ? 'visual' :\n                                         'normal';\n          var match = commandDispatcher.matchCommand(keysMatcher[2] || keysMatcher[1], defaultKeymap, vim.inputState, context);\n          if (match.type == 'none') { clearInputState(cm); return false; }\n          else if (match.type == 'partial') { return true; }\n\n          vim.inputState.keyBuffer = '';\n          var keysMatcher = /^(\\d*)(.*)$/.exec(keys);\n          if (keysMatcher[1] && keysMatcher[1] != '0') {\n            vim.inputState.pushRepeatDigit(keysMatcher[1]);\n          }\n          return match.command;\n        }\n\n        var command;\n        if (vim.insertMode) { command = handleKeyInsertMode(); }\n        else { command = handleKeyNonInsertMode(); }\n        if (command === false) {\n          return undefined; //ace_patch\n        } else if (command === true) {\n          return function() { return true; };\n        } else {\n          return function() {\n            if ((command.operator || command.isEdit) && cm.getOption('readOnly'))\n              return; // ace_patch\n            return cm.operation(function() {\n              cm.curOp.isVimOp = true;\n              try {\n                if (command.type == 'keyToKey') {\n                  doKeyToKey(command.toKeys);\n                } else {\n                  commandDispatcher.processCommand(cm, vim, command);\n                }\n              } catch (e) {\n                cm.state.vim = undefined;\n                maybeInitVimState(cm);\n                if (!CodeMirror.Vim.suppressErrorLogging) {\n                  console['log'](e);\n                }\n                throw e;\n              }\n              return true;\n            });\n          };\n        }\n      },\n      handleEx: function(cm, input) {\n        exCommandDispatcher.processCommand(cm, input);\n      },\n\n      defineMotion: defineMotion,\n      defineAction: defineAction,\n      defineOperator: defineOperator,\n      mapCommand: mapCommand,\n      _mapCommand: _mapCommand,\n\n      defineRegister: defineRegister,\n\n      exitVisualMode: exitVisualMode,\n      exitInsertMode: exitInsertMode\n    };\n    function InputState() {\n      this.prefixRepeat = [];\n      this.motionRepeat = [];\n\n      this.operator = null;\n      this.operatorArgs = null;\n      this.motion = null;\n      this.motionArgs = null;\n      this.keyBuffer = []; // For matching multi-key commands.\n      this.registerName = null; // Defaults to the unnamed register.\n    }\n    InputState.prototype.pushRepeatDigit = function(n) {\n      if (!this.operator) {\n        this.prefixRepeat = this.prefixRepeat.concat(n);\n      } else {\n        this.motionRepeat = this.motionRepeat.concat(n);\n      }\n    };\n    InputState.prototype.getRepeat = function() {\n      var repeat = 0;\n      if (this.prefixRepeat.length > 0 || this.motionRepeat.length > 0) {\n        repeat = 1;\n        if (this.prefixRepeat.length > 0) {\n          repeat *= parseInt(this.prefixRepeat.join(''), 10);\n        }\n        if (this.motionRepeat.length > 0) {\n          repeat *= parseInt(this.motionRepeat.join(''), 10);\n        }\n      }\n      return repeat;\n    };\n\n    function clearInputState(cm, reason) {\n      cm.state.vim.inputState = new InputState();\n      CodeMirror.signal(cm, 'vim-command-done', reason);\n    }\n    function Register(text, linewise, blockwise) {\n      this.clear();\n      this.keyBuffer = [text || ''];\n      this.insertModeChanges = [];\n      this.searchQueries = [];\n      this.linewise = !!linewise;\n      this.blockwise = !!blockwise;\n    }\n    Register.prototype = {\n      setText: function(text, linewise, blockwise) {\n        this.keyBuffer = [text || ''];\n        this.linewise = !!linewise;\n        this.blockwise = !!blockwise;\n      },\n      pushText: function(text, linewise) {\n        if (linewise) {\n          if (!this.linewise) {\n            this.keyBuffer.push('\\n');\n          }\n          this.linewise = true;\n        }\n        this.keyBuffer.push(text);\n      },\n      pushInsertModeChanges: function(changes) {\n        this.insertModeChanges.push(createInsertModeChanges(changes));\n      },\n      pushSearchQuery: function(query) {\n        this.searchQueries.push(query);\n      },\n      clear: function() {\n        this.keyBuffer = [];\n        this.insertModeChanges = [];\n        this.searchQueries = [];\n        this.linewise = false;\n      },\n      toString: function() {\n        return this.keyBuffer.join('');\n      }\n    };\n    function defineRegister(name, register) {\n      var registers = vimGlobalState.registerController.registers;\n      if (!name || name.length != 1) {\n        throw Error('Register name must be 1 character');\n      }\n      registers[name] = register;\n      validRegisters.push(name);\n    }\n    function RegisterController(registers) {\n      this.registers = registers;\n      this.unnamedRegister = registers['\"'] = new Register();\n      registers['.'] = new Register();\n      registers[':'] = new Register();\n      registers['/'] = new Register();\n    }\n    RegisterController.prototype = {\n      pushText: function(registerName, operator, text, linewise, blockwise) {\n        if (linewise && text.charAt(text.length - 1) !== '\\n'){\n          text += '\\n';\n        }\n        var register = this.isValidRegister(registerName) ?\n            this.getRegister(registerName) : null;\n        if (!register) {\n          switch (operator) {\n            case 'yank':\n              this.registers['0'] = new Register(text, linewise, blockwise);\n              break;\n            case 'delete':\n            case 'change':\n              if (text.indexOf('\\n') == -1) {\n                this.registers['-'] = new Register(text, linewise);\n              } else {\n                this.shiftNumericRegisters_();\n                this.registers['1'] = new Register(text, linewise);\n              }\n              break;\n          }\n          this.unnamedRegister.setText(text, linewise, blockwise);\n          return;\n        }\n        var append = isUpperCase(registerName);\n        if (append) {\n          register.pushText(text, linewise);\n        } else {\n          register.setText(text, linewise, blockwise);\n        }\n        this.unnamedRegister.setText(register.toString(), linewise);\n      },\n      getRegister: function(name) {\n        if (!this.isValidRegister(name)) {\n          return this.unnamedRegister;\n        }\n        name = name.toLowerCase();\n        if (!this.registers[name]) {\n          this.registers[name] = new Register();\n        }\n        return this.registers[name];\n      },\n      isValidRegister: function(name) {\n        return name && inArray(name, validRegisters);\n      },\n      shiftNumericRegisters_: function() {\n        for (var i = 9; i >= 2; i--) {\n          this.registers[i] = this.getRegister('' + (i - 1));\n        }\n      }\n    };\n    function HistoryController() {\n        this.historyBuffer = [];\n        this.iterator = 0;\n        this.initialPrefix = null;\n    }\n    HistoryController.prototype = {\n      nextMatch: function (input, up) {\n        var historyBuffer = this.historyBuffer;\n        var dir = up ? -1 : 1;\n        if (this.initialPrefix === null) this.initialPrefix = input;\n        for (var i = this.iterator + dir; up ? i >= 0 : i < historyBuffer.length; i+= dir) {\n          var element = historyBuffer[i];\n          for (var j = 0; j <= element.length; j++) {\n            if (this.initialPrefix == element.substring(0, j)) {\n              this.iterator = i;\n              return element;\n            }\n          }\n        }\n        if (i >= historyBuffer.length) {\n          this.iterator = historyBuffer.length;\n          return this.initialPrefix;\n        }\n        if (i < 0 ) return input;\n      },\n      pushInput: function(input) {\n        var index = this.historyBuffer.indexOf(input);\n        if (index > -1) this.historyBuffer.splice(index, 1);\n        if (input.length) this.historyBuffer.push(input);\n      },\n      reset: function() {\n        this.initialPrefix = null;\n        this.iterator = this.historyBuffer.length;\n      }\n    };\n    var commandDispatcher = {\n      matchCommand: function(keys, keyMap, inputState, context) {\n        var matches = commandMatches(keys, keyMap, context, inputState);\n        if (!matches.full && !matches.partial) {\n          return {type: 'none'};\n        } else if (!matches.full && matches.partial) {\n          return {type: 'partial'};\n        }\n\n        var bestMatch;\n        for (var i = 0; i < matches.full.length; i++) {\n          var match = matches.full[i];\n          if (!bestMatch) {\n            bestMatch = match;\n          }\n        }\n        if (bestMatch.keys.slice(-11) == '<character>') {\n          var character = lastChar(keys);\n          if (/<C-.>/.test(character) || !character) return {type: 'none'}; //ace_patch\n          inputState.selectedCharacter = character;\n        }\n        return {type: 'full', command: bestMatch};\n      },\n      processCommand: function(cm, vim, command) {\n        vim.inputState.repeatOverride = command.repeatOverride;\n        switch (command.type) {\n          case 'motion':\n            this.processMotion(cm, vim, command);\n            break;\n          case 'operator':\n            this.processOperator(cm, vim, command);\n            break;\n          case 'operatorMotion':\n            this.processOperatorMotion(cm, vim, command);\n            break;\n          case 'action':\n            this.processAction(cm, vim, command);\n            break;\n          case 'search':\n            this.processSearch(cm, vim, command);\n            break;\n          case 'ex':\n          case 'keyToEx':\n            this.processEx(cm, vim, command);\n            break;\n          default:\n            break;\n        }\n      },\n      processMotion: function(cm, vim, command) {\n        vim.inputState.motion = command.motion;\n        vim.inputState.motionArgs = copyArgs(command.motionArgs);\n        this.evalInput(cm, vim);\n      },\n      processOperator: function(cm, vim, command) {\n        var inputState = vim.inputState;\n        if (inputState.operator) {\n          if (inputState.operator == command.operator) {\n            inputState.motion = 'expandToLine';\n            inputState.motionArgs = { linewise: true };\n            this.evalInput(cm, vim);\n            return;\n          } else {\n            clearInputState(cm);\n          }\n        }\n        inputState.operator = command.operator;\n        inputState.operatorArgs = copyArgs(command.operatorArgs);\n        if (command.exitVisualBlock) {\n            vim.visualBlock = false;\n            updateCmSelection(cm);\n        }\n        if (vim.visualMode) {\n          this.evalInput(cm, vim);\n        }\n      },\n      processOperatorMotion: function(cm, vim, command) {\n        var visualMode = vim.visualMode;\n        var operatorMotionArgs = copyArgs(command.operatorMotionArgs);\n        if (operatorMotionArgs) {\n          if (visualMode && operatorMotionArgs.visualLine) {\n            vim.visualLine = true;\n          }\n        }\n        this.processOperator(cm, vim, command);\n        if (!visualMode) {\n          this.processMotion(cm, vim, command);\n        }\n      },\n      processAction: function(cm, vim, command) {\n        var inputState = vim.inputState;\n        var repeat = inputState.getRepeat();\n        var repeatIsExplicit = !!repeat;\n        var actionArgs = copyArgs(command.actionArgs) || {};\n        if (inputState.selectedCharacter) {\n          actionArgs.selectedCharacter = inputState.selectedCharacter;\n        }\n        if (command.operator) {\n          this.processOperator(cm, vim, command);\n        }\n        if (command.motion) {\n          this.processMotion(cm, vim, command);\n        }\n        if (command.motion || command.operator) {\n          this.evalInput(cm, vim);\n        }\n        actionArgs.repeat = repeat || 1;\n        actionArgs.repeatIsExplicit = repeatIsExplicit;\n        actionArgs.registerName = inputState.registerName;\n        clearInputState(cm);\n        vim.lastMotion = null;\n        if (command.isEdit) {\n          this.recordLastEdit(vim, inputState, command);\n        }\n        actions[command.action](cm, actionArgs, vim);\n      },\n      processSearch: function(cm, vim, command) {\n        if (!cm.getSearchCursor) {\n          return;\n        }\n        var forward = command.searchArgs.forward;\n        var wholeWordOnly = command.searchArgs.wholeWordOnly;\n        getSearchState(cm).setReversed(!forward);\n        var promptPrefix = (forward) ? '/' : '?';\n        var originalQuery = getSearchState(cm).getQuery();\n        var originalScrollPos = cm.getScrollInfo();\n        function handleQuery(query, ignoreCase, smartCase) {\n          vimGlobalState.searchHistoryController.pushInput(query);\n          vimGlobalState.searchHistoryController.reset();\n          try {\n            updateSearchQuery(cm, query, ignoreCase, smartCase);\n          } catch (e) {\n            showConfirm(cm, 'Invalid regex: ' + query);\n            clearInputState(cm);\n            return;\n          }\n          commandDispatcher.processMotion(cm, vim, {\n            type: 'motion',\n            motion: 'findNext',\n            motionArgs: { forward: true, toJumplist: command.searchArgs.toJumplist }\n          });\n        }\n        function onPromptClose(query) {\n          cm.scrollTo(originalScrollPos.left, originalScrollPos.top);\n          handleQuery(query, true /** ignoreCase */, true /** smartCase */);\n          var macroModeState = vimGlobalState.macroModeState;\n          if (macroModeState.isRecording) {\n            logSearchQuery(macroModeState, query);\n          }\n        }\n        function onPromptKeyUp(e, query, close) {\n          var keyName = CodeMirror.keyName(e), up, offset;\n          if (keyName == 'Up' || keyName == 'Down') {\n            up = keyName == 'Up' ? true : false;\n            offset = e.target ? e.target.selectionEnd : 0;\n            query = vimGlobalState.searchHistoryController.nextMatch(query, up) || '';\n            close(query);\n            if (offset && e.target) e.target.selectionEnd = e.target.selectionStart = Math.min(offset, e.target.value.length);\n          } else {\n            if ( keyName != 'Left' && keyName != 'Right' && keyName != 'Ctrl' && keyName != 'Alt' && keyName != 'Shift')\n              vimGlobalState.searchHistoryController.reset();\n          }\n          var parsedQuery;\n          try {\n            parsedQuery = updateSearchQuery(cm, query,\n                true /** ignoreCase */, true /** smartCase */);\n          } catch (e) {\n          }\n          if (parsedQuery) {\n            cm.scrollIntoView(findNext(cm, !forward, parsedQuery), 30);\n          } else {\n            clearSearchHighlight(cm);\n            cm.scrollTo(originalScrollPos.left, originalScrollPos.top);\n          }\n        }\n        function onPromptKeyDown(e, query, close) {\n          var keyName = CodeMirror.keyName(e);\n          if (keyName == 'Esc' || keyName == 'Ctrl-C' || keyName == 'Ctrl-[' ||\n              (keyName == 'Backspace' && query == '')) {\n            vimGlobalState.searchHistoryController.pushInput(query);\n            vimGlobalState.searchHistoryController.reset();\n            updateSearchQuery(cm, originalQuery);\n            clearSearchHighlight(cm);\n            cm.scrollTo(originalScrollPos.left, originalScrollPos.top);\n            CodeMirror.e_stop(e);\n            clearInputState(cm);\n            close();\n            cm.focus();\n          } else if (keyName == 'Up' || keyName == 'Down') {\n            CodeMirror.e_stop(e);\n          } else if (keyName == 'Ctrl-U') {\n            CodeMirror.e_stop(e);\n            close('');\n          }\n        }\n        switch (command.searchArgs.querySrc) {\n          case 'prompt':\n            var macroModeState = vimGlobalState.macroModeState;\n            if (macroModeState.isPlaying) {\n              var query = macroModeState.replaySearchQueries.shift();\n              handleQuery(query, true /** ignoreCase */, false /** smartCase */);\n            } else {\n              showPrompt(cm, {\n                  onClose: onPromptClose,\n                  prefix: promptPrefix,\n                  desc: searchPromptDesc,\n                  onKeyUp: onPromptKeyUp,\n                  onKeyDown: onPromptKeyDown\n              });\n            }\n            break;\n          case 'wordUnderCursor':\n            var word = expandWordUnderCursor(cm, false /** inclusive */,\n                true /** forward */, false /** bigWord */,\n                true /** noSymbol */);\n            var isKeyword = true;\n            if (!word) {\n              word = expandWordUnderCursor(cm, false /** inclusive */,\n                  true /** forward */, false /** bigWord */,\n                  false /** noSymbol */);\n              isKeyword = false;\n            }\n            if (!word) {\n              return;\n            }\n            var query = cm.getLine(word.start.line).substring(word.start.ch,\n                word.end.ch);\n            if (isKeyword && wholeWordOnly) {\n                query = '\\\\b' + query + '\\\\b';\n            } else {\n              query = escapeRegex(query);\n            }\n            vimGlobalState.jumpList.cachedCursor = cm.getCursor();\n            cm.setCursor(word.start);\n\n            handleQuery(query, true /** ignoreCase */, false /** smartCase */);\n            break;\n        }\n      },\n      processEx: function(cm, vim, command) {\n        function onPromptClose(input) {\n          vimGlobalState.exCommandHistoryController.pushInput(input);\n          vimGlobalState.exCommandHistoryController.reset();\n          exCommandDispatcher.processCommand(cm, input);\n        }\n        function onPromptKeyDown(e, input, close) {\n          var keyName = CodeMirror.keyName(e), up, offset;\n          if (keyName == 'Esc' || keyName == 'Ctrl-C' || keyName == 'Ctrl-[' ||\n              (keyName == 'Backspace' && input == '')) {\n            vimGlobalState.exCommandHistoryController.pushInput(input);\n            vimGlobalState.exCommandHistoryController.reset();\n            CodeMirror.e_stop(e);\n            clearInputState(cm);\n            close();\n            cm.focus();\n          }\n          if (keyName == 'Up' || keyName == 'Down') {\n            CodeMirror.e_stop(e);\n            up = keyName == 'Up' ? true : false;\n            offset = e.target ? e.target.selectionEnd : 0;\n            input = vimGlobalState.exCommandHistoryController.nextMatch(input, up) || '';\n            close(input);\n            if (offset && e.target) e.target.selectionEnd = e.target.selectionStart = Math.min(offset, e.target.value.length);\n          } else if (keyName == 'Ctrl-U') {\n            CodeMirror.e_stop(e);\n            close('');\n          } else {\n            if ( keyName != 'Left' && keyName != 'Right' && keyName != 'Ctrl' && keyName != 'Alt' && keyName != 'Shift')\n              vimGlobalState.exCommandHistoryController.reset();\n          }\n        }\n        if (command.type == 'keyToEx') {\n          exCommandDispatcher.processCommand(cm, command.exArgs.input);\n        } else {\n          if (vim.visualMode) {\n            showPrompt(cm, { onClose: onPromptClose, prefix: ':', value: '\\'<,\\'>',\n                onKeyDown: onPromptKeyDown, selectValueOnOpen: false});\n          } else {\n            showPrompt(cm, { onClose: onPromptClose, prefix: ':',\n                onKeyDown: onPromptKeyDown});\n          }\n        }\n      },\n      evalInput: function(cm, vim) {\n        var inputState = vim.inputState;\n        var motion = inputState.motion;\n        var motionArgs = inputState.motionArgs || {};\n        var operator = inputState.operator;\n        var operatorArgs = inputState.operatorArgs || {};\n        var registerName = inputState.registerName;\n        var sel = vim.sel;\n        var origHead = copyCursor(vim.visualMode ? clipCursorToContent(cm, sel.head): cm.getCursor('head'));\n        var origAnchor = copyCursor(vim.visualMode ? clipCursorToContent(cm, sel.anchor) : cm.getCursor('anchor'));\n        var oldHead = copyCursor(origHead);\n        var oldAnchor = copyCursor(origAnchor);\n        var newHead, newAnchor;\n        var repeat;\n        if (operator) {\n          this.recordLastEdit(vim, inputState);\n        }\n        if (inputState.repeatOverride !== undefined) {\n          repeat = inputState.repeatOverride;\n        } else {\n          repeat = inputState.getRepeat();\n        }\n        if (repeat > 0 && motionArgs.explicitRepeat) {\n          motionArgs.repeatIsExplicit = true;\n        } else if (motionArgs.noRepeat ||\n            (!motionArgs.explicitRepeat && repeat === 0)) {\n          repeat = 1;\n          motionArgs.repeatIsExplicit = false;\n        }\n        if (inputState.selectedCharacter) {\n          motionArgs.selectedCharacter = operatorArgs.selectedCharacter =\n              inputState.selectedCharacter;\n        }\n        motionArgs.repeat = repeat;\n        clearInputState(cm);\n        if (motion) {\n          var motionResult = motions[motion](cm, origHead, motionArgs, vim);\n          vim.lastMotion = motions[motion];\n          if (!motionResult) {\n            return;\n          }\n          if (motionArgs.toJumplist) {\n            if (!operator && cm.ace.curOp != null)\n              cm.ace.curOp.command.scrollIntoView = \"center-animate\"; // ace_patch\n            var jumpList = vimGlobalState.jumpList;\n            var cachedCursor = jumpList.cachedCursor;\n            if (cachedCursor) {\n              recordJumpPosition(cm, cachedCursor, motionResult);\n              delete jumpList.cachedCursor;\n            } else {\n              recordJumpPosition(cm, origHead, motionResult);\n            }\n          }\n          if (motionResult instanceof Array) {\n            newAnchor = motionResult[0];\n            newHead = motionResult[1];\n          } else {\n            newHead = motionResult;\n          }\n          if (!newHead) {\n            newHead = copyCursor(origHead);\n          }\n          if (vim.visualMode) {\n            if (!(vim.visualBlock && newHead.ch === Infinity)) {\n              newHead = clipCursorToContent(cm, newHead, vim.visualBlock);\n            }\n            if (newAnchor) {\n              newAnchor = clipCursorToContent(cm, newAnchor, true);\n            }\n            newAnchor = newAnchor || oldAnchor;\n            sel.anchor = newAnchor;\n            sel.head = newHead;\n            updateCmSelection(cm);\n            updateMark(cm, vim, '<',\n                cursorIsBefore(newAnchor, newHead) ? newAnchor\n                    : newHead);\n            updateMark(cm, vim, '>',\n                cursorIsBefore(newAnchor, newHead) ? newHead\n                    : newAnchor);\n          } else if (!operator) {\n            newHead = clipCursorToContent(cm, newHead);\n            cm.setCursor(newHead.line, newHead.ch);\n          }\n        }\n        if (operator) {\n          if (operatorArgs.lastSel) {\n            newAnchor = oldAnchor;\n            var lastSel = operatorArgs.lastSel;\n            var lineOffset = Math.abs(lastSel.head.line - lastSel.anchor.line);\n            var chOffset = Math.abs(lastSel.head.ch - lastSel.anchor.ch);\n            if (lastSel.visualLine) {\n              newHead = Pos(oldAnchor.line + lineOffset, oldAnchor.ch);\n            } else if (lastSel.visualBlock) {\n              newHead = Pos(oldAnchor.line + lineOffset, oldAnchor.ch + chOffset);\n            } else if (lastSel.head.line == lastSel.anchor.line) {\n              newHead = Pos(oldAnchor.line, oldAnchor.ch + chOffset);\n            } else {\n              newHead = Pos(oldAnchor.line + lineOffset, oldAnchor.ch);\n            }\n            vim.visualMode = true;\n            vim.visualLine = lastSel.visualLine;\n            vim.visualBlock = lastSel.visualBlock;\n            sel = vim.sel = {\n              anchor: newAnchor,\n              head: newHead\n            };\n            updateCmSelection(cm);\n          } else if (vim.visualMode) {\n            operatorArgs.lastSel = {\n              anchor: copyCursor(sel.anchor),\n              head: copyCursor(sel.head),\n              visualBlock: vim.visualBlock,\n              visualLine: vim.visualLine\n            };\n          }\n          var curStart, curEnd, linewise, mode;\n          var cmSel;\n          if (vim.visualMode) {\n            curStart = cursorMin(sel.head, sel.anchor);\n            curEnd = cursorMax(sel.head, sel.anchor);\n            linewise = vim.visualLine || operatorArgs.linewise;\n            mode = vim.visualBlock ? 'block' :\n                   linewise ? 'line' :\n                   'char';\n            cmSel = makeCmSelection(cm, {\n              anchor: curStart,\n              head: curEnd\n            }, mode);\n            if (linewise) {\n              var ranges = cmSel.ranges;\n              if (mode == 'block') {\n                for (var i = 0; i < ranges.length; i++) {\n                  ranges[i].head.ch = lineLength(cm, ranges[i].head.line);\n                }\n              } else if (mode == 'line') {\n                ranges[0].head = Pos(ranges[0].head.line + 1, 0);\n              }\n            }\n          } else {\n            curStart = copyCursor(newAnchor || oldAnchor);\n            curEnd = copyCursor(newHead || oldHead);\n            if (cursorIsBefore(curEnd, curStart)) {\n              var tmp = curStart;\n              curStart = curEnd;\n              curEnd = tmp;\n            }\n            linewise = motionArgs.linewise || operatorArgs.linewise;\n            if (linewise) {\n              expandSelectionToLine(cm, curStart, curEnd);\n            } else if (motionArgs.forward) {\n              clipToLine(cm, curStart, curEnd);\n            }\n            mode = 'char';\n            var exclusive = !motionArgs.inclusive || linewise;\n            cmSel = makeCmSelection(cm, {\n              anchor: curStart,\n              head: curEnd\n            }, mode, exclusive);\n          }\n          cm.setSelections(cmSel.ranges, cmSel.primary);\n          vim.lastMotion = null;\n          operatorArgs.repeat = repeat; // For indent in visual mode.\n          operatorArgs.registerName = registerName;\n          operatorArgs.linewise = linewise;\n          var operatorMoveTo = operators[operator](\n            cm, operatorArgs, cmSel.ranges, oldAnchor, newHead);\n          if (vim.visualMode) {\n            exitVisualMode(cm, operatorMoveTo != null);\n          }\n          if (operatorMoveTo) {\n            cm.setCursor(operatorMoveTo);\n          }\n        }\n      },\n      recordLastEdit: function(vim, inputState, actionCommand) {\n        var macroModeState = vimGlobalState.macroModeState;\n        if (macroModeState.isPlaying) { return; }\n        vim.lastEditInputState = inputState;\n        vim.lastEditActionCommand = actionCommand;\n        macroModeState.lastInsertModeChanges.changes = [];\n        macroModeState.lastInsertModeChanges.expectCursorActivityForChange = false;\n        macroModeState.lastInsertModeChanges.visualBlock = vim.visualBlock ? vim.sel.head.line - vim.sel.anchor.line : 0;\n      }\n    };\n    var motions = {\n      moveToTopLine: function(cm, _head, motionArgs) {\n        var line = getUserVisibleLines(cm).top + motionArgs.repeat -1;\n        return Pos(line, findFirstNonWhiteSpaceCharacter(cm.getLine(line)));\n      },\n      moveToMiddleLine: function(cm) {\n        var range = getUserVisibleLines(cm);\n        var line = Math.floor((range.top + range.bottom) * 0.5);\n        return Pos(line, findFirstNonWhiteSpaceCharacter(cm.getLine(line)));\n      },\n      moveToBottomLine: function(cm, _head, motionArgs) {\n        var line = getUserVisibleLines(cm).bottom - motionArgs.repeat +1;\n        return Pos(line, findFirstNonWhiteSpaceCharacter(cm.getLine(line)));\n      },\n      expandToLine: function(_cm, head, motionArgs) {\n        var cur = head;\n        return Pos(cur.line + motionArgs.repeat - 1, Infinity);\n      },\n      findNext: function(cm, _head, motionArgs) {\n        var state = getSearchState(cm);\n        var query = state.getQuery();\n        if (!query) {\n          return;\n        }\n        var prev = !motionArgs.forward;\n        prev = (state.isReversed()) ? !prev : prev;\n        highlightSearchMatches(cm, query);\n        return findNext(cm, prev/** prev */, query, motionArgs.repeat);\n      },\n      goToMark: function(cm, _head, motionArgs, vim) {\n        var pos = getMarkPos(cm, vim, motionArgs.selectedCharacter);\n        if (pos) {\n          return motionArgs.linewise ? { line: pos.line, ch: findFirstNonWhiteSpaceCharacter(cm.getLine(pos.line)) } : pos;\n        }\n        return null;\n      },\n      moveToOtherHighlightedEnd: function(cm, _head, motionArgs, vim) {\n        if (vim.visualBlock && motionArgs.sameLine) {\n          var sel = vim.sel;\n          return [\n            clipCursorToContent(cm, Pos(sel.anchor.line, sel.head.ch)),\n            clipCursorToContent(cm, Pos(sel.head.line, sel.anchor.ch))\n          ];\n        } else {\n          return ([vim.sel.head, vim.sel.anchor]);\n        }\n      },\n      jumpToMark: function(cm, head, motionArgs, vim) {\n        var best = head;\n        for (var i = 0; i < motionArgs.repeat; i++) {\n          var cursor = best;\n          for (var key in vim.marks) {\n            if (!isLowerCase(key)) {\n              continue;\n            }\n            var mark = vim.marks[key].find();\n            var isWrongDirection = (motionArgs.forward) ?\n              cursorIsBefore(mark, cursor) : cursorIsBefore(cursor, mark);\n\n            if (isWrongDirection) {\n              continue;\n            }\n            if (motionArgs.linewise && (mark.line == cursor.line)) {\n              continue;\n            }\n\n            var equal = cursorEqual(cursor, best);\n            var between = (motionArgs.forward) ?\n              cursorIsBetween(cursor, mark, best) :\n              cursorIsBetween(best, mark, cursor);\n\n            if (equal || between) {\n              best = mark;\n            }\n          }\n        }\n\n        if (motionArgs.linewise) {\n          best = Pos(best.line, findFirstNonWhiteSpaceCharacter(cm.getLine(best.line)));\n        }\n        return best;\n      },\n      moveByCharacters: function(_cm, head, motionArgs) {\n        var cur = head;\n        var repeat = motionArgs.repeat;\n        var ch = motionArgs.forward ? cur.ch + repeat : cur.ch - repeat;\n        return Pos(cur.line, ch);\n      },\n      moveByLines: function(cm, head, motionArgs, vim) {\n        var cur = head;\n        var endCh = cur.ch;\n        switch (vim.lastMotion) {\n          case this.moveByLines:\n          case this.moveByDisplayLines:\n          case this.moveByScroll:\n          case this.moveToColumn:\n          case this.moveToEol:\n            endCh = vim.lastHPos;\n            break;\n          default:\n            vim.lastHPos = endCh;\n        }\n        var repeat = motionArgs.repeat+(motionArgs.repeatOffset||0);\n        var line = motionArgs.forward ? cur.line + repeat : cur.line - repeat;\n        var first = cm.firstLine();\n        var last = cm.lastLine();\n        if (line < first && cur.line == first){\n          return this.moveToStartOfLine(cm, head, motionArgs, vim);\n        }else if (line > last && cur.line == last){\n            return this.moveToEol(cm, head, motionArgs, vim, true);\n        }\n        var fold = cm.ace.session.getFoldLine(line);\n        if (fold) {\n          if (motionArgs.forward) {\n            if (line > fold.start.row)\n              line = fold.end.row + 1;\n          } else {\n            line = fold.start.row;\n          }\n        }\n        if (motionArgs.toFirstChar){\n          endCh=findFirstNonWhiteSpaceCharacter(cm.getLine(line));\n          vim.lastHPos = endCh;\n        }\n        vim.lastHSPos = cm.charCoords(Pos(line, endCh),'div').left;\n        return Pos(line, endCh);\n      },\n      moveByDisplayLines: function(cm, head, motionArgs, vim) {\n        var cur = head;\n        switch (vim.lastMotion) {\n          case this.moveByDisplayLines:\n          case this.moveByScroll:\n          case this.moveByLines:\n          case this.moveToColumn:\n          case this.moveToEol:\n            break;\n          default:\n            vim.lastHSPos = cm.charCoords(cur,'div').left;\n        }\n        var repeat = motionArgs.repeat;\n        var res=cm.findPosV(cur,(motionArgs.forward ? repeat : -repeat),'line',vim.lastHSPos);\n        if (res.hitSide) {\n          if (motionArgs.forward) {\n            var lastCharCoords = cm.charCoords(res, 'div');\n            var goalCoords = { top: lastCharCoords.top + 8, left: vim.lastHSPos };\n            var res = cm.coordsChar(goalCoords, 'div');\n          } else {\n            var resCoords = cm.charCoords(Pos(cm.firstLine(), 0), 'div');\n            resCoords.left = vim.lastHSPos;\n            res = cm.coordsChar(resCoords, 'div');\n          }\n        }\n        vim.lastHPos = res.ch;\n        return res;\n      },\n      moveByPage: function(cm, head, motionArgs) {\n        var curStart = head;\n        var repeat = motionArgs.repeat;\n        return cm.findPosV(curStart, (motionArgs.forward ? repeat : -repeat), 'page');\n      },\n      moveByParagraph: function(cm, head, motionArgs) {\n        var dir = motionArgs.forward ? 1 : -1;\n        return findParagraph(cm, head, motionArgs.repeat, dir);\n      },\n      moveBySentence: function(cm, head, motionArgs) {\n        var dir = motionArgs.forward ? 1 : -1;\n        return findSentence(cm, head, motionArgs.repeat, dir);\n      },\n      moveByScroll: function(cm, head, motionArgs, vim) {\n        var scrollbox = cm.getScrollInfo();\n        var curEnd = null;\n        var repeat = motionArgs.repeat;\n        if (!repeat) {\n          repeat = scrollbox.clientHeight / (2 * cm.defaultTextHeight());\n        }\n        var orig = cm.charCoords(head, 'local');\n        motionArgs.repeat = repeat;\n        var curEnd = motions.moveByDisplayLines(cm, head, motionArgs, vim);\n        if (!curEnd) {\n          return null;\n        }\n        var dest = cm.charCoords(curEnd, 'local');\n        cm.scrollTo(null, scrollbox.top + dest.top - orig.top);\n        return curEnd;\n      },\n      moveByWords: function(cm, head, motionArgs) {\n        return moveToWord(cm, head, motionArgs.repeat, !!motionArgs.forward,\n            !!motionArgs.wordEnd, !!motionArgs.bigWord);\n      },\n      moveTillCharacter: function(cm, _head, motionArgs) {\n        var repeat = motionArgs.repeat;\n        var curEnd = moveToCharacter(cm, repeat, motionArgs.forward,\n            motionArgs.selectedCharacter);\n        var increment = motionArgs.forward ? -1 : 1;\n        recordLastCharacterSearch(increment, motionArgs);\n        if (!curEnd) return null;\n        curEnd.ch += increment;\n        return curEnd;\n      },\n      moveToCharacter: function(cm, head, motionArgs) {\n        var repeat = motionArgs.repeat;\n        recordLastCharacterSearch(0, motionArgs);\n        return moveToCharacter(cm, repeat, motionArgs.forward,\n            motionArgs.selectedCharacter) || head;\n      },\n      moveToSymbol: function(cm, head, motionArgs) {\n        var repeat = motionArgs.repeat;\n        return findSymbol(cm, repeat, motionArgs.forward,\n            motionArgs.selectedCharacter) || head;\n      },\n      moveToColumn: function(cm, head, motionArgs, vim) {\n        var repeat = motionArgs.repeat;\n        vim.lastHPos = repeat - 1;\n        vim.lastHSPos = cm.charCoords(head,'div').left;\n        return moveToColumn(cm, repeat);\n      },\n      moveToEol: function(cm, head, motionArgs, vim, keepHPos) {\n        var cur = head;\n        var retval= Pos(cur.line + motionArgs.repeat - 1, Infinity);\n        var end=cm.clipPos(retval);\n        end.ch--;\n        if (!keepHPos) {\n          vim.lastHPos = Infinity;\n          vim.lastHSPos = cm.charCoords(end,'div').left;\n        }\n        return retval;\n      },\n      moveToFirstNonWhiteSpaceCharacter: function(cm, head) {\n        var cursor = head;\n        return Pos(cursor.line,\n                   findFirstNonWhiteSpaceCharacter(cm.getLine(cursor.line)));\n      },\n      moveToMatchedSymbol: function(cm, head) {\n        var cursor = head;\n        var line = cursor.line;\n        var ch = cursor.ch;\n        var lineText = cm.getLine(line);\n        var symbol;\n        for (; ch < lineText.length; ch++) {\n          symbol = lineText.charAt(ch);\n          if (symbol && isMatchableSymbol(symbol)) {\n            var style = cm.getTokenTypeAt(Pos(line, ch + 1));\n            if (style !== \"string\" && style !== \"comment\") {\n              break;\n            }\n          }\n        }\n        if (ch < lineText.length) {\n          var re = /[<>]/.test(lineText[ch]) ? /[(){}[\\]<>]/ : /[(){}[\\]]/; //ace_patch?\n          var matched = cm.findMatchingBracket(Pos(line, ch+1), {bracketRegex: re});\n          return matched.to;\n        } else {\n          return cursor;\n        }\n      },\n      moveToStartOfLine: function(_cm, head) {\n        return Pos(head.line, 0);\n      },\n      moveToLineOrEdgeOfDocument: function(cm, _head, motionArgs) {\n        var lineNum = motionArgs.forward ? cm.lastLine() : cm.firstLine();\n        if (motionArgs.repeatIsExplicit) {\n          lineNum = motionArgs.repeat - cm.getOption('firstLineNumber');\n        }\n        return Pos(lineNum,\n                   findFirstNonWhiteSpaceCharacter(cm.getLine(lineNum)));\n      },\n      textObjectManipulation: function(cm, head, motionArgs, vim) {\n        var mirroredPairs = {'(': ')', ')': '(',\n                             '{': '}', '}': '{',\n                             '[': ']', ']': '[',\n                             '<': '>', '>': '<'};\n        var selfPaired = {'\\'': true, '\"': true, '`': true};\n\n        var character = motionArgs.selectedCharacter;\n        if (character == 'b') {\n          character = '(';\n        } else if (character == 'B') {\n          character = '{';\n        }\n        var inclusive = !motionArgs.textObjectInner;\n\n        var tmp;\n        if (mirroredPairs[character]) {\n          tmp = selectCompanionObject(cm, head, character, inclusive);\n        } else if (selfPaired[character]) {\n          tmp = findBeginningAndEnd(cm, head, character, inclusive);\n        } else if (character === 'W') {\n          tmp = expandWordUnderCursor(cm, inclusive, true /** forward */,\n                                                     true /** bigWord */);\n        } else if (character === 'w') {\n          tmp = expandWordUnderCursor(cm, inclusive, true /** forward */,\n                                                     false /** bigWord */);\n        } else if (character === 'p') {\n          tmp = findParagraph(cm, head, motionArgs.repeat, 0, inclusive);\n          motionArgs.linewise = true;\n          if (vim.visualMode) {\n            if (!vim.visualLine) { vim.visualLine = true; }\n          } else {\n            var operatorArgs = vim.inputState.operatorArgs;\n            if (operatorArgs) { operatorArgs.linewise = true; }\n            tmp.end.line--;\n          }\n        } else {\n          return null;\n        }\n\n        if (!cm.state.vim.visualMode) {\n          return [tmp.start, tmp.end];\n        } else {\n          return expandSelection(cm, tmp.start, tmp.end);\n        }\n      },\n\n      repeatLastCharacterSearch: function(cm, head, motionArgs) {\n        var lastSearch = vimGlobalState.lastCharacterSearch;\n        var repeat = motionArgs.repeat;\n        var forward = motionArgs.forward === lastSearch.forward;\n        var increment = (lastSearch.increment ? 1 : 0) * (forward ? -1 : 1);\n        cm.moveH(-increment, 'char');\n        motionArgs.inclusive = forward ? true : false;\n        var curEnd = moveToCharacter(cm, repeat, forward, lastSearch.selectedCharacter);\n        if (!curEnd) {\n          cm.moveH(increment, 'char');\n          return head;\n        }\n        curEnd.ch += increment;\n        return curEnd;\n      }\n    };\n\n    function defineMotion(name, fn) {\n      motions[name] = fn;\n    }\n\n    function fillArray(val, times) {\n      var arr = [];\n      for (var i = 0; i < times; i++) {\n        arr.push(val);\n      }\n      return arr;\n    }\n    var operators = {\n      change: function(cm, args, ranges) {\n        var finalHead, text;\n        var vim = cm.state.vim;\n        var anchor = ranges[0].anchor,\n            head = ranges[0].head;\n        if (!vim.visualMode) {\n          text = cm.getRange(anchor, head);\n          var lastState = vim.lastEditInputState || {};\n          if (lastState.motion == \"moveByWords\" && !isWhiteSpaceString(text)) {\n            var match = (/\\s+$/).exec(text);\n            if (match && lastState.motionArgs && lastState.motionArgs.forward) {\n              head = offsetCursor(head, 0, - match[0].length);\n              text = text.slice(0, - match[0].length);\n            }\n          }\n          var prevLineEnd = new Pos(anchor.line - 1, Number.MAX_VALUE);\n          var wasLastLine = cm.firstLine() == cm.lastLine();\n          if (head.line > cm.lastLine() && args.linewise && !wasLastLine) {\n            cm.replaceRange('', prevLineEnd, head);\n          } else {\n            cm.replaceRange('', anchor, head);\n          }\n          if (args.linewise) {\n            if (!wasLastLine) {\n              cm.setCursor(prevLineEnd);\n              CodeMirror.commands.newlineAndIndent(cm);\n            }\n            anchor.ch = Number.MAX_VALUE;\n          }\n          finalHead = anchor;\n        } else if (args.fullLine) {\n            head.ch = Number.MAX_VALUE;\n            head.line--;\n            cm.setSelection(anchor, head)\n            text = cm.getSelection();\n            cm.replaceSelection(\"\");\n            finalHead = anchor;\n        } else {\n          text = cm.getSelection();\n          var replacement = fillArray('', ranges.length);\n          cm.replaceSelections(replacement);\n          finalHead = cursorMin(ranges[0].head, ranges[0].anchor);\n        }\n        vimGlobalState.registerController.pushText(\n            args.registerName, 'change', text,\n            args.linewise, ranges.length > 1);\n        actions.enterInsertMode(cm, {head: finalHead}, cm.state.vim);\n      },\n      'delete': function(cm, args, ranges) {\n        var finalHead, text;\n        var vim = cm.state.vim;\n        if (!vim.visualBlock) {\n          var anchor = ranges[0].anchor,\n              head = ranges[0].head;\n          if (args.linewise &&\n              head.line != cm.firstLine() &&\n              anchor.line == cm.lastLine() &&\n              anchor.line == head.line - 1) {\n            if (anchor.line == cm.firstLine()) {\n              anchor.ch = 0;\n            } else {\n              anchor = Pos(anchor.line - 1, lineLength(cm, anchor.line - 1));\n            }\n          }\n          text = cm.getRange(anchor, head);\n          cm.replaceRange('', anchor, head);\n          finalHead = anchor;\n          if (args.linewise) {\n            finalHead = motions.moveToFirstNonWhiteSpaceCharacter(cm, anchor);\n          }\n        } else {\n          text = cm.getSelection();\n          var replacement = fillArray('', ranges.length);\n          cm.replaceSelections(replacement);\n          finalHead = ranges[0].anchor;\n        }\n        vimGlobalState.registerController.pushText(\n            args.registerName, 'delete', text,\n            args.linewise, vim.visualBlock);\n        var includeLineBreak = vim.insertMode\n        return clipCursorToContent(cm, finalHead, includeLineBreak);\n      },\n      indent: function(cm, args, ranges) {\n        var vim = cm.state.vim;\n        var startLine = ranges[0].anchor.line;\n        var endLine = vim.visualBlock ?\n          ranges[ranges.length - 1].anchor.line :\n          ranges[0].head.line;\n        var repeat = (vim.visualMode) ? args.repeat : 1;\n        if (args.linewise) {\n          endLine--;\n        }\n        for (var i = startLine; i <= endLine; i++) {\n          for (var j = 0; j < repeat; j++) {\n            cm.indentLine(i, args.indentRight);\n          }\n        }\n        return motions.moveToFirstNonWhiteSpaceCharacter(cm, ranges[0].anchor);\n      },\n      indentAuto: function(cm, _args, ranges) {\n        cm.execCommand(\"indentAuto\");\n        return motions.moveToFirstNonWhiteSpaceCharacter(cm, ranges[0].anchor);\n      },\n      changeCase: function(cm, args, ranges, oldAnchor, newHead) {\n        var selections = cm.getSelections();\n        var swapped = [];\n        var toLower = args.toLower;\n        for (var j = 0; j < selections.length; j++) {\n          var toSwap = selections[j];\n          var text = '';\n          if (toLower === true) {\n            text = toSwap.toLowerCase();\n          } else if (toLower === false) {\n            text = toSwap.toUpperCase();\n          } else {\n            for (var i = 0; i < toSwap.length; i++) {\n              var character = toSwap.charAt(i);\n              text += isUpperCase(character) ? character.toLowerCase() :\n                  character.toUpperCase();\n            }\n          }\n          swapped.push(text);\n        }\n        cm.replaceSelections(swapped);\n        if (args.shouldMoveCursor){\n          return newHead;\n        } else if (!cm.state.vim.visualMode && args.linewise && ranges[0].anchor.line + 1 == ranges[0].head.line) {\n          return motions.moveToFirstNonWhiteSpaceCharacter(cm, oldAnchor);\n        } else if (args.linewise){\n          return oldAnchor;\n        } else {\n          return cursorMin(ranges[0].anchor, ranges[0].head);\n        }\n      },\n      yank: function(cm, args, ranges, oldAnchor) {\n        var vim = cm.state.vim;\n        var text = cm.getSelection();\n        var endPos = vim.visualMode\n          ? cursorMin(vim.sel.anchor, vim.sel.head, ranges[0].head, ranges[0].anchor)\n          : oldAnchor;\n        vimGlobalState.registerController.pushText(\n            args.registerName, 'yank',\n            text, args.linewise, vim.visualBlock);\n        return endPos;\n      }\n    };\n\n    function defineOperator(name, fn) {\n      operators[name] = fn;\n    }\n\n    var actions = {\n      jumpListWalk: function(cm, actionArgs, vim) {\n        if (vim.visualMode) {\n          return;\n        }\n        var repeat = actionArgs.repeat;\n        var forward = actionArgs.forward;\n        var jumpList = vimGlobalState.jumpList;\n\n        var mark = jumpList.move(cm, forward ? repeat : -repeat);\n        var markPos = mark ? mark.find() : undefined;\n        markPos = markPos ? markPos : cm.getCursor();\n        cm.setCursor(markPos);\n        cm.ace.curOp.command.scrollIntoView = \"center-animate\"; // ace_patch\n      },\n      scroll: function(cm, actionArgs, vim) {\n        if (vim.visualMode) {\n          return;\n        }\n        var repeat = actionArgs.repeat || 1;\n        var lineHeight = cm.defaultTextHeight();\n        var top = cm.getScrollInfo().top;\n        var delta = lineHeight * repeat;\n        var newPos = actionArgs.forward ? top + delta : top - delta;\n        var cursor = copyCursor(cm.getCursor());\n        var cursorCoords = cm.charCoords(cursor, 'local');\n        if (actionArgs.forward) {\n          if (newPos > cursorCoords.top) {\n             cursor.line += (newPos - cursorCoords.top) / lineHeight;\n             cursor.line = Math.ceil(cursor.line);\n             cm.setCursor(cursor);\n             cursorCoords = cm.charCoords(cursor, 'local');\n             cm.scrollTo(null, cursorCoords.top);\n          } else {\n             cm.scrollTo(null, newPos);\n          }\n        } else {\n          var newBottom = newPos + cm.getScrollInfo().clientHeight;\n          if (newBottom < cursorCoords.bottom) {\n             cursor.line -= (cursorCoords.bottom - newBottom) / lineHeight;\n             cursor.line = Math.floor(cursor.line);\n             cm.setCursor(cursor);\n             cursorCoords = cm.charCoords(cursor, 'local');\n             cm.scrollTo(\n                 null, cursorCoords.bottom - cm.getScrollInfo().clientHeight);\n          } else {\n             cm.scrollTo(null, newPos);\n          }\n        }\n      },\n      scrollToCursor: function(cm, actionArgs) {\n        var lineNum = cm.getCursor().line;\n        var charCoords = cm.charCoords(Pos(lineNum, 0), 'local');\n        var height = cm.getScrollInfo().clientHeight;\n        var y = charCoords.top;\n        var lineHeight = charCoords.bottom - y;\n        switch (actionArgs.position) {\n          case 'center': y = y - (height / 2) + lineHeight;\n            break;\n          case 'bottom': y = y - height + lineHeight;\n            break;\n        }\n        cm.scrollTo(null, y);\n      },\n      replayMacro: function(cm, actionArgs, vim) {\n        var registerName = actionArgs.selectedCharacter;\n        var repeat = actionArgs.repeat;\n        var macroModeState = vimGlobalState.macroModeState;\n        if (registerName == '@') {\n          registerName = macroModeState.latestRegister;\n        } else {\n          macroModeState.latestRegister = registerName;\n        }\n        while(repeat--){\n          executeMacroRegister(cm, vim, macroModeState, registerName);\n        }\n      },\n      enterMacroRecordMode: function(cm, actionArgs) {\n        var macroModeState = vimGlobalState.macroModeState;\n        var registerName = actionArgs.selectedCharacter;\n        if (vimGlobalState.registerController.isValidRegister(registerName)) {\n          macroModeState.enterMacroRecordMode(cm, registerName);\n        }\n      },\n      toggleOverwrite: function(cm) {\n        if (!cm.state.overwrite) {\n          cm.toggleOverwrite(true);\n          cm.setOption('keyMap', 'vim-replace');\n          CodeMirror.signal(cm, \"vim-mode-change\", {mode: \"replace\"});\n        } else {\n          cm.toggleOverwrite(false);\n          cm.setOption('keyMap', 'vim-insert');\n          CodeMirror.signal(cm, \"vim-mode-change\", {mode: \"insert\"});\n        }\n      },\n      enterInsertMode: function(cm, actionArgs, vim) {\n        if (cm.getOption('readOnly')) { return; }\n        vim.insertMode = true;\n        vim.insertModeRepeat = actionArgs && actionArgs.repeat || 1;\n        var insertAt = (actionArgs) ? actionArgs.insertAt : null;\n        var sel = vim.sel;\n        var head = actionArgs.head || cm.getCursor('head');\n        var height = cm.listSelections().length;\n        if (insertAt == 'eol') {\n          head = Pos(head.line, lineLength(cm, head.line));\n        } else if (insertAt == 'bol') {\n          head = Pos(head.line, 0);\n        } else if (insertAt == 'charAfter') {\n          head = offsetCursor(head, 0, 1);\n        } else if (insertAt == 'firstNonBlank') {\n          head = motions.moveToFirstNonWhiteSpaceCharacter(cm, head);\n        } else if (insertAt == 'startOfSelectedArea') {\n          if (!vim.visualMode)\n              return;\n          if (!vim.visualBlock) {\n            if (sel.head.line < sel.anchor.line) {\n              head = sel.head;\n            } else {\n              head = Pos(sel.anchor.line, 0);\n            }\n          } else {\n            head = Pos(\n                Math.min(sel.head.line, sel.anchor.line),\n                Math.min(sel.head.ch, sel.anchor.ch));\n            height = Math.abs(sel.head.line - sel.anchor.line) + 1;\n          }\n        } else if (insertAt == 'endOfSelectedArea') {\n            if (!vim.visualMode)\n              return;\n          if (!vim.visualBlock) {\n            if (sel.head.line >= sel.anchor.line) {\n              head = offsetCursor(sel.head, 0, 1);\n            } else {\n              head = Pos(sel.anchor.line, 0);\n            }\n          } else {\n            head = Pos(\n                Math.min(sel.head.line, sel.anchor.line),\n                Math.max(sel.head.ch + 1, sel.anchor.ch));\n            height = Math.abs(sel.head.line - sel.anchor.line) + 1;\n          }\n        } else if (insertAt == 'inplace') {\n          if (vim.visualMode){\n            return;\n          }\n        } else if (insertAt == 'lastEdit') {\n          head = getLastEditPos(cm) || head;\n        }\n        cm.setOption('disableInput', false);\n        if (actionArgs && actionArgs.replace) {\n          cm.toggleOverwrite(true);\n          cm.setOption('keyMap', 'vim-replace');\n          CodeMirror.signal(cm, \"vim-mode-change\", {mode: \"replace\"});\n        } else {\n          cm.toggleOverwrite(false);\n          cm.setOption('keyMap', 'vim-insert');\n          CodeMirror.signal(cm, \"vim-mode-change\", {mode: \"insert\"});\n        }\n        if (!vimGlobalState.macroModeState.isPlaying) {\n          cm.on('change', onChange);\n          CodeMirror.on(cm.getInputField(), 'keydown', onKeyEventTargetKeyDown);\n        }\n        if (vim.visualMode) {\n          exitVisualMode(cm);\n        }\n        selectForInsert(cm, head, height);\n      },\n      toggleVisualMode: function(cm, actionArgs, vim) {\n        var repeat = actionArgs.repeat;\n        var anchor = cm.getCursor();\n        var head;\n        if (!vim.visualMode) {\n          vim.visualMode = true;\n          vim.visualLine = !!actionArgs.linewise;\n          vim.visualBlock = !!actionArgs.blockwise;\n          head = clipCursorToContent(\n              cm, Pos(anchor.line, anchor.ch + repeat - 1),\n              true /** includeLineBreak */);\n          vim.sel = {\n            anchor: anchor,\n            head: head\n          };\n          CodeMirror.signal(cm, \"vim-mode-change\", {mode: \"visual\", subMode: vim.visualLine ? \"linewise\" : vim.visualBlock ? \"blockwise\" : \"\"});\n          updateCmSelection(cm);\n          updateMark(cm, vim, '<', cursorMin(anchor, head));\n          updateMark(cm, vim, '>', cursorMax(anchor, head));\n        } else if (vim.visualLine ^ actionArgs.linewise ||\n            vim.visualBlock ^ actionArgs.blockwise) {\n          vim.visualLine = !!actionArgs.linewise;\n          vim.visualBlock = !!actionArgs.blockwise;\n          CodeMirror.signal(cm, \"vim-mode-change\", {mode: \"visual\", subMode: vim.visualLine ? \"linewise\" : vim.visualBlock ? \"blockwise\" : \"\"});\n          updateCmSelection(cm);\n        } else {\n          exitVisualMode(cm);\n        }\n      },\n      reselectLastSelection: function(cm, _actionArgs, vim) {\n        var lastSelection = vim.lastSelection;\n        if (vim.visualMode) {\n          updateLastSelection(cm, vim);\n        }\n        if (lastSelection) {\n          var anchor = lastSelection.anchorMark.find();\n          var head = lastSelection.headMark.find();\n          if (!anchor || !head) {\n            return;\n          }\n          vim.sel = {\n            anchor: anchor,\n            head: head\n          };\n          vim.visualMode = true;\n          vim.visualLine = lastSelection.visualLine;\n          vim.visualBlock = lastSelection.visualBlock;\n          updateCmSelection(cm);\n          updateMark(cm, vim, '<', cursorMin(anchor, head));\n          updateMark(cm, vim, '>', cursorMax(anchor, head));\n          CodeMirror.signal(cm, 'vim-mode-change', {\n            mode: 'visual',\n            subMode: vim.visualLine ? 'linewise' :\n                     vim.visualBlock ? 'blockwise' : ''});\n        }\n      },\n      joinLines: function(cm, actionArgs, vim) {\n        var curStart, curEnd;\n        if (vim.visualMode) {\n          curStart = cm.getCursor('anchor');\n          curEnd = cm.getCursor('head');\n          if (cursorIsBefore(curEnd, curStart)) {\n            var tmp = curEnd;\n            curEnd = curStart;\n            curStart = tmp;\n          }\n          curEnd.ch = lineLength(cm, curEnd.line) - 1;\n        } else {\n          var repeat = Math.max(actionArgs.repeat, 2);\n          curStart = cm.getCursor();\n          curEnd = clipCursorToContent(cm, Pos(curStart.line + repeat - 1,\n                                               Infinity));\n        }\n        var finalCh = 0;\n        for (var i = curStart.line; i < curEnd.line; i++) {\n          finalCh = lineLength(cm, curStart.line);\n          var tmp = Pos(curStart.line + 1,\n                        lineLength(cm, curStart.line + 1));\n          var text = cm.getRange(curStart, tmp);\n          text = actionArgs.keepSpaces\n            ? text.replace(/\\n\\r?/g, '')\n            : text.replace(/\\n\\s*/g, ' ');\n          cm.replaceRange(text, curStart, tmp);\n        }\n        var curFinalPos = Pos(curStart.line, finalCh);\n        if (vim.visualMode) {\n          exitVisualMode(cm, false);\n        }\n        cm.setCursor(curFinalPos);\n      },\n      newLineAndEnterInsertMode: function(cm, actionArgs, vim) {\n        vim.insertMode = true;\n        var insertAt = copyCursor(cm.getCursor());\n        if (insertAt.line === cm.firstLine() && !actionArgs.after) {\n          cm.replaceRange('\\n', Pos(cm.firstLine(), 0));\n          cm.setCursor(cm.firstLine(), 0);\n        } else {\n          insertAt.line = (actionArgs.after) ? insertAt.line :\n              insertAt.line - 1;\n          insertAt.ch = lineLength(cm, insertAt.line);\n          cm.setCursor(insertAt);\n          var newlineFn = CodeMirror.commands.newlineAndIndentContinueComment ||\n              CodeMirror.commands.newlineAndIndent;\n          newlineFn(cm);\n        }\n        this.enterInsertMode(cm, { repeat: actionArgs.repeat }, vim);\n      },\n      paste: function(cm, actionArgs, vim) {\n        var cur = copyCursor(cm.getCursor());\n        var register = vimGlobalState.registerController.getRegister(\n            actionArgs.registerName);\n        var text = register.toString();\n        if (!text) {\n          return;\n        }\n        if (actionArgs.matchIndent) {\n          var tabSize = cm.getOption(\"tabSize\");\n          var whitespaceLength = function(str) {\n            var tabs = (str.split(\"\\t\").length - 1);\n            var spaces = (str.split(\" \").length - 1);\n            return tabs * tabSize + spaces * 1;\n          };\n          var currentLine = cm.getLine(cm.getCursor().line);\n          var indent = whitespaceLength(currentLine.match(/^\\s*/)[0]);\n          var chompedText = text.replace(/\\n$/, '');\n          var wasChomped = text !== chompedText;\n          var firstIndent = whitespaceLength(text.match(/^\\s*/)[0]);\n          var text = chompedText.replace(/^\\s*/gm, function(wspace) {\n            var newIndent = indent + (whitespaceLength(wspace) - firstIndent);\n            if (newIndent < 0) {\n              return \"\";\n            }\n            else if (cm.getOption(\"indentWithTabs\")) {\n              var quotient = Math.floor(newIndent / tabSize);\n              return Array(quotient + 1).join('\\t');\n            }\n            else {\n              return Array(newIndent + 1).join(' ');\n            }\n          });\n          text += wasChomped ? \"\\n\" : \"\";\n        }\n        if (actionArgs.repeat > 1) {\n          var text = Array(actionArgs.repeat + 1).join(text);\n        }\n        var linewise = register.linewise;\n        var blockwise = register.blockwise;\n        if (blockwise) {\n          text = text.split('\\n');\n          if (linewise) {\n              text.pop();\n          }\n          for (var i = 0; i < text.length; i++) {\n            text[i] = (text[i] == '') ? ' ' : text[i];\n          }\n          cur.ch += actionArgs.after ? 1 : 0;\n          cur.ch = Math.min(lineLength(cm, cur.line), cur.ch);\n        } else if (linewise) {\n          if(vim.visualMode) {\n            text = vim.visualLine ? text.slice(0, -1) : '\\n' + text.slice(0, text.length - 1) + '\\n';\n          } else if (actionArgs.after) {\n            text = '\\n' + text.slice(0, text.length - 1);\n            cur.ch = lineLength(cm, cur.line);\n          } else {\n            cur.ch = 0;\n          }\n        } else {\n          cur.ch += actionArgs.after ? 1 : 0;\n        }\n        var curPosFinal;\n        var idx;\n        if (vim.visualMode) {\n          vim.lastPastedText = text;\n          var lastSelectionCurEnd;\n          var selectedArea = getSelectedAreaRange(cm, vim);\n          var selectionStart = selectedArea[0];\n          var selectionEnd = selectedArea[1];\n          var selectedText = cm.getSelection();\n          var selections = cm.listSelections();\n          var emptyStrings = new Array(selections.length).join('1').split('1');\n          if (vim.lastSelection) {\n            lastSelectionCurEnd = vim.lastSelection.headMark.find();\n          }\n          vimGlobalState.registerController.unnamedRegister.setText(selectedText);\n          if (blockwise) {\n            cm.replaceSelections(emptyStrings);\n            selectionEnd = Pos(selectionStart.line + text.length-1, selectionStart.ch);\n            cm.setCursor(selectionStart);\n            selectBlock(cm, selectionEnd);\n            cm.replaceSelections(text);\n            curPosFinal = selectionStart;\n          } else if (vim.visualBlock) {\n            cm.replaceSelections(emptyStrings);\n            cm.setCursor(selectionStart);\n            cm.replaceRange(text, selectionStart, selectionStart);\n            curPosFinal = selectionStart;\n          } else {\n            cm.replaceRange(text, selectionStart, selectionEnd);\n            curPosFinal = cm.posFromIndex(cm.indexFromPos(selectionStart) + text.length - 1);\n          }\n          if(lastSelectionCurEnd) {\n            vim.lastSelection.headMark = cm.setBookmark(lastSelectionCurEnd);\n          }\n          if (linewise) {\n            curPosFinal.ch=0;\n          }\n        } else {\n          if (blockwise) {\n            cm.setCursor(cur);\n            for (var i = 0; i < text.length; i++) {\n              var line = cur.line+i;\n              if (line > cm.lastLine()) {\n                cm.replaceRange('\\n',  Pos(line, 0));\n              }\n              var lastCh = lineLength(cm, line);\n              if (lastCh < cur.ch) {\n                extendLineToColumn(cm, line, cur.ch);\n              }\n            }\n            cm.setCursor(cur);\n            selectBlock(cm, Pos(cur.line + text.length-1, cur.ch));\n            cm.replaceSelections(text);\n            curPosFinal = cur;\n          } else {\n            cm.replaceRange(text, cur);\n            if (linewise && actionArgs.after) {\n              curPosFinal = Pos(\n              cur.line + 1,\n              findFirstNonWhiteSpaceCharacter(cm.getLine(cur.line + 1)));\n            } else if (linewise && !actionArgs.after) {\n              curPosFinal = Pos(\n                cur.line,\n                findFirstNonWhiteSpaceCharacter(cm.getLine(cur.line)));\n            } else if (!linewise && actionArgs.after) {\n              idx = cm.indexFromPos(cur);\n              curPosFinal = cm.posFromIndex(idx + text.length - 1);\n            } else {\n              idx = cm.indexFromPos(cur);\n              curPosFinal = cm.posFromIndex(idx + text.length);\n            }\n          }\n        }\n        if (vim.visualMode) {\n          exitVisualMode(cm, false);\n        }\n        cm.setCursor(curPosFinal);\n      },\n      undo: function(cm, actionArgs) {\n        cm.operation(function() {\n          repeatFn(cm, CodeMirror.commands.undo, actionArgs.repeat)();\n          cm.setCursor(cm.getCursor('anchor'));\n        });\n      },\n      redo: function(cm, actionArgs) {\n        repeatFn(cm, CodeMirror.commands.redo, actionArgs.repeat)();\n      },\n      setRegister: function(_cm, actionArgs, vim) {\n        vim.inputState.registerName = actionArgs.selectedCharacter;\n      },\n      setMark: function(cm, actionArgs, vim) {\n        var markName = actionArgs.selectedCharacter;\n        updateMark(cm, vim, markName, cm.getCursor());\n      },\n      replace: function(cm, actionArgs, vim) {\n        var replaceWith = actionArgs.selectedCharacter;\n        var curStart = cm.getCursor();\n        var replaceTo;\n        var curEnd;\n        var selections = cm.listSelections();\n        if (vim.visualMode) {\n          curStart = cm.getCursor('start');\n          curEnd = cm.getCursor('end');\n        } else {\n          var line = cm.getLine(curStart.line);\n          replaceTo = curStart.ch + actionArgs.repeat;\n          if (replaceTo > line.length) {\n            replaceTo=line.length;\n          }\n          curEnd = Pos(curStart.line, replaceTo);\n        }\n        if (replaceWith=='\\n') {\n          if (!vim.visualMode) cm.replaceRange('', curStart, curEnd);\n          (CodeMirror.commands.newlineAndIndentContinueComment || CodeMirror.commands.newlineAndIndent)(cm);\n        } else {\n          var replaceWithStr = cm.getRange(curStart, curEnd);\n          replaceWithStr = replaceWithStr.replace(/[^\\n]/g, replaceWith);\n          if (vim.visualBlock) {\n            var spaces = new Array(cm.getOption(\"tabSize\")+1).join(' ');\n            replaceWithStr = cm.getSelection();\n            replaceWithStr = replaceWithStr.replace(/\\t/g, spaces).replace(/[^\\n]/g, replaceWith).split('\\n');\n            cm.replaceSelections(replaceWithStr);\n          } else {\n            cm.replaceRange(replaceWithStr, curStart, curEnd);\n          }\n          if (vim.visualMode) {\n            curStart = cursorIsBefore(selections[0].anchor, selections[0].head) ?\n                         selections[0].anchor : selections[0].head;\n            cm.setCursor(curStart);\n            exitVisualMode(cm, false);\n          } else {\n            cm.setCursor(offsetCursor(curEnd, 0, -1));\n          }\n        }\n      },\n      incrementNumberToken: function(cm, actionArgs) {\n        var cur = cm.getCursor();\n        var lineStr = cm.getLine(cur.line);\n        var re = /(-?)(?:(0x)([\\da-f]+)|(0b|0|)(\\d+))/gi;\n        var match;\n        var start;\n        var end;\n        var numberStr;\n        while ((match = re.exec(lineStr)) !== null) {\n          start = match.index;\n          end = start + match[0].length;\n          if (cur.ch < end)break;\n        }\n        if (!actionArgs.backtrack && (end <= cur.ch))return;\n        if (match) {\n          var baseStr = match[2] || match[4]\n          var digits = match[3] || match[5]\n          var increment = actionArgs.increase ? 1 : -1;\n          var base = {'0b': 2, '0': 8, '': 10, '0x': 16}[baseStr.toLowerCase()];\n          var number = parseInt(match[1] + digits, base) + (increment * actionArgs.repeat);\n          numberStr = number.toString(base);\n          var zeroPadding = baseStr ? new Array(digits.length - numberStr.length + 1 + match[1].length).join('0') : ''\n          if (numberStr.charAt(0) === '-') {\n            numberStr = '-' + baseStr + zeroPadding + numberStr.substr(1);\n          } else {\n            numberStr = baseStr + zeroPadding + numberStr;\n          }\n          var from = Pos(cur.line, start);\n          var to = Pos(cur.line, end);\n          cm.replaceRange(numberStr, from, to);\n        } else {\n          return;\n        }\n        cm.setCursor(Pos(cur.line, start + numberStr.length - 1));\n      },\n      repeatLastEdit: function(cm, actionArgs, vim) {\n        var lastEditInputState = vim.lastEditInputState;\n        if (!lastEditInputState) { return; }\n        var repeat = actionArgs.repeat;\n        if (repeat && actionArgs.repeatIsExplicit) {\n          vim.lastEditInputState.repeatOverride = repeat;\n        } else {\n          repeat = vim.lastEditInputState.repeatOverride || repeat;\n        }\n        repeatLastEdit(cm, vim, repeat, false /** repeatForInsert */);\n      },\n      indent: function(cm, actionArgs) {\n        cm.indentLine(cm.getCursor().line, actionArgs.indentRight);\n      },\n      exitInsertMode: exitInsertMode\n    };\n\n    function defineAction(name, fn) {\n      actions[name] = fn;\n    }\n    function clipCursorToContent(cm, cur, includeLineBreak) {\n      var line = Math.min(Math.max(cm.firstLine(), cur.line), cm.lastLine() );\n      var maxCh = lineLength(cm, line) - 1;\n      maxCh = (includeLineBreak) ? maxCh + 1 : maxCh;\n      var ch = Math.min(Math.max(0, cur.ch), maxCh);\n      return Pos(line, ch);\n    }\n    function copyArgs(args) {\n      var ret = {};\n      for (var prop in args) {\n        if (args.hasOwnProperty(prop)) {\n          ret[prop] = args[prop];\n        }\n      }\n      return ret;\n    }\n    function offsetCursor(cur, offsetLine, offsetCh) {\n      if (typeof offsetLine === 'object') {\n        offsetCh = offsetLine.ch;\n        offsetLine = offsetLine.line;\n      }\n      return Pos(cur.line + offsetLine, cur.ch + offsetCh);\n    }\n    function commandMatches(keys, keyMap, context, inputState) {\n      var match, partial = [], full = [];\n      for (var i = 0; i < keyMap.length; i++) {\n        var command = keyMap[i];\n        if (context == 'insert' && command.context != 'insert' ||\n            command.context && command.context != context ||\n            inputState.operator && command.type == 'action' ||\n            !(match = commandMatch(keys, command.keys))) { continue; }\n        if (match == 'partial') { partial.push(command); }\n        if (match == 'full') { full.push(command); }\n      }\n      return {\n        partial: partial.length && partial,\n        full: full.length && full\n      };\n    }\n    function commandMatch(pressed, mapped) {\n      if (mapped.slice(-11) == '<character>') {\n        var prefixLen = mapped.length - 11;\n        var pressedPrefix = pressed.slice(0, prefixLen);\n        var mappedPrefix = mapped.slice(0, prefixLen);\n        return pressedPrefix == mappedPrefix && pressed.length > prefixLen ? 'full' :\n               mappedPrefix.indexOf(pressedPrefix) == 0 ? 'partial' : false;\n      } else {\n        return pressed == mapped ? 'full' :\n               mapped.indexOf(pressed) == 0 ? 'partial' : false;\n      }\n    }\n    function lastChar(keys) {\n      var match = /^.*(<[^>]+>)$/.exec(keys);\n      var selectedCharacter = match ? match[1] : keys.slice(-1);\n      if (selectedCharacter.length > 1){\n        switch(selectedCharacter){\n          case '<CR>':\n            selectedCharacter='\\n';\n            break;\n          case '<Space>':\n            selectedCharacter=' ';\n            break;\n          default:\n            selectedCharacter='';\n            break;\n        }\n      }\n      return selectedCharacter;\n    }\n    function repeatFn(cm, fn, repeat) {\n      return function() {\n        for (var i = 0; i < repeat; i++) {\n          fn(cm);\n        }\n      };\n    }\n    function copyCursor(cur) {\n      return Pos(cur.line, cur.ch);\n    }\n    function cursorEqual(cur1, cur2) {\n      return cur1.ch == cur2.ch && cur1.line == cur2.line;\n    }\n    function cursorIsBefore(cur1, cur2) {\n      if (cur1.line < cur2.line) {\n        return true;\n      }\n      if (cur1.line == cur2.line && cur1.ch < cur2.ch) {\n        return true;\n      }\n      return false;\n    }\n    function cursorMin(cur1, cur2) {\n      if (arguments.length > 2) {\n        cur2 = cursorMin.apply(undefined, Array.prototype.slice.call(arguments, 1));\n      }\n      return cursorIsBefore(cur1, cur2) ? cur1 : cur2;\n    }\n    function cursorMax(cur1, cur2) {\n      if (arguments.length > 2) {\n        cur2 = cursorMax.apply(undefined, Array.prototype.slice.call(arguments, 1));\n      }\n      return cursorIsBefore(cur1, cur2) ? cur2 : cur1;\n    }\n    function cursorIsBetween(cur1, cur2, cur3) {\n      var cur1before2 = cursorIsBefore(cur1, cur2);\n      var cur2before3 = cursorIsBefore(cur2, cur3);\n      return cur1before2 && cur2before3;\n    }\n    function lineLength(cm, lineNum) {\n      return cm.getLine(lineNum).length;\n    }\n    function trim(s) {\n      if (s.trim) {\n        return s.trim();\n      }\n      return s.replace(/^\\s+|\\s+$/g, '');\n    }\n    function escapeRegex(s) {\n      return s.replace(/([.?*+$\\[\\]\\/\\\\(){}|\\-])/g, '\\\\$1');\n    }\n    function extendLineToColumn(cm, lineNum, column) {\n      var endCh = lineLength(cm, lineNum);\n      var spaces = new Array(column-endCh+1).join(' ');\n      cm.setCursor(Pos(lineNum, endCh));\n      cm.replaceRange(spaces, cm.getCursor());\n    }\n    function selectBlock(cm, selectionEnd) {\n      var selections = [], ranges = cm.listSelections();\n      var head = copyCursor(cm.clipPos(selectionEnd));\n      var isClipped = !cursorEqual(selectionEnd, head);\n      var curHead = cm.getCursor('head');\n      var primIndex = getIndex(ranges, curHead);\n      var wasClipped = cursorEqual(ranges[primIndex].head, ranges[primIndex].anchor);\n      var max = ranges.length - 1;\n      var index = max - primIndex > primIndex ? max : 0;\n      var base = ranges[index].anchor;\n\n      var firstLine = Math.min(base.line, head.line);\n      var lastLine = Math.max(base.line, head.line);\n      var baseCh = base.ch, headCh = head.ch;\n\n      var dir = ranges[index].head.ch - baseCh;\n      var newDir = headCh - baseCh;\n      if (dir > 0 && newDir <= 0) {\n        baseCh++;\n        if (!isClipped) { headCh--; }\n      } else if (dir < 0 && newDir >= 0) {\n        baseCh--;\n        if (!wasClipped) { headCh++; }\n      } else if (dir < 0 && newDir == -1) {\n        baseCh--;\n        headCh++;\n      }\n      for (var line = firstLine; line <= lastLine; line++) {\n        var range = {anchor: new Pos(line, baseCh), head: new Pos(line, headCh)};\n        selections.push(range);\n      }\n      cm.setSelections(selections);\n      selectionEnd.ch = headCh;\n      base.ch = baseCh;\n      return base;\n    }\n    function selectForInsert(cm, head, height) {\n      var sel = [];\n      for (var i = 0; i < height; i++) {\n        var lineHead = offsetCursor(head, i, 0);\n        sel.push({anchor: lineHead, head: lineHead});\n      }\n      cm.setSelections(sel, 0);\n    }\n    function getIndex(ranges, cursor, end) {\n      for (var i = 0; i < ranges.length; i++) {\n        var atAnchor = end != 'head' && cursorEqual(ranges[i].anchor, cursor);\n        var atHead = end != 'anchor' && cursorEqual(ranges[i].head, cursor);\n        if (atAnchor || atHead) {\n          return i;\n        }\n      }\n      return -1;\n    }\n    function getSelectedAreaRange(cm, vim) {\n      var lastSelection = vim.lastSelection;\n      var getCurrentSelectedAreaRange = function() {\n        var selections = cm.listSelections();\n        var start =  selections[0];\n        var end = selections[selections.length-1];\n        var selectionStart = cursorIsBefore(start.anchor, start.head) ? start.anchor : start.head;\n        var selectionEnd = cursorIsBefore(end.anchor, end.head) ? end.head : end.anchor;\n        return [selectionStart, selectionEnd];\n      };\n      var getLastSelectedAreaRange = function() {\n        var selectionStart = cm.getCursor();\n        var selectionEnd = cm.getCursor();\n        var block = lastSelection.visualBlock;\n        if (block) {\n          var width = block.width;\n          var height = block.height;\n          selectionEnd = Pos(selectionStart.line + height, selectionStart.ch + width);\n          var selections = [];\n          for (var i = selectionStart.line; i < selectionEnd.line; i++) {\n            var anchor = Pos(i, selectionStart.ch);\n            var head = Pos(i, selectionEnd.ch);\n            var range = {anchor: anchor, head: head};\n            selections.push(range);\n          }\n          cm.setSelections(selections);\n        } else {\n          var start = lastSelection.anchorMark.find();\n          var end = lastSelection.headMark.find();\n          var line = end.line - start.line;\n          var ch = end.ch - start.ch;\n          selectionEnd = {line: selectionEnd.line + line, ch: line ? selectionEnd.ch : ch + selectionEnd.ch};\n          if (lastSelection.visualLine) {\n            selectionStart = Pos(selectionStart.line, 0);\n            selectionEnd = Pos(selectionEnd.line, lineLength(cm, selectionEnd.line));\n          }\n          cm.setSelection(selectionStart, selectionEnd);\n        }\n        return [selectionStart, selectionEnd];\n      };\n      if (!vim.visualMode) {\n        return getLastSelectedAreaRange();\n      } else {\n        return getCurrentSelectedAreaRange();\n      }\n    }\n    function updateLastSelection(cm, vim) {\n      var anchor = vim.sel.anchor;\n      var head = vim.sel.head;\n      if (vim.lastPastedText) {\n        head = cm.posFromIndex(cm.indexFromPos(anchor) + vim.lastPastedText.length);\n        vim.lastPastedText = null;\n      }\n      vim.lastSelection = {'anchorMark': cm.setBookmark(anchor),\n                           'headMark': cm.setBookmark(head),\n                           'anchor': copyCursor(anchor),\n                           'head': copyCursor(head),\n                           'visualMode': vim.visualMode,\n                           'visualLine': vim.visualLine,\n                           'visualBlock': vim.visualBlock};\n    }\n    function expandSelection(cm, start, end) {\n      var sel = cm.state.vim.sel;\n      var head = sel.head;\n      var anchor = sel.anchor;\n      var tmp;\n      if (cursorIsBefore(end, start)) {\n        tmp = end;\n        end = start;\n        start = tmp;\n      }\n      if (cursorIsBefore(head, anchor)) {\n        head = cursorMin(start, head);\n        anchor = cursorMax(anchor, end);\n      } else {\n        anchor = cursorMin(start, anchor);\n        head = cursorMax(head, end);\n        head = offsetCursor(head, 0, -1);\n        if (head.ch == -1 && head.line != cm.firstLine()) {\n          head = Pos(head.line - 1, lineLength(cm, head.line - 1));\n        }\n      }\n      return [anchor, head];\n    }\n    function updateCmSelection(cm, sel, mode) {\n      var vim = cm.state.vim;\n      sel = sel || vim.sel;\n      var mode = mode ||\n        vim.visualLine ? 'line' : vim.visualBlock ? 'block' : 'char';\n      var cmSel = makeCmSelection(cm, sel, mode);\n      cm.setSelections(cmSel.ranges, cmSel.primary);\n      updateFakeCursor(cm);\n    }\n    function makeCmSelection(cm, sel, mode, exclusive) {\n      var head = copyCursor(sel.head);\n      var anchor = copyCursor(sel.anchor);\n      if (mode == 'char') {\n        var headOffset = !exclusive && !cursorIsBefore(sel.head, sel.anchor) ? 1 : 0;\n        var anchorOffset = cursorIsBefore(sel.head, sel.anchor) ? 1 : 0;\n        head = offsetCursor(sel.head, 0, headOffset);\n        anchor = offsetCursor(sel.anchor, 0, anchorOffset);\n        return {\n          ranges: [{anchor: anchor, head: head}],\n          primary: 0\n        };\n      } else if (mode == 'line') {\n        if (!cursorIsBefore(sel.head, sel.anchor)) {\n          anchor.ch = 0;\n\n          var lastLine = cm.lastLine();\n          if (head.line > lastLine) {\n            head.line = lastLine;\n          }\n          head.ch = lineLength(cm, head.line);\n        } else {\n          head.ch = 0;\n          anchor.ch = lineLength(cm, anchor.line);\n        }\n        return {\n          ranges: [{anchor: anchor, head: head}],\n          primary: 0\n        };\n      } else if (mode == 'block') {\n        var top = Math.min(anchor.line, head.line),\n            left = Math.min(anchor.ch, head.ch),\n            bottom = Math.max(anchor.line, head.line),\n            right = Math.max(anchor.ch, head.ch) + 1;\n        var height = bottom - top + 1;\n        var primary = head.line == top ? 0 : height - 1;\n        var ranges = [];\n        for (var i = 0; i < height; i++) {\n          ranges.push({\n            anchor: Pos(top + i, left),\n            head: Pos(top + i, right)\n          });\n        }\n        return {\n          ranges: ranges,\n          primary: primary\n        };\n      }\n    }\n    function getHead(cm) {\n      var cur = cm.getCursor('head');\n      if (cm.getSelection().length == 1) {\n        cur = cursorMin(cur, cm.getCursor('anchor'));\n      }\n      return cur;\n    }\n    function exitVisualMode(cm, moveHead) {\n      var vim = cm.state.vim;\n      if (moveHead !== false) {\n        cm.setCursor(clipCursorToContent(cm, vim.sel.head));\n      }\n      updateLastSelection(cm, vim);\n      vim.visualMode = false;\n      vim.visualLine = false;\n      vim.visualBlock = false;\n      CodeMirror.signal(cm, \"vim-mode-change\", {mode: \"normal\"});\n      if (vim.fakeCursor) {\n        vim.fakeCursor.clear();\n      }\n    }\n    function clipToLine(cm, curStart, curEnd) {\n      var selection = cm.getRange(curStart, curEnd);\n      if (/\\n\\s*$/.test(selection)) {\n        var lines = selection.split('\\n');\n        lines.pop();\n        var line;\n        for (var line = lines.pop(); lines.length > 0 && line && isWhiteSpaceString(line); line = lines.pop()) {\n          curEnd.line--;\n          curEnd.ch = 0;\n        }\n        if (line) {\n          curEnd.line--;\n          curEnd.ch = lineLength(cm, curEnd.line);\n        } else {\n          curEnd.ch = 0;\n        }\n      }\n    }\n    function expandSelectionToLine(_cm, curStart, curEnd) {\n      curStart.ch = 0;\n      curEnd.ch = 0;\n      curEnd.line++;\n    }\n\n    function findFirstNonWhiteSpaceCharacter(text) {\n      if (!text) {\n        return 0;\n      }\n      var firstNonWS = text.search(/\\S/);\n      return firstNonWS == -1 ? text.length : firstNonWS;\n    }\n\n    function expandWordUnderCursor(cm, inclusive, _forward, bigWord, noSymbol) {\n      var cur = getHead(cm);\n      var line = cm.getLine(cur.line);\n      var idx = cur.ch;\n      var test = noSymbol ? wordCharTest[0] : bigWordCharTest [0];\n      while (!test(line.charAt(idx))) {\n        idx++;\n        if (idx >= line.length) { return null; }\n      }\n\n      if (bigWord) {\n        test = bigWordCharTest[0];\n      } else {\n        test = wordCharTest[0];\n        if (!test(line.charAt(idx))) {\n          test = wordCharTest[1];\n        }\n      }\n\n      var end = idx, start = idx;\n      while (test(line.charAt(end)) && end < line.length) { end++; }\n      while (test(line.charAt(start)) && start >= 0) { start--; }\n      start++;\n\n      if (inclusive) {\n        var wordEnd = end;\n        while (/\\s/.test(line.charAt(end)) && end < line.length) { end++; }\n        if (wordEnd == end) {\n          var wordStart = start;\n          while (/\\s/.test(line.charAt(start - 1)) && start > 0) { start--; }\n          if (!start) { start = wordStart; }\n        }\n      }\n      return { start: Pos(cur.line, start), end: Pos(cur.line, end) };\n    }\n\n    function recordJumpPosition(cm, oldCur, newCur) {\n      if (!cursorEqual(oldCur, newCur)) {\n        vimGlobalState.jumpList.add(cm, oldCur, newCur);\n      }\n    }\n\n    function recordLastCharacterSearch(increment, args) {\n        vimGlobalState.lastCharacterSearch.increment = increment;\n        vimGlobalState.lastCharacterSearch.forward = args.forward;\n        vimGlobalState.lastCharacterSearch.selectedCharacter = args.selectedCharacter;\n    }\n\n    var symbolToMode = {\n        '(': 'bracket', ')': 'bracket', '{': 'bracket', '}': 'bracket',\n        '[': 'section', ']': 'section',\n        '*': 'comment', '/': 'comment',\n        'm': 'method', 'M': 'method',\n        '#': 'preprocess'\n    };\n    var findSymbolModes = {\n      bracket: {\n        isComplete: function(state) {\n          if (state.nextCh === state.symb) {\n            state.depth++;\n            if (state.depth >= 1)return true;\n          } else if (state.nextCh === state.reverseSymb) {\n            state.depth--;\n          }\n          return false;\n        }\n      },\n      section: {\n        init: function(state) {\n          state.curMoveThrough = true;\n          state.symb = (state.forward ? ']' : '[') === state.symb ? '{' : '}';\n        },\n        isComplete: function(state) {\n          return state.index === 0 && state.nextCh === state.symb;\n        }\n      },\n      comment: {\n        isComplete: function(state) {\n          var found = state.lastCh === '*' && state.nextCh === '/';\n          state.lastCh = state.nextCh;\n          return found;\n        }\n      },\n      method: {\n        init: function(state) {\n          state.symb = (state.symb === 'm' ? '{' : '}');\n          state.reverseSymb = state.symb === '{' ? '}' : '{';\n        },\n        isComplete: function(state) {\n          if (state.nextCh === state.symb)return true;\n          return false;\n        }\n      },\n      preprocess: {\n        init: function(state) {\n          state.index = 0;\n        },\n        isComplete: function(state) {\n          if (state.nextCh === '#') {\n            var token = state.lineText.match(/#(\\w+)/)[1];\n            if (token === 'endif') {\n              if (state.forward && state.depth === 0) {\n                return true;\n              }\n              state.depth++;\n            } else if (token === 'if') {\n              if (!state.forward && state.depth === 0) {\n                return true;\n              }\n              state.depth--;\n            }\n            if (token === 'else' && state.depth === 0)return true;\n          }\n          return false;\n        }\n      }\n    };\n    function findSymbol(cm, repeat, forward, symb) {\n      var cur = copyCursor(cm.getCursor());\n      var increment = forward ? 1 : -1;\n      var endLine = forward ? cm.lineCount() : -1;\n      var curCh = cur.ch;\n      var line = cur.line;\n      var lineText = cm.getLine(line);\n      var state = {\n        lineText: lineText,\n        nextCh: lineText.charAt(curCh),\n        lastCh: null,\n        index: curCh,\n        symb: symb,\n        reverseSymb: (forward ?  { ')': '(', '}': '{' } : { '(': ')', '{': '}' })[symb],\n        forward: forward,\n        depth: 0,\n        curMoveThrough: false\n      };\n      var mode = symbolToMode[symb];\n      if (!mode)return cur;\n      var init = findSymbolModes[mode].init;\n      var isComplete = findSymbolModes[mode].isComplete;\n      if (init) { init(state); }\n      while (line !== endLine && repeat) {\n        state.index += increment;\n        state.nextCh = state.lineText.charAt(state.index);\n        if (!state.nextCh) {\n          line += increment;\n          state.lineText = cm.getLine(line) || '';\n          if (increment > 0) {\n            state.index = 0;\n          } else {\n            var lineLen = state.lineText.length;\n            state.index = (lineLen > 0) ? (lineLen-1) : 0;\n          }\n          state.nextCh = state.lineText.charAt(state.index);\n        }\n        if (isComplete(state)) {\n          cur.line = line;\n          cur.ch = state.index;\n          repeat--;\n        }\n      }\n      if (state.nextCh || state.curMoveThrough) {\n        return Pos(line, state.index);\n      }\n      return cur;\n    }\n    function findWord(cm, cur, forward, bigWord, emptyLineIsWord) {\n      var lineNum = cur.line;\n      var pos = cur.ch;\n      var line = cm.getLine(lineNum);\n      var dir = forward ? 1 : -1;\n      var charTests = bigWord ? bigWordCharTest: wordCharTest;\n\n      if (emptyLineIsWord && line == '') {\n        lineNum += dir;\n        line = cm.getLine(lineNum);\n        if (!isLine(cm, lineNum)) {\n          return null;\n        }\n        pos = (forward) ? 0 : line.length;\n      }\n\n      while (true) {\n        if (emptyLineIsWord && line == '') {\n          return { from: 0, to: 0, line: lineNum };\n        }\n        var stop = (dir > 0) ? line.length : -1;\n        var wordStart = stop, wordEnd = stop;\n        while (pos != stop) {\n          var foundWord = false;\n          for (var i = 0; i < charTests.length && !foundWord; ++i) {\n            if (charTests[i](line.charAt(pos))) {\n              wordStart = pos;\n              while (pos != stop && charTests[i](line.charAt(pos))) {\n                pos += dir;\n              }\n              wordEnd = pos;\n              foundWord = wordStart != wordEnd;\n              if (wordStart == cur.ch && lineNum == cur.line &&\n                  wordEnd == wordStart + dir) {\n                continue;\n              } else {\n                return {\n                  from: Math.min(wordStart, wordEnd + 1),\n                  to: Math.max(wordStart, wordEnd),\n                  line: lineNum };\n              }\n            }\n          }\n          if (!foundWord) {\n            pos += dir;\n          }\n        }\n        lineNum += dir;\n        if (!isLine(cm, lineNum)) {\n          return null;\n        }\n        line = cm.getLine(lineNum);\n        pos = (dir > 0) ? 0 : line.length;\n      }\n    }\n    function moveToWord(cm, cur, repeat, forward, wordEnd, bigWord) {\n      var curStart = copyCursor(cur);\n      var words = [];\n      if (forward && !wordEnd || !forward && wordEnd) {\n        repeat++;\n      }\n      var emptyLineIsWord = !(forward && wordEnd);\n      for (var i = 0; i < repeat; i++) {\n        var word = findWord(cm, cur, forward, bigWord, emptyLineIsWord);\n        if (!word) {\n          var eodCh = lineLength(cm, cm.lastLine());\n          words.push(forward\n              ? {line: cm.lastLine(), from: eodCh, to: eodCh}\n              : {line: 0, from: 0, to: 0});\n          break;\n        }\n        words.push(word);\n        cur = Pos(word.line, forward ? (word.to - 1) : word.from);\n      }\n      var shortCircuit = words.length != repeat;\n      var firstWord = words[0];\n      var lastWord = words.pop();\n      if (forward && !wordEnd) {\n        if (!shortCircuit && (firstWord.from != curStart.ch || firstWord.line != curStart.line)) {\n          lastWord = words.pop();\n        }\n        return Pos(lastWord.line, lastWord.from);\n      } else if (forward && wordEnd) {\n        return Pos(lastWord.line, lastWord.to - 1);\n      } else if (!forward && wordEnd) {\n        if (!shortCircuit && (firstWord.to != curStart.ch || firstWord.line != curStart.line)) {\n          lastWord = words.pop();\n        }\n        return Pos(lastWord.line, lastWord.to);\n      } else {\n        return Pos(lastWord.line, lastWord.from);\n      }\n    }\n\n    function moveToCharacter(cm, repeat, forward, character) {\n      var cur = cm.getCursor();\n      var start = cur.ch;\n      var idx;\n      for (var i = 0; i < repeat; i ++) {\n        var line = cm.getLine(cur.line);\n        idx = charIdxInLine(start, line, character, forward, true);\n        if (idx == -1) {\n          return null;\n        }\n        start = idx;\n      }\n      return Pos(cm.getCursor().line, idx);\n    }\n\n    function moveToColumn(cm, repeat) {\n      var line = cm.getCursor().line;\n      return clipCursorToContent(cm, Pos(line, repeat - 1));\n    }\n\n    function updateMark(cm, vim, markName, pos) {\n      if (!inArray(markName, validMarks)) {\n        return;\n      }\n      if (vim.marks[markName]) {\n        vim.marks[markName].clear();\n      }\n      vim.marks[markName] = cm.setBookmark(pos);\n    }\n\n    function charIdxInLine(start, line, character, forward, includeChar) {\n      var idx;\n      if (forward) {\n        idx = line.indexOf(character, start + 1);\n        if (idx != -1 && !includeChar) {\n          idx -= 1;\n        }\n      } else {\n        idx = line.lastIndexOf(character, start - 1);\n        if (idx != -1 && !includeChar) {\n          idx += 1;\n        }\n      }\n      return idx;\n    }\n\n    function findParagraph(cm, head, repeat, dir, inclusive) {\n      var line = head.line;\n      var min = cm.firstLine();\n      var max = cm.lastLine();\n      var start, end, i = line;\n      function isEmpty(i) { return !/\\S/.test(cm.getLine(i)); } // ace_patch\n      function isBoundary(i, dir, any) {\n        if (any) { return isEmpty(i) != isEmpty(i + dir); }\n        return !isEmpty(i) && isEmpty(i + dir);\n      }\n      function skipFold(i) {\n          dir = dir > 0 ? 1 : -1;\n          var foldLine = cm.ace.session.getFoldLine(i);\n          if (foldLine) {\n              if (i + dir > foldLine.start.row && i + dir < foldLine.end.row)\n                  dir = (dir > 0 ? foldLine.end.row : foldLine.start.row) - i;\n          }\n      }\n      if (dir) {\n        while (min <= i && i <= max && repeat > 0) {\n          skipFold(i);\n          if (isBoundary(i, dir)) { repeat--; }\n          i += dir;\n        }\n        return new Pos(i, 0);\n      }\n\n      var vim = cm.state.vim;\n      if (vim.visualLine && isBoundary(line, 1, true)) {\n        var anchor = vim.sel.anchor;\n        if (isBoundary(anchor.line, -1, true)) {\n          if (!inclusive || anchor.line != line) {\n            line += 1;\n          }\n        }\n      }\n      var startState = isEmpty(line);\n      for (i = line; i <= max && repeat; i++) {\n        if (isBoundary(i, 1, true)) {\n          if (!inclusive || isEmpty(i) != startState) {\n            repeat--;\n          }\n        }\n      }\n      end = new Pos(i, 0);\n      if (i > max && !startState) { startState = true; }\n      else { inclusive = false; }\n      for (i = line; i > min; i--) {\n        if (!inclusive || isEmpty(i) == startState || i == line) {\n          if (isBoundary(i, -1, true)) { break; }\n        }\n      }\n      start = new Pos(i, 0);\n      return { start: start, end: end };\n    }\n\n    function findSentence(cm, cur, repeat, dir) {\n      function nextChar(cm, idx) {\n        if (idx.pos + idx.dir < 0 || idx.pos + idx.dir >= idx.line.length) {\n          idx.ln += idx.dir;\n          if (!isLine(cm, idx.ln)) {\n            idx.line = null;\n            idx.ln = null;\n            idx.pos = null;\n            return;\n          }\n          idx.line = cm.getLine(idx.ln);\n          idx.pos = (idx.dir > 0) ? 0 : idx.line.length - 1;\n        }\n        else {\n          idx.pos += idx.dir;\n        }\n      }\n      function forward(cm, ln, pos, dir) {\n        var line = cm.getLine(ln);\n        var stop = (line === \"\");\n\n        var curr = {\n          line: line,\n          ln: ln,\n          pos: pos,\n          dir: dir,\n        }\n\n        var last_valid = {\n          ln: curr.ln,\n          pos: curr.pos,\n        }\n\n        var skip_empty_lines = (curr.line === \"\");\n        nextChar(cm, curr);\n\n        while (curr.line !== null) {\n          last_valid.ln = curr.ln;\n          last_valid.pos = curr.pos;\n\n          if (curr.line === \"\" && !skip_empty_lines) {\n            return { ln: curr.ln, pos: curr.pos, };\n          }\n          else if (stop && curr.line !== \"\" && !isWhiteSpaceString(curr.line[curr.pos])) {\n            return { ln: curr.ln, pos: curr.pos, };\n          }\n          else if (isEndOfSentenceSymbol(curr.line[curr.pos])\n            && !stop\n            && (curr.pos === curr.line.length - 1\n              || isWhiteSpaceString(curr.line[curr.pos + 1]))) {\n            stop = true;\n          }\n\n          nextChar(cm, curr);\n        }\n        var line = cm.getLine(last_valid.ln);\n        last_valid.pos = 0;\n        for(var i = line.length - 1; i >= 0; --i) {\n          if (!isWhiteSpaceString(line[i])) {\n            last_valid.pos = i;\n            break;\n          }\n        }\n\n        return last_valid;\n\n      }\n      function reverse(cm, ln, pos, dir) {\n        var line = cm.getLine(ln);\n\n        var curr = {\n          line: line,\n          ln: ln,\n          pos: pos,\n          dir: dir,\n        }\n\n        var last_valid = {\n          ln: curr.ln,\n          pos: null,\n        };\n\n        var skip_empty_lines = (curr.line === \"\");\n        nextChar(cm, curr);\n\n        while (curr.line !== null) {\n\n          if (curr.line === \"\" && !skip_empty_lines) {\n            if (last_valid.pos !== null) {\n              return last_valid;\n            }\n            else {\n              return { ln: curr.ln, pos: curr.pos };\n            }\n          }\n          else if (isEndOfSentenceSymbol(curr.line[curr.pos])\n              && last_valid.pos !== null\n              && !(curr.ln === last_valid.ln && curr.pos + 1 === last_valid.pos)) {\n            return last_valid;\n          }\n          else if (curr.line !== \"\" && !isWhiteSpaceString(curr.line[curr.pos])) {\n            skip_empty_lines = false;\n            last_valid = { ln: curr.ln, pos: curr.pos }\n          }\n\n          nextChar(cm, curr);\n        }\n        var line = cm.getLine(last_valid.ln);\n        last_valid.pos = 0;\n        for(var i = 0; i < line.length; ++i) {\n          if (!isWhiteSpaceString(line[i])) {\n            last_valid.pos = i;\n            break;\n          }\n        }\n        return last_valid;\n      }\n\n      var curr_index = {\n        ln: cur.line,\n        pos: cur.ch,\n      };\n\n      while (repeat > 0) {\n        if (dir < 0) {\n          curr_index = reverse(cm, curr_index.ln, curr_index.pos, dir);\n        }\n        else {\n          curr_index = forward(cm, curr_index.ln, curr_index.pos, dir);\n        }\n        repeat--;\n      }\n\n      return Pos(curr_index.ln, curr_index.pos);\n    }\n    function selectCompanionObject(cm, head, symb, inclusive) {\n      var cur = head, start, end;\n\n      var bracketRegexp = ({\n        '(': /[()]/, ')': /[()]/,\n        '[': /[[\\]]/, ']': /[[\\]]/,\n        '{': /[{}]/, '}': /[{}]/,\n        '<': /[<>]/, '>': /[<>]/})[symb];\n      var openSym = ({\n        '(': '(', ')': '(',\n        '[': '[', ']': '[',\n        '{': '{', '}': '{',\n        '<': '<', '>': '<'})[symb];\n      var curChar = cm.getLine(cur.line).charAt(cur.ch);\n      var offset = curChar === openSym ? 1 : 0;\n\n      start = cm.scanForBracket(Pos(cur.line, cur.ch + offset), -1, undefined, {'bracketRegex': bracketRegexp});\n      end = cm.scanForBracket(Pos(cur.line, cur.ch + offset), 1, undefined, {'bracketRegex': bracketRegexp});\n\n      if (!start || !end) {\n        return { start: cur, end: cur };\n      }\n\n      start = start.pos;\n      end = end.pos;\n\n      if ((start.line == end.line && start.ch > end.ch)\n          || (start.line > end.line)) {\n        var tmp = start;\n        start = end;\n        end = tmp;\n      }\n\n      if (inclusive) {\n        end.ch += 1;\n      } else {\n        start.ch += 1;\n      }\n\n      return { start: start, end: end };\n    }\n    function findBeginningAndEnd(cm, head, symb, inclusive) {\n      var cur = copyCursor(head);\n      var line = cm.getLine(cur.line);\n      var chars = line.split('');\n      var start, end, i, len;\n      var firstIndex = chars.indexOf(symb);\n      if (cur.ch < firstIndex) {\n        cur.ch = firstIndex;\n      }\n      else if (firstIndex < cur.ch && chars[cur.ch] == symb) {\n        end = cur.ch; // assign end to the current cursor\n        --cur.ch; // make sure to look backwards\n      }\n      if (chars[cur.ch] == symb && !end) {\n        start = cur.ch + 1; // assign start to ahead of the cursor\n      } else {\n        for (i = cur.ch; i > -1 && !start; i--) {\n          if (chars[i] == symb) {\n            start = i + 1;\n          }\n        }\n      }\n      if (start && !end) {\n        for (i = start, len = chars.length; i < len && !end; i++) {\n          if (chars[i] == symb) {\n            end = i;\n          }\n        }\n      }\n      if (!start || !end) {\n        return { start: cur, end: cur };\n      }\n      if (inclusive) {\n        --start; ++end;\n      }\n\n      return {\n        start: Pos(cur.line, start),\n        end: Pos(cur.line, end)\n      };\n    }\n    defineOption('pcre', true, 'boolean');\n    function SearchState() {}\n    SearchState.prototype = {\n      getQuery: function() {\n        return vimGlobalState.query;\n      },\n      setQuery: function(query) {\n        vimGlobalState.query = query;\n      },\n      getOverlay: function() {\n        return this.searchOverlay;\n      },\n      setOverlay: function(overlay) {\n        this.searchOverlay = overlay;\n      },\n      isReversed: function() {\n        return vimGlobalState.isReversed;\n      },\n      setReversed: function(reversed) {\n        vimGlobalState.isReversed = reversed;\n      },\n      getScrollbarAnnotate: function() {\n        return this.annotate;\n      },\n      setScrollbarAnnotate: function(annotate) {\n        this.annotate = annotate;\n      }\n    };\n    function getSearchState(cm) {\n      var vim = cm.state.vim;\n      return vim.searchState_ || (vim.searchState_ = new SearchState());\n    }\n    function dialog(cm, template, shortText, onClose, options) {\n      if (cm.openDialog) {\n        cm.openDialog(template, onClose, { bottom: true, value: options.value,\n            onKeyDown: options.onKeyDown, onKeyUp: options.onKeyUp,\n            selectValueOnOpen: false, onClose: function() {\n              if (cm.state.vim) {\n                cm.state.vim.status = \"\";\n                cm.ace.renderer.$loop.schedule(cm.ace.renderer.CHANGE_CURSOR);\n              }\n            }});\n      }\n      else {\n        onClose(prompt(shortText, ''));\n      }\n    }\n    function splitBySlash(argString) {\n      return splitBySeparator(argString, '/');\n    }\n\n    function findUnescapedSlashes(argString) {\n      return findUnescapedSeparators(argString, '/');\n    }\n\n    function splitBySeparator(argString, separator) {\n      var slashes = findUnescapedSeparators(argString, separator) || [];\n      if (!slashes.length) return [];\n      var tokens = [];\n      if (slashes[0] !== 0) return;\n      for (var i = 0; i < slashes.length; i++) {\n        if (typeof slashes[i] == 'number')\n          tokens.push(argString.substring(slashes[i] + 1, slashes[i+1]));\n      }\n      return tokens;\n    }\n\n    function findUnescapedSeparators(str, separator) {\n      if (!separator)\n        separator = '/';\n\n      var escapeNextChar = false;\n      var slashes = [];\n      for (var i = 0; i < str.length; i++) {\n        var c = str.charAt(i);\n        if (!escapeNextChar && c == separator) {\n          slashes.push(i);\n        }\n        escapeNextChar = !escapeNextChar && (c == '\\\\');\n      }\n      return slashes;\n    }\n    function translateRegex(str) {\n      var specials = '|(){';\n      var unescape = '}';\n      var escapeNextChar = false;\n      var out = [];\n      for (var i = -1; i < str.length; i++) {\n        var c = str.charAt(i) || '';\n        var n = str.charAt(i+1) || '';\n        var specialComesNext = (n && specials.indexOf(n) != -1);\n        if (escapeNextChar) {\n          if (c !== '\\\\' || !specialComesNext) {\n            out.push(c);\n          }\n          escapeNextChar = false;\n        } else {\n          if (c === '\\\\') {\n            escapeNextChar = true;\n            if (n && unescape.indexOf(n) != -1) {\n              specialComesNext = true;\n            }\n            if (!specialComesNext || n === '\\\\') {\n              out.push(c);\n            }\n          } else {\n            out.push(c);\n            if (specialComesNext && n !== '\\\\') {\n              out.push('\\\\');\n            }\n          }\n        }\n      }\n      return out.join('');\n    }\n    var charUnescapes = {'\\\\n': '\\n', '\\\\r': '\\r', '\\\\t': '\\t'};\n    function translateRegexReplace(str) {\n      var escapeNextChar = false;\n      var out = [];\n      for (var i = -1; i < str.length; i++) {\n        var c = str.charAt(i) || '';\n        var n = str.charAt(i+1) || '';\n        if (charUnescapes[c + n]) {\n          out.push(charUnescapes[c+n]);\n          i++;\n        } else if (escapeNextChar) {\n          out.push(c);\n          escapeNextChar = false;\n        } else {\n          if (c === '\\\\') {\n            escapeNextChar = true;\n            if ((isNumber(n) || n === '$')) {\n              out.push('$');\n            } else if (n !== '/' && n !== '\\\\') {\n              out.push('\\\\');\n            }\n          } else {\n            if (c === '$') {\n              out.push('$');\n            }\n            out.push(c);\n            if (n === '/') {\n              out.push('\\\\');\n            }\n          }\n        }\n      }\n      return out.join('');\n    }\n    var unescapes = {'\\\\/': '/', '\\\\\\\\': '\\\\', '\\\\n': '\\n', '\\\\r': '\\r', '\\\\t': '\\t'};\n    function unescapeRegexReplace(str) {\n      var stream = new CodeMirror.StringStream(str);\n      var output = [];\n      while (!stream.eol()) {\n        while (stream.peek() && stream.peek() != '\\\\') {\n          output.push(stream.next());\n        }\n        var matched = false;\n        for (var matcher in unescapes) {\n          if (stream.match(matcher, true)) {\n            matched = true;\n            output.push(unescapes[matcher]);\n            break;\n          }\n        }\n        if (!matched) {\n          output.push(stream.next());\n        }\n      }\n      return output.join('');\n    }\n    function parseQuery(query, ignoreCase, smartCase) {\n      var lastSearchRegister = vimGlobalState.registerController.getRegister('/');\n      lastSearchRegister.setText(query);\n      if (query instanceof RegExp) { return query; }\n      var slashes = findUnescapedSlashes(query);\n      var regexPart;\n      var forceIgnoreCase;\n      if (!slashes.length) {\n        regexPart = query;\n      } else {\n        regexPart = query.substring(0, slashes[0]);\n        var flagsPart = query.substring(slashes[0]);\n        forceIgnoreCase = (flagsPart.indexOf('i') != -1);\n      }\n      if (!regexPart) {\n        return null;\n      }\n      if (!getOption('pcre')) {\n        regexPart = translateRegex(regexPart);\n      }\n      if (smartCase) {\n        ignoreCase = (/^[^A-Z]*$/).test(regexPart);\n      }\n      var regexp = new RegExp(regexPart,\n          (ignoreCase || forceIgnoreCase) ? 'i' : undefined);\n      return regexp;\n    }\n    function showConfirm(cm, text) {\n      if (cm.openNotification) {\n        cm.openNotification('<span style=\"color: red\">' + text + '</span>',\n                            {bottom: true, duration: 5000});\n      } else {\n        alert(text);\n      }\n    }\n    function makePrompt(prefix, desc) {\n      var raw = '<span style=\"font-family: monospace; white-space: pre\">' +\n          (prefix || \"\") + '<input type=\"text\" autocorrect=\"off\" autocapitalize=\"none\" autocomplete=\"off\"></span>';\n      if (desc)\n        raw += ' <span style=\"color: #888\">' + desc + '</span>';\n      return raw;\n    }\n    var searchPromptDesc = '(Javascript regexp)';\n    function showPrompt(cm, options) {\n      var shortText = (options.prefix || '') + ' ' + (options.desc || '');\n      var prompt = makePrompt(options.prefix, options.desc);\n      dialog(cm, prompt, shortText, options.onClose, options);\n    }\n    function regexEqual(r1, r2) {\n      if (r1 instanceof RegExp && r2 instanceof RegExp) {\n          var props = ['global', 'multiline', 'ignoreCase', 'source'];\n          for (var i = 0; i < props.length; i++) {\n              var prop = props[i];\n              if (r1[prop] !== r2[prop]) {\n                  return false;\n              }\n          }\n          return true;\n      }\n      return false;\n    }\n    function updateSearchQuery(cm, rawQuery, ignoreCase, smartCase) {\n      if (!rawQuery) {\n        return;\n      }\n      var state = getSearchState(cm);\n      var query = parseQuery(rawQuery, !!ignoreCase, !!smartCase);\n      if (!query) {\n        return;\n      }\n      highlightSearchMatches(cm, query);\n      if (regexEqual(query, state.getQuery())) {\n        return query;\n      }\n      state.setQuery(query);\n      return query;\n    }\n    function searchOverlay(query) {\n      if (query.source.charAt(0) == '^') {\n        var matchSol = true;\n      }\n      return {\n        token: function(stream) {\n          if (matchSol && !stream.sol()) {\n            stream.skipToEnd();\n            return;\n          }\n          var match = stream.match(query, false);\n          if (match) {\n            if (match[0].length == 0) {\n              stream.next();\n              return 'searching';\n            }\n            if (!stream.sol()) {\n              stream.backUp(1);\n              if (!query.exec(stream.next() + match[0])) {\n                stream.next();\n                return null;\n              }\n            }\n            stream.match(query);\n            return 'searching';\n          }\n          while (!stream.eol()) {\n            stream.next();\n            if (stream.match(query, false)) break;\n          }\n        },\n        query: query\n      };\n    }\n    function highlightSearchMatches(cm, query) {\n      var searchState = getSearchState(cm);\n      var overlay = searchState.getOverlay();\n      if (!overlay || query != overlay.query) {\n        if (overlay) {\n          cm.removeOverlay(overlay);\n        }\n        overlay = searchOverlay(query);\n        cm.addOverlay(overlay);\n        if (cm.showMatchesOnScrollbar) {\n          if (searchState.getScrollbarAnnotate()) {\n            searchState.getScrollbarAnnotate().clear();\n          }\n          searchState.setScrollbarAnnotate(cm.showMatchesOnScrollbar(query));\n        }\n        searchState.setOverlay(overlay);\n      }\n    }\n    function findNext(cm, prev, query, repeat) {\n      if (repeat === undefined) { repeat = 1; }\n      return cm.operation(function() {\n        var pos = cm.getCursor();\n        var cursor = cm.getSearchCursor(query, pos);\n        for (var i = 0; i < repeat; i++) {\n          var found = cursor.find(prev);\n          if (i == 0 && found && cursorEqual(cursor.from(), pos)) { found = cursor.find(prev); }\n          if (!found) {\n            cursor = cm.getSearchCursor(query,\n                (prev) ? Pos(cm.lastLine()) : Pos(cm.firstLine(), 0) );\n            if (!cursor.find(prev)) {\n              return;\n            }\n          }\n        }\n        return cursor.from();\n      });\n    }\n    function clearSearchHighlight(cm) {\n      var state = getSearchState(cm);\n      cm.removeOverlay(getSearchState(cm).getOverlay());\n      state.setOverlay(null);\n      if (state.getScrollbarAnnotate()) {\n        state.getScrollbarAnnotate().clear();\n        state.setScrollbarAnnotate(null);\n      }\n    }\n    function isInRange(pos, start, end) {\n      if (typeof pos != 'number') {\n        pos = pos.line;\n      }\n      if (start instanceof Array) {\n        return inArray(pos, start);\n      } else {\n        if (end) {\n          return (pos >= start && pos <= end);\n        } else {\n          return pos == start;\n        }\n      }\n    }\n    function getUserVisibleLines(cm) {\n      var renderer = cm.ace.renderer;\n      return {\n        top: renderer.getFirstFullyVisibleRow(),\n        bottom: renderer.getLastFullyVisibleRow()\n      }\n    }\n\n    function getMarkPos(cm, vim, markName) {\n      if (markName == '\\'' || markName == '`') {\n        return vimGlobalState.jumpList.find(cm, -1) || Pos(0, 0);\n      } else if (markName == '.') {\n        return getLastEditPos(cm);\n      }\n\n      var mark = vim.marks[markName];\n      return mark && mark.find();\n    }\n\n    function getLastEditPos(cm) {\n      var undoManager = cm.ace.session.$undoManager;\n      if (undoManager && undoManager.$lastDelta)\n        return toCmPos(undoManager.$lastDelta.end);\n    }\n\n    var ExCommandDispatcher = function() {\n      this.buildCommandMap_();\n    };\n    ExCommandDispatcher.prototype = {\n      processCommand: function(cm, input, opt_params) {\n        var that = this;\n        cm.operation(function () {\n          cm.curOp.isVimOp = true;\n          that._processCommand(cm, input, opt_params);\n        });\n      },\n      _processCommand: function(cm, input, opt_params) {\n        var vim = cm.state.vim;\n        var commandHistoryRegister = vimGlobalState.registerController.getRegister(':');\n        var previousCommand = commandHistoryRegister.toString();\n        if (vim.visualMode) {\n          exitVisualMode(cm);\n        }\n        var inputStream = new CodeMirror.StringStream(input);\n        commandHistoryRegister.setText(input);\n        var params = opt_params || {};\n        params.input = input;\n        try {\n          this.parseInput_(cm, inputStream, params);\n        } catch(e) {\n          showConfirm(cm, e);\n          throw e;\n        }\n        var command;\n        var commandName;\n        if (!params.commandName) {\n          if (params.line !== undefined) {\n            commandName = 'move';\n          }\n        } else {\n          command = this.matchCommand_(params.commandName);\n          if (command) {\n            commandName = command.name;\n            if (command.excludeFromCommandHistory) {\n              commandHistoryRegister.setText(previousCommand);\n            }\n            this.parseCommandArgs_(inputStream, params, command);\n            if (command.type == 'exToKey') {\n              for (var i = 0; i < command.toKeys.length; i++) {\n                CodeMirror.Vim.handleKey(cm, command.toKeys[i], 'mapping');\n              }\n              return;\n            } else if (command.type == 'exToEx') {\n              this.processCommand(cm, command.toInput);\n              return;\n            }\n          }\n        }\n        if (!commandName) {\n          showConfirm(cm, 'Not an editor command \":' + input + '\"');\n          return;\n        }\n        try {\n          exCommands[commandName](cm, params);\n          if ((!command || !command.possiblyAsync) && params.callback) {\n            params.callback();\n          }\n        } catch(e) {\n          showConfirm(cm, e);\n          throw e;\n        }\n      },\n      parseInput_: function(cm, inputStream, result) {\n        inputStream.eatWhile(':');\n        if (inputStream.eat('%')) {\n          result.line = cm.firstLine();\n          result.lineEnd = cm.lastLine();\n        } else {\n          result.line = this.parseLineSpec_(cm, inputStream);\n          if (result.line !== undefined && inputStream.eat(',')) {\n            result.lineEnd = this.parseLineSpec_(cm, inputStream);\n          }\n        }\n        var commandMatch = inputStream.match(/^(\\w+)/);\n        if (commandMatch) {\n          result.commandName = commandMatch[1];\n        } else {\n          result.commandName = inputStream.match(/.*/)[0];\n        }\n\n        return result;\n      },\n      parseLineSpec_: function(cm, inputStream) {\n        var numberMatch = inputStream.match(/^(\\d+)/);\n        if (numberMatch) {\n          return parseInt(numberMatch[1], 10) - 1;\n        }\n        switch (inputStream.next()) {\n          case '.':\n            return this.parseLineSpecOffset_(inputStream, cm.getCursor().line);\n          case '$':\n            return this.parseLineSpecOffset_(inputStream, cm.lastLine());\n          case '\\'':\n            var markName = inputStream.next();\n            var markPos = getMarkPos(cm, cm.state.vim, markName);\n            if (!markPos) throw new Error('Mark not set');\n            return this.parseLineSpecOffset_(inputStream, markPos.line);\n          case '-':\n          case '+':\n            inputStream.backUp(1);\n            return this.parseLineSpecOffset_(inputStream, cm.getCursor().line);\n          default:\n            inputStream.backUp(1);\n            return undefined;\n        }\n      },\n      parseLineSpecOffset_: function(inputStream, line) {\n        var offsetMatch = inputStream.match(/^([+-])?(\\d+)/);\n        if (offsetMatch) {\n          var offset = parseInt(offsetMatch[2], 10);\n          if (offsetMatch[1] == \"-\") {\n            line -= offset;\n          } else {\n            line += offset;\n          }\n        }\n        return line;\n      },\n      parseCommandArgs_: function(inputStream, params, command) {\n        if (inputStream.eol()) {\n          return;\n        }\n        params.argString = inputStream.match(/.*/)[0];\n        var delim = command.argDelimiter || /\\s+/;\n        var args = trim(params.argString).split(delim);\n        if (args.length && args[0]) {\n          params.args = args;\n        }\n      },\n      matchCommand_: function(commandName) {\n        for (var i = commandName.length; i > 0; i--) {\n          var prefix = commandName.substring(0, i);\n          if (this.commandMap_[prefix]) {\n            var command = this.commandMap_[prefix];\n            if (command.name.indexOf(commandName) === 0) {\n              return command;\n            }\n          }\n        }\n        return null;\n      },\n      buildCommandMap_: function() {\n        this.commandMap_ = {};\n        for (var i = 0; i < defaultExCommandMap.length; i++) {\n          var command = defaultExCommandMap[i];\n          var key = command.shortName || command.name;\n          this.commandMap_[key] = command;\n        }\n      },\n      map: function(lhs, rhs, ctx) {\n        if (lhs != ':' && lhs.charAt(0) == ':') {\n          if (ctx) { throw Error('Mode not supported for ex mappings'); }\n          var commandName = lhs.substring(1);\n          if (rhs != ':' && rhs.charAt(0) == ':') {\n            this.commandMap_[commandName] = {\n              name: commandName,\n              type: 'exToEx',\n              toInput: rhs.substring(1),\n              user: true\n            };\n          } else {\n            this.commandMap_[commandName] = {\n              name: commandName,\n              type: 'exToKey',\n              toKeys: rhs,\n              user: true\n            };\n          }\n        } else {\n          if (rhs != ':' && rhs.charAt(0) == ':') {\n            var mapping = {\n              keys: lhs,\n              type: 'keyToEx',\n              exArgs: { input: rhs.substring(1) }\n            };\n            if (ctx) { mapping.context = ctx; }\n            defaultKeymap.unshift(mapping);\n          } else {\n            var mapping = {\n              keys: lhs,\n              type: 'keyToKey',\n              toKeys: rhs\n            };\n            if (ctx) { mapping.context = ctx; }\n            defaultKeymap.unshift(mapping);\n          }\n        }\n      },\n      unmap: function(lhs, ctx) {\n        if (lhs != ':' && lhs.charAt(0) == ':') {\n          if (ctx) { throw Error('Mode not supported for ex mappings'); }\n          var commandName = lhs.substring(1);\n          if (this.commandMap_[commandName] && this.commandMap_[commandName].user) {\n            delete this.commandMap_[commandName];\n            return;\n          }\n        } else {\n          var keys = lhs;\n          for (var i = 0; i < defaultKeymap.length; i++) {\n            if (keys == defaultKeymap[i].keys\n                && defaultKeymap[i].context === ctx) {\n              defaultKeymap.splice(i, 1);\n              return;\n            }\n          }\n        }\n      }\n    };\n\n    var exCommands = {\n      colorscheme: function(cm, params) {\n        if (!params.args || params.args.length < 1) {\n          showConfirm(cm, cm.getOption('theme'));\n          return;\n        }\n        cm.setOption('theme', params.args[0]);\n      },\n      map: function(cm, params, ctx) {\n        var mapArgs = params.args;\n        if (!mapArgs || mapArgs.length < 2) {\n          if (cm) {\n            showConfirm(cm, 'Invalid mapping: ' + params.input);\n          }\n          return;\n        }\n        exCommandDispatcher.map(mapArgs[0], mapArgs[1], ctx);\n      },\n      imap: function(cm, params) { this.map(cm, params, 'insert'); },\n      nmap: function(cm, params) { this.map(cm, params, 'normal'); },\n      vmap: function(cm, params) { this.map(cm, params, 'visual'); },\n      unmap: function(cm, params, ctx) {\n        var mapArgs = params.args;\n        if (!mapArgs || mapArgs.length < 1) {\n          if (cm) {\n            showConfirm(cm, 'No such mapping: ' + params.input);\n          }\n          return;\n        }\n        exCommandDispatcher.unmap(mapArgs[0], ctx);\n      },\n      move: function(cm, params) {\n        commandDispatcher.processCommand(cm, cm.state.vim, {\n            type: 'motion',\n            motion: 'moveToLineOrEdgeOfDocument',\n            motionArgs: { forward: false, explicitRepeat: true,\n              linewise: true },\n            repeatOverride: params.line+1});\n      },\n      set: function(cm, params) {\n        var setArgs = params.args;\n        var setCfg = params.setCfg || {};\n        if (!setArgs || setArgs.length < 1) {\n          if (cm) {\n            showConfirm(cm, 'Invalid mapping: ' + params.input);\n          }\n          return;\n        }\n        var expr = setArgs[0].split('=');\n        var optionName = expr[0];\n        var value = expr[1];\n        var forceGet = false;\n\n        if (optionName.charAt(optionName.length - 1) == '?') {\n          if (value) { throw Error('Trailing characters: ' + params.argString); }\n          optionName = optionName.substring(0, optionName.length - 1);\n          forceGet = true;\n        }\n        if (value === undefined && optionName.substring(0, 2) == 'no') {\n          optionName = optionName.substring(2);\n          value = false;\n        }\n\n        var optionIsBoolean = options[optionName] && options[optionName].type == 'boolean';\n        if (optionIsBoolean && value == undefined) {\n          value = true;\n        }\n        if (!optionIsBoolean && value === undefined || forceGet) {\n          var oldValue = getOption(optionName, cm, setCfg);\n          if (oldValue instanceof Error) {\n            showConfirm(cm, oldValue.message);\n          } else if (oldValue === true || oldValue === false) {\n            showConfirm(cm, ' ' + (oldValue ? '' : 'no') + optionName);\n          } else {\n            showConfirm(cm, '  ' + optionName + '=' + oldValue);\n          }\n        } else {\n          var setOptionReturn = setOption(optionName, value, cm, setCfg);\n          if (setOptionReturn instanceof Error) {\n            showConfirm(cm, setOptionReturn.message);\n          }\n        }\n      },\n      setlocal: function (cm, params) {\n        params.setCfg = {scope: 'local'};\n        this.set(cm, params);\n      },\n      setglobal: function (cm, params) {\n        params.setCfg = {scope: 'global'};\n        this.set(cm, params);\n      },\n      registers: function(cm, params) {\n        var regArgs = params.args;\n        var registers = vimGlobalState.registerController.registers;\n        var regInfo = '----------Registers----------<br><br>';\n        if (!regArgs) {\n          for (var registerName in registers) {\n            var text = registers[registerName].toString();\n            if (text.length) {\n              regInfo += '\"' + registerName + '    ' + text + '<br>';\n            }\n          }\n        } else {\n          var registerName;\n          regArgs = regArgs.join('');\n          for (var i = 0; i < regArgs.length; i++) {\n            registerName = regArgs.charAt(i);\n            if (!vimGlobalState.registerController.isValidRegister(registerName)) {\n              continue;\n            }\n            var register = registers[registerName] || new Register();\n            regInfo += '\"' + registerName + '    ' + register.toString() + '<br>';\n          }\n        }\n        showConfirm(cm, regInfo);\n      },\n      sort: function(cm, params) {\n        var reverse, ignoreCase, unique, number, pattern;\n        function parseArgs() {\n          if (params.argString) {\n            var args = new CodeMirror.StringStream(params.argString);\n            if (args.eat('!')) { reverse = true; }\n            if (args.eol()) { return; }\n            if (!args.eatSpace()) { return 'Invalid arguments'; }\n            var opts = args.match(/([dinuox]+)?\\s*(\\/.+\\/)?\\s*/);\n            if (!opts && !args.eol()) { return 'Invalid arguments'; }\n            if (opts[1]) {\n              ignoreCase = opts[1].indexOf('i') != -1;\n              unique = opts[1].indexOf('u') != -1;\n              var decimal = opts[1].indexOf('d') != -1 || opts[1].indexOf('n') != -1 && 1;\n              var hex = opts[1].indexOf('x') != -1 && 1;\n              var octal = opts[1].indexOf('o') != -1 && 1;\n              if (decimal + hex + octal > 1) { return 'Invalid arguments'; }\n              number = decimal && 'decimal' || hex && 'hex' || octal && 'octal';\n            }\n            if (opts[2]) {\n              pattern = new RegExp(opts[2].substr(1, opts[2].length - 2), ignoreCase ? 'i' : '');\n            }\n          }\n        }\n        var err = parseArgs();\n        if (err) {\n          showConfirm(cm, err + ': ' + params.argString);\n          return;\n        }\n        var lineStart = params.line || cm.firstLine();\n        var lineEnd = params.lineEnd || params.line || cm.lastLine();\n        if (lineStart == lineEnd) { return; }\n        var curStart = Pos(lineStart, 0);\n        var curEnd = Pos(lineEnd, lineLength(cm, lineEnd));\n        var text = cm.getRange(curStart, curEnd).split('\\n');\n        var numberRegex = pattern ? pattern :\n           (number == 'decimal') ? /(-?)([\\d]+)/ :\n           (number == 'hex') ? /(-?)(?:0x)?([0-9a-f]+)/i :\n           (number == 'octal') ? /([0-7]+)/ : null;\n        var radix = (number == 'decimal') ? 10 : (number == 'hex') ? 16 : (number == 'octal') ? 8 : null;\n        var numPart = [], textPart = [];\n        if (number || pattern) {\n          for (var i = 0; i < text.length; i++) {\n            var matchPart = pattern ? text[i].match(pattern) : null;\n            if (matchPart && matchPart[0] != '') {\n              numPart.push(matchPart);\n            } else if (!pattern && numberRegex.exec(text[i])) {\n              numPart.push(text[i]);\n            } else {\n              textPart.push(text[i]);\n            }\n          }\n        } else {\n          textPart = text;\n        }\n        function compareFn(a, b) {\n          if (reverse) { var tmp; tmp = a; a = b; b = tmp; }\n          if (ignoreCase) { a = a.toLowerCase(); b = b.toLowerCase(); }\n          var anum = number && numberRegex.exec(a);\n          var bnum = number && numberRegex.exec(b);\n          if (!anum) { return a < b ? -1 : 1; }\n          anum = parseInt((anum[1] + anum[2]).toLowerCase(), radix);\n          bnum = parseInt((bnum[1] + bnum[2]).toLowerCase(), radix);\n          return anum - bnum;\n        }\n        function comparePatternFn(a, b) {\n          if (reverse) { var tmp; tmp = a; a = b; b = tmp; }\n          if (ignoreCase) { a[0] = a[0].toLowerCase(); b[0] = b[0].toLowerCase(); }\n          return (a[0] < b[0]) ? -1 : 1;\n        }\n        numPart.sort(pattern ? comparePatternFn : compareFn);\n        if (pattern) {\n          for (var i = 0; i < numPart.length; i++) {\n            numPart[i] = numPart[i].input;\n          }\n        } else if (!number) { textPart.sort(compareFn); }\n        text = (!reverse) ? textPart.concat(numPart) : numPart.concat(textPart);\n        if (unique) { // Remove duplicate lines\n          var textOld = text;\n          var lastLine;\n          text = [];\n          for (var i = 0; i < textOld.length; i++) {\n            if (textOld[i] != lastLine) {\n              text.push(textOld[i]);\n            }\n            lastLine = textOld[i];\n          }\n        }\n        cm.replaceRange(text.join('\\n'), curStart, curEnd);\n      },\n      global: function(cm, params) {\n        var argString = params.argString;\n        if (!argString) {\n          showConfirm(cm, 'Regular Expression missing from global');\n          return;\n        }\n        var lineStart = (params.line !== undefined) ? params.line : cm.firstLine();\n        var lineEnd = params.lineEnd || params.line || cm.lastLine();\n        var tokens = splitBySlash(argString);\n        var regexPart = argString, cmd;\n        if (tokens.length) {\n          regexPart = tokens[0];\n          cmd = tokens.slice(1, tokens.length).join('/');\n        }\n        if (regexPart) {\n          try {\n           updateSearchQuery(cm, regexPart, true /** ignoreCase */,\n             true /** smartCase */);\n          } catch (e) {\n           showConfirm(cm, 'Invalid regex: ' + regexPart);\n           return;\n          }\n        }\n        var query = getSearchState(cm).getQuery();\n        var matchedLines = [], content = '';\n        for (var i = lineStart; i <= lineEnd; i++) {\n          var matched = query.test(cm.getLine(i));\n          if (matched) {\n            matchedLines.push(i+1);\n            content+= cm.getLine(i) + '<br>';\n          }\n        }\n        if (!cmd) {\n          showConfirm(cm, content);\n          return;\n        }\n        var index = 0;\n        var nextCommand = function() {\n          if (index < matchedLines.length) {\n            var command = matchedLines[index] + cmd;\n            exCommandDispatcher.processCommand(cm, command, {\n              callback: nextCommand\n            });\n          }\n          index++;\n        };\n        nextCommand();\n      },\n      substitute: function(cm, params) {\n        if (!cm.getSearchCursor) {\n          throw new Error('Search feature not available. Requires searchcursor.js or ' +\n              'any other getSearchCursor implementation.');\n        }\n        var argString = params.argString;\n        var tokens = argString ? splitBySeparator(argString, argString[0]) : [];\n        var regexPart, replacePart = '', trailing, flagsPart, count;\n        var confirm = false; // Whether to confirm each replace.\n        var global = false; // True to replace all instances on a line, false to replace only 1.\n        if (tokens.length) {\n          regexPart = tokens[0];\n          if (getOption('pcre') && regexPart !== '') {\n              regexPart = new RegExp(regexPart).source; //normalize not escaped characters\n          }\n          replacePart = tokens[1];\n          if (regexPart && regexPart[regexPart.length - 1] === '$') {\n            regexPart = regexPart.slice(0, regexPart.length - 1) + '\\\\n';\n            replacePart = replacePart ? replacePart + '\\n' : '\\n';\n          }\n          if (replacePart !== undefined) {\n            if (getOption('pcre')) {\n              replacePart = unescapeRegexReplace(replacePart.replace(/([^\\\\])&/g,\"$1$$&\"));\n            } else {\n              replacePart = translateRegexReplace(replacePart);\n            }\n            vimGlobalState.lastSubstituteReplacePart = replacePart;\n          }\n          trailing = tokens[2] ? tokens[2].split(' ') : [];\n        } else {\n          if (argString && argString.length) {\n            showConfirm(cm, 'Substitutions should be of the form ' +\n                ':s/pattern/replace/');\n            return;\n          }\n        }\n        if (trailing) {\n          flagsPart = trailing[0];\n          count = parseInt(trailing[1]);\n          if (flagsPart) {\n            if (flagsPart.indexOf('c') != -1) {\n              confirm = true;\n              flagsPart.replace('c', '');\n            }\n            if (flagsPart.indexOf('g') != -1) {\n              global = true;\n              flagsPart.replace('g', '');\n            }\n            if (getOption('pcre')) {\n               regexPart = regexPart + '/' + flagsPart;\n            } else {\n               regexPart = regexPart.replace(/\\//g, \"\\\\/\") + '/' + flagsPart;\n            }\n          }\n        }\n        if (regexPart) {\n          try {\n            updateSearchQuery(cm, regexPart, true /** ignoreCase */,\n              true /** smartCase */);\n          } catch (e) {\n            showConfirm(cm, 'Invalid regex: ' + regexPart);\n            return;\n          }\n        }\n        replacePart = replacePart || vimGlobalState.lastSubstituteReplacePart;\n        if (replacePart === undefined) {\n          showConfirm(cm, 'No previous substitute regular expression');\n          return;\n        }\n        var state = getSearchState(cm);\n        var query = state.getQuery();\n        var lineStart = (params.line !== undefined) ? params.line : cm.getCursor().line;\n        var lineEnd = params.lineEnd || lineStart;\n        if (lineStart == cm.firstLine() && lineEnd == cm.lastLine()) {\n          lineEnd = Infinity;\n        }\n        if (count) {\n          lineStart = lineEnd;\n          lineEnd = lineStart + count - 1;\n        }\n        var startPos = clipCursorToContent(cm, Pos(lineStart, 0));\n        var cursor = cm.getSearchCursor(query, startPos);\n        doReplace(cm, confirm, global, lineStart, lineEnd, cursor, query, replacePart, params.callback);\n      },\n      redo: CodeMirror.commands.redo,\n      undo: CodeMirror.commands.undo,\n      write: function(cm) {\n        if (CodeMirror.commands.save) {\n          CodeMirror.commands.save(cm);\n        } else if (cm.save) {\n          cm.save();\n        }\n      },\n      nohlsearch: function(cm) {\n        clearSearchHighlight(cm);\n      },\n      yank: function (cm) {\n        var cur = copyCursor(cm.getCursor());\n        var line = cur.line;\n        var lineText = cm.getLine(line);\n        vimGlobalState.registerController.pushText(\n          '0', 'yank', lineText, true, true);\n      },\n      delmarks: function(cm, params) {\n        if (!params.argString || !trim(params.argString)) {\n          showConfirm(cm, 'Argument required');\n          return;\n        }\n\n        var state = cm.state.vim;\n        var stream = new CodeMirror.StringStream(trim(params.argString));\n        while (!stream.eol()) {\n          stream.eatSpace();\n          var count = stream.pos;\n\n          if (!stream.match(/[a-zA-Z]/, false)) {\n            showConfirm(cm, 'Invalid argument: ' + params.argString.substring(count));\n            return;\n          }\n\n          var sym = stream.next();\n          if (stream.match('-', true)) {\n            if (!stream.match(/[a-zA-Z]/, false)) {\n              showConfirm(cm, 'Invalid argument: ' + params.argString.substring(count));\n              return;\n            }\n\n            var startMark = sym;\n            var finishMark = stream.next();\n            if (isLowerCase(startMark) && isLowerCase(finishMark) ||\n                isUpperCase(startMark) && isUpperCase(finishMark)) {\n              var start = startMark.charCodeAt(0);\n              var finish = finishMark.charCodeAt(0);\n              if (start >= finish) {\n                showConfirm(cm, 'Invalid argument: ' + params.argString.substring(count));\n                return;\n              }\n              for (var j = 0; j <= finish - start; j++) {\n                var mark = String.fromCharCode(start + j);\n                delete state.marks[mark];\n              }\n            } else {\n              showConfirm(cm, 'Invalid argument: ' + startMark + '-');\n              return;\n            }\n          } else {\n            delete state.marks[sym];\n          }\n        }\n      }\n    };\n\n    var exCommandDispatcher = new ExCommandDispatcher();\n    function doReplace(cm, confirm, global, lineStart, lineEnd, searchCursor, query,\n        replaceWith, callback) {\n      cm.state.vim.exMode = true;\n      var done = false;\n      var lastPos = searchCursor.from();\n      function replaceAll() {\n        cm.operation(function() {\n          while (!done) {\n            replace();\n            next();\n          }\n          stop();\n        });\n      }\n      function replace() {\n        var text = cm.getRange(searchCursor.from(), searchCursor.to());\n        var newText = text.replace(query, replaceWith);\n        searchCursor.replace(newText);\n      }\n      function next() {\n        while(searchCursor.findNext() &&\n              isInRange(searchCursor.from(), lineStart, lineEnd)) {\n          if (!global && lastPos && searchCursor.from().line == lastPos.line) {\n            continue;\n          }\n          cm.scrollIntoView(searchCursor.from(), 30);\n          cm.setSelection(searchCursor.from(), searchCursor.to());\n          lastPos = searchCursor.from();\n          done = false;\n          return;\n        }\n        done = true;\n      }\n      function stop(close) {\n        if (close) { close(); }\n        cm.focus();\n        if (lastPos) {\n          cm.setCursor(lastPos);\n          var vim = cm.state.vim;\n          vim.exMode = false;\n          vim.lastHPos = vim.lastHSPos = lastPos.ch;\n        }\n        if (callback) { callback(); }\n      }\n      function onPromptKeyDown(e, _value, close) {\n        CodeMirror.e_stop(e);\n        var keyName = CodeMirror.keyName(e);\n        switch (keyName) {\n          case 'Y':\n            replace(); next(); break;\n          case 'N':\n            next(); break;\n          case 'A':\n            var savedCallback = callback;\n            callback = undefined;\n            cm.operation(replaceAll);\n            callback = savedCallback;\n            break;\n          case 'L':\n            replace();\n          case 'Q':\n          case 'Esc':\n          case 'Ctrl-C':\n          case 'Ctrl-[':\n            stop(close);\n            break;\n        }\n        if (done) { stop(close); }\n        return true;\n      }\n      next();\n      if (done) {\n        showConfirm(cm, 'No matches for ' + query.source);\n        return;\n      }\n      if (!confirm) {\n        replaceAll();\n        if (callback) { callback(); }\n        return;\n      }\n      showPrompt(cm, {\n        prefix: 'replace with <strong>' + replaceWith + '</strong> (y/n/a/q/l)',\n        onKeyDown: onPromptKeyDown\n      });\n    }\n\n    CodeMirror.keyMap.vim = {\n      attach: attachVimMap,\n      detach: detachVimMap,\n      call: cmKey\n    };\n\n    function exitInsertMode(cm) {\n      var vim = cm.state.vim;\n      var macroModeState = vimGlobalState.macroModeState;\n      var insertModeChangeRegister = vimGlobalState.registerController.getRegister('.');\n      var isPlaying = macroModeState.isPlaying;\n      var lastChange = macroModeState.lastInsertModeChanges;\n      if (!isPlaying) {\n        cm.off('change', onChange);\n        CodeMirror.off(cm.getInputField(), 'keydown', onKeyEventTargetKeyDown);\n      }\n      if (!isPlaying && vim.insertModeRepeat > 1) {\n        repeatLastEdit(cm, vim, vim.insertModeRepeat - 1,\n            true /** repeatForInsert */);\n        vim.lastEditInputState.repeatOverride = vim.insertModeRepeat;\n      }\n      delete vim.insertModeRepeat;\n      vim.insertMode = false;\n      cm.setCursor(cm.getCursor().line, cm.getCursor().ch-1);\n      cm.setOption('keyMap', 'vim');\n      cm.setOption('disableInput', true);\n      cm.toggleOverwrite(false); // exit replace mode if we were in it.\n      insertModeChangeRegister.setText(lastChange.changes.join(''));\n      CodeMirror.signal(cm, \"vim-mode-change\", {mode: \"normal\"});\n      if (macroModeState.isRecording) {\n        logInsertModeChange(macroModeState);\n      }\n    }\n\n    function _mapCommand(command) {\n      defaultKeymap.unshift(command);\n    }\n\n    function mapCommand(keys, type, name, args, extra) {\n      var command = {keys: keys, type: type};\n      command[type] = name;\n      command[type + \"Args\"] = args;\n      for (var key in extra)\n        command[key] = extra[key];\n      _mapCommand(command);\n    }\n    defineOption('insertModeEscKeysTimeout', 200, 'number');\n\n    CodeMirror.keyMap['vim-insert'] = {\n      fallthrough: ['default'],\n      attach: attachVimMap,\n      detach: detachVimMap,\n      call: cmKey\n    };\n\n    CodeMirror.keyMap['vim-replace'] = {\n      'Backspace': 'goCharLeft',\n      fallthrough: ['vim-insert'],\n      attach: attachVimMap,\n      detach: detachVimMap,\n      call: cmKey\n    };\n\n    function executeMacroRegister(cm, vim, macroModeState, registerName) {\n      var register = vimGlobalState.registerController.getRegister(registerName);\n      if (registerName == ':') {\n        if (register.keyBuffer[0]) {\n          exCommandDispatcher.processCommand(cm, register.keyBuffer[0]);\n        }\n        macroModeState.isPlaying = false;\n        return;\n      }\n      var keyBuffer = register.keyBuffer;\n      var imc = 0;\n      macroModeState.isPlaying = true;\n      macroModeState.replaySearchQueries = register.searchQueries.slice(0);\n      for (var i = 0; i < keyBuffer.length; i++) {\n        var text = keyBuffer[i];\n        var match, key;\n        while (text) {\n          match = (/<\\w+-.+?>|<\\w+>|./).exec(text);\n          key = match[0];\n          text = text.substring(match.index + key.length);\n          CodeMirror.Vim.handleKey(cm, key, 'macro');\n          if (vim.insertMode) {\n            var changes = register.insertModeChanges[imc++].changes;\n            vimGlobalState.macroModeState.lastInsertModeChanges.changes =\n                changes;\n            repeatInsertModeChanges(cm, changes, 1);\n            exitInsertMode(cm);\n          }\n        }\n      }\n      macroModeState.isPlaying = false;\n    }\n\n    function logKey(macroModeState, key) {\n      if (macroModeState.isPlaying) { return; }\n      var registerName = macroModeState.latestRegister;\n      var register = vimGlobalState.registerController.getRegister(registerName);\n      if (register) {\n        register.pushText(key);\n      }\n    }\n\n    function logInsertModeChange(macroModeState) {\n      if (macroModeState.isPlaying) { return; }\n      var registerName = macroModeState.latestRegister;\n      var register = vimGlobalState.registerController.getRegister(registerName);\n      if (register && register.pushInsertModeChanges) {\n        register.pushInsertModeChanges(macroModeState.lastInsertModeChanges);\n      }\n    }\n\n    function logSearchQuery(macroModeState, query) {\n      if (macroModeState.isPlaying) { return; }\n      var registerName = macroModeState.latestRegister;\n      var register = vimGlobalState.registerController.getRegister(registerName);\n      if (register && register.pushSearchQuery) {\n        register.pushSearchQuery(query);\n      }\n    }\n    function onChange(cm, changeObj) {\n      var macroModeState = vimGlobalState.macroModeState;\n      var lastChange = macroModeState.lastInsertModeChanges;\n      if (!macroModeState.isPlaying) {\n        while(changeObj) {\n          lastChange.expectCursorActivityForChange = true;\n          if (lastChange.ignoreCount > 1) {\n            lastChange.ignoreCount--;\n          } else if (changeObj.origin == '+input' || changeObj.origin == 'paste'\n              || changeObj.origin === undefined /* only in testing */) {\n            var selectionCount = cm.listSelections().length;\n            if (selectionCount > 1)\n              lastChange.ignoreCount = selectionCount;\n            var text = changeObj.text.join('\\n');\n            if (lastChange.maybeReset) {\n              lastChange.changes = [];\n              lastChange.maybeReset = false;\n            }\n            if (text) {\n              if (cm.state.overwrite && !/\\n/.test(text)) {\n                lastChange.changes.push([text]);\n              } else {\n                lastChange.changes.push(text);\n              }\n            }\n          }\n          changeObj = changeObj.next;\n        }\n      }\n    }\n    function onCursorActivity(cm) {\n      var vim = cm.state.vim;\n      if (vim.insertMode) {\n        var macroModeState = vimGlobalState.macroModeState;\n        if (macroModeState.isPlaying) { return; }\n        var lastChange = macroModeState.lastInsertModeChanges;\n        if (lastChange.expectCursorActivityForChange) {\n          lastChange.expectCursorActivityForChange = false;\n        } else {\n          lastChange.maybeReset = true;\n        }\n      } else if (!cm.curOp.isVimOp) {\n        handleExternalSelection(cm, vim);\n      }\n      if (vim.visualMode) {\n        updateFakeCursor(cm);\n      }\n    }\n    function updateFakeCursor(cm) {\n      var vim = cm.state.vim;\n      var from = clipCursorToContent(cm, copyCursor(vim.sel.head));\n      var to = offsetCursor(from, 0, 1);\n      if (vim.fakeCursor) {\n        vim.fakeCursor.clear();\n      }\n      vim.fakeCursor = cm.markText(from, to, {className: 'cm-animate-fat-cursor'});\n    }\n    function handleExternalSelection(cm, vim, keepHPos) {\n      var anchor = cm.getCursor('anchor');\n      var head = cm.getCursor('head');\n      if (vim.visualMode && !cm.somethingSelected()) {\n        exitVisualMode(cm, false);\n      } else if (!vim.visualMode && !vim.insertMode && cm.somethingSelected()) {\n        vim.visualMode = true;\n        vim.visualLine = false;\n        CodeMirror.signal(cm, \"vim-mode-change\", {mode: \"visual\"});\n      }\n      if (vim.visualMode) {\n        var headOffset = !cursorIsBefore(head, anchor) ? -1 : 0;\n        var anchorOffset = cursorIsBefore(head, anchor) ? -1 : 0;\n        head = offsetCursor(head, 0, headOffset);\n        anchor = offsetCursor(anchor, 0, anchorOffset);\n        vim.sel = {\n          anchor: anchor,\n          head: head\n        };\n        updateMark(cm, vim, '<', cursorMin(head, anchor));\n        updateMark(cm, vim, '>', cursorMax(head, anchor));\n      } else if (!vim.insertMode && !keepHPos) {\n        vim.lastHPos = cm.getCursor().ch;\n      }\n    }\n    function InsertModeKey(keyName) {\n      this.keyName = keyName;\n    }\n    function onKeyEventTargetKeyDown(e) {\n      var macroModeState = vimGlobalState.macroModeState;\n      var lastChange = macroModeState.lastInsertModeChanges;\n      var keyName = CodeMirror.keyName(e);\n      if (!keyName) { return; }\n      function onKeyFound() {\n        if (lastChange.maybeReset) {\n          lastChange.changes = [];\n          lastChange.maybeReset = false;\n        }\n        lastChange.changes.push(new InsertModeKey(keyName));\n        return true;\n      }\n      if (keyName.indexOf('Delete') != -1 || keyName.indexOf('Backspace') != -1) {\n        CodeMirror.lookupKey(keyName, 'vim-insert', onKeyFound);\n      }\n    }\n    function repeatLastEdit(cm, vim, repeat, repeatForInsert) {\n      var macroModeState = vimGlobalState.macroModeState;\n      macroModeState.isPlaying = true;\n      var isAction = !!vim.lastEditActionCommand;\n      var cachedInputState = vim.inputState;\n      function repeatCommand() {\n        if (isAction) {\n          commandDispatcher.processAction(cm, vim, vim.lastEditActionCommand);\n        } else {\n          commandDispatcher.evalInput(cm, vim);\n        }\n      }\n      function repeatInsert(repeat) {\n        if (macroModeState.lastInsertModeChanges.changes.length > 0) {\n          repeat = !vim.lastEditActionCommand ? 1 : repeat;\n          var changeObject = macroModeState.lastInsertModeChanges;\n          repeatInsertModeChanges(cm, changeObject.changes, repeat);\n        }\n      }\n      vim.inputState = vim.lastEditInputState;\n      if (isAction && vim.lastEditActionCommand.interlaceInsertRepeat) {\n        for (var i = 0; i < repeat; i++) {\n          repeatCommand();\n          repeatInsert(1);\n        }\n      } else {\n        if (!repeatForInsert) {\n          repeatCommand();\n        }\n        repeatInsert(repeat);\n      }\n      vim.inputState = cachedInputState;\n      if (vim.insertMode && !repeatForInsert) {\n        exitInsertMode(cm);\n      }\n      macroModeState.isPlaying = false;\n    }\n\n    function repeatInsertModeChanges(cm, changes, repeat) {\n      function keyHandler(binding) {\n        if (typeof binding == 'string') {\n          CodeMirror.commands[binding](cm);\n        } else {\n          binding(cm);\n        }\n        return true;\n      }\n      var head = cm.getCursor('head');\n      var visualBlock = vimGlobalState.macroModeState.lastInsertModeChanges.visualBlock;\n      if (visualBlock) {\n        selectForInsert(cm, head, visualBlock + 1);\n        repeat = cm.listSelections().length;\n        cm.setCursor(head);\n      }\n      for (var i = 0; i < repeat; i++) {\n        if (visualBlock) {\n          cm.setCursor(offsetCursor(head, i, 0));\n        }\n        for (var j = 0; j < changes.length; j++) {\n          var change = changes[j];\n          if (change instanceof InsertModeKey) {\n            CodeMirror.lookupKey(change.keyName, 'vim-insert', keyHandler);\n          } else if (typeof change == \"string\") {\n            var cur = cm.getCursor();\n            cm.replaceRange(change, cur, cur);\n          } else {\n            var start = cm.getCursor();\n            var end = offsetCursor(start, 0, change[0].length);\n            cm.replaceRange(change[0], start, end);\n          }\n        }\n      }\n      if (visualBlock) {\n        cm.setCursor(offsetCursor(head, 0, 1));\n      }\n    }\n\n    resetVimGlobalState();\n  CodeMirror.Vim = Vim();\n\n  Vim = CodeMirror.Vim;\n\n  var specialKey = {'return':'CR',backspace:'BS','delete':'Del',esc:'Esc',\n    left:'Left',right:'Right',up:'Up',down:'Down',space: 'Space',\n    home:'Home',end:'End',pageup:'PageUp',pagedown:'PageDown', enter: 'CR'\n  };\n  function lookupKey(hashId, key, e) {\n    if (key.length > 1 && key[0] == \"n\") {\n      key = key.replace(\"numpad\", \"\");\n    }\n    key = specialKey[key] || key;\n    var name = '';\n    if (e.ctrlKey) { name += 'C-'; }\n    if (e.altKey) { name += 'A-'; }\n    if ((name || key.length > 1) && e.shiftKey) { name += 'S-'; }\n\n    name += key;\n    if (name.length > 1) { name = '<' + name + '>'; }\n    return name;\n  }\n  var handleKey = Vim.handleKey.bind(Vim);\n  Vim.handleKey = function(cm, key, origin) {\n    return cm.operation(function() {\n      return handleKey(cm, key, origin);\n    }, true);\n  }\n  function cloneVimState(state) {\n    var n = new state.constructor();\n    Object.keys(state).forEach(function(key) {\n      var o = state[key];\n      if (Array.isArray(o))\n        o = o.slice();\n      else if (o && typeof o == \"object\" && o.constructor != Object)\n        o = cloneVimState(o);\n      n[key] = o;\n    });\n    if (state.sel) {\n      n.sel = {\n        head: state.sel.head && copyCursor(state.sel.head),\n        anchor: state.sel.anchor && copyCursor(state.sel.anchor)\n      };\n    }\n    return n;\n  }\n  function multiSelectHandleKey(cm, key, origin) {\n    var isHandled = false;\n    var vim = Vim.maybeInitVimState_(cm);\n    var visualBlock = vim.visualBlock || vim.wasInVisualBlock;\n\n    var wasMultiselect = cm.ace.inMultiSelectMode;\n    if (vim.wasInVisualBlock && !wasMultiselect) {\n      vim.wasInVisualBlock = false;\n    } else if (wasMultiselect && vim.visualBlock) {\n       vim.wasInVisualBlock = true;\n    }\n    \n    if (key == '<Esc>' && !vim.insertMode && !vim.visualMode && wasMultiselect) {\n      cm.ace.exitMultiSelectMode();\n    } else if (visualBlock || !wasMultiselect || cm.ace.inVirtualSelectionMode) {\n      isHandled = Vim.handleKey(cm, key, origin);\n    } else {\n      var old = cloneVimState(vim);\n      cm.operation(function() {\n        cm.ace.forEachSelection(function() {\n          var sel = cm.ace.selection;\n          cm.state.vim.lastHPos = sel.$desiredColumn == null ? sel.lead.column : sel.$desiredColumn;\n          var head = cm.getCursor(\"head\");\n          var anchor = cm.getCursor(\"anchor\");\n          var headOffset = !cursorIsBefore(head, anchor) ? -1 : 0;\n          var anchorOffset = cursorIsBefore(head, anchor) ? -1 : 0;\n          head = offsetCursor(head, 0, headOffset);\n          anchor = offsetCursor(anchor, 0, anchorOffset);\n          cm.state.vim.sel.head = head;\n          cm.state.vim.sel.anchor = anchor;\n          \n          isHandled = handleKey(cm, key, origin);\n          sel.$desiredColumn = cm.state.vim.lastHPos == -1 ? null : cm.state.vim.lastHPos;\n          if (cm.virtualSelectionMode()) {\n            cm.state.vim = cloneVimState(old);\n          }\n        });\n        if (cm.curOp.cursorActivity && !isHandled)\n          cm.curOp.cursorActivity = false;\n      }, true);\n    }\n    if (isHandled && !vim.visualMode && !vim.insert && vim.visualMode != cm.somethingSelected()) {\n      handleExternalSelection(cm, vim, true);\n    }\n    return isHandled;\n  }\n  exports.CodeMirror = CodeMirror;\n  var getVim = Vim.maybeInitVimState_;\n  exports.handler = {\n    $id: \"ace/keyboard/vim\",\n    drawCursor: function(element, pixelPos, config, sel, session) {\n      var vim = this.state.vim || {};\n      var w = config.characterWidth;\n      var h = config.lineHeight;\n      var top = pixelPos.top;\n      var left = pixelPos.left;\n      if (!vim.insertMode) {\n        var isbackwards = !sel.cursor \n            ? session.selection.isBackwards() || session.selection.isEmpty()\n            : Range.comparePoints(sel.cursor, sel.start) <= 0;\n        if (!isbackwards && left > w)\n          left -= w;\n      }     \n      if (!vim.insertMode && vim.status) {\n        h = h / 2;\n        top += h;\n      }\n      dom.translate(element, left, top);\n      dom.setStyle(element.style, \"width\", w + \"px\");\n      dom.setStyle(element.style, \"height\", h + \"px\");\n    },\n    handleKeyboard: function(data, hashId, key, keyCode, e) {\n      var editor = data.editor;\n      var cm = editor.state.cm;\n      var vim = getVim(cm);\n      if (keyCode == -1) return;\n      if (!vim.insertMode) {\n        if (hashId == -1) {\n          if (key.charCodeAt(0) > 0xFF) {\n            if (data.inputKey) {\n              key = data.inputKey;\n              if (key && data.inputHash == 4)\n                key = key.toUpperCase();\n            }\n          }\n          data.inputChar = key;\n        }\n        else if (hashId == 4 || hashId == 0) {\n          if (data.inputKey == key && data.inputHash == hashId && data.inputChar) {\n            key = data.inputChar;\n            hashId = -1\n          }\n          else {\n            data.inputChar = null;\n            data.inputKey = key;\n            data.inputHash = hashId;\n          }\n        }\n        else {\n          data.inputChar = data.inputKey = null;\n        }\n      }\n      if (key == \"c\" && hashId == 1) { // key == \"ctrl-c\"\n        if (!useragent.isMac && editor.getCopyText()) {\n          editor.once(\"copy\", function() {\n            editor.selection.clearSelection();\n          });\n          return {command: \"null\", passEvent: true};\n        }\n      }\n      \n      if (key == \"esc\" && !vim.insertMode && !vim.visualMode && !cm.ace.inMultiSelectMode) {\n        var searchState = getSearchState(cm);\n        var overlay = searchState.getOverlay();\n        if (overlay) cm.removeOverlay(overlay);\n      }\n      \n      if (hashId == -1 || hashId & 1 || hashId === 0 && key.length > 1) {\n        var insertMode = vim.insertMode;\n        var name = lookupKey(hashId, key, e || {});\n        if (vim.status == null)\n          vim.status = \"\";\n        var isHandled = multiSelectHandleKey(cm, name, 'user');\n        vim = getVim(cm); // may be changed by multiSelectHandleKey\n        if (isHandled && vim.status != null)\n          vim.status += name;\n        else if (vim.status == null)\n          vim.status = \"\";\n        cm._signal(\"changeStatus\");\n        if (!isHandled && (hashId != -1 || insertMode))\n          return;\n        return {command: \"null\", passEvent: !isHandled};\n      }\n    },\n    attach: function(editor) {\n      if (!editor.state) editor.state = {};\n      var cm = new CodeMirror(editor);\n      editor.state.cm = cm;\n      editor.$vimModeHandler = this;\n      CodeMirror.keyMap.vim.attach(cm);\n      getVim(cm).status = null;\n      cm.on('vim-command-done', function() {\n        if (cm.virtualSelectionMode()) return;\n        getVim(cm).status = null;\n        cm.ace._signal(\"changeStatus\");\n        cm.ace.session.markUndoGroup();\n      });\n      cm.on(\"changeStatus\", function() {\n        cm.ace.renderer.updateCursor();\n        cm.ace._signal(\"changeStatus\");\n      });\n      cm.on(\"vim-mode-change\", function() {\n        if (cm.virtualSelectionMode()) return;\n        updateInputMode();\n        cm._signal(\"changeStatus\");\n      });\n      function updateInputMode() {\n        var isIntsert = getVim(cm).insertMode;\n        cm.ace.renderer.setStyle(\"normal-mode\", !isIntsert);\n        editor.textInput.setCommandMode(!isIntsert);\n        editor.renderer.$keepTextAreaAtCursor = isIntsert;\n        editor.renderer.$blockCursor = !isIntsert;\n      }\n      updateInputMode();\n      editor.renderer.$cursorLayer.drawCursor = this.drawCursor.bind(cm);\n    },\n    detach: function(editor) {\n      var cm = editor.state.cm;\n      CodeMirror.keyMap.vim.detach(cm);\n      cm.destroy();\n      editor.state.cm = null;\n      editor.$vimModeHandler = null;\n      editor.renderer.$cursorLayer.drawCursor = null;\n      editor.renderer.setStyle(\"normal-mode\", false);\n      editor.textInput.setCommandMode(false);\n      editor.renderer.$keepTextAreaAtCursor = true;\n    },\n    getStatusText: function(editor) {\n      var cm = editor.state.cm;\n      var vim = getVim(cm);\n      if (vim.insertMode)\n        return \"INSERT\";\n      var status = \"\";\n      if (vim.visualMode) {\n        status += \"VISUAL\";\n        if (vim.visualLine)\n          status += \" LINE\";\n        if (vim.visualBlock)\n          status += \" BLOCK\";\n      }\n      if (vim.status)\n        status += (status ? \" \" : \"\") + vim.status;\n      return status;\n    }\n  };\n  Vim.defineOption({\n    name: \"wrap\",\n    set: function(value, cm) {\n      if (cm) {cm.ace.setOption(\"wrap\", value)}\n    },\n    type: \"boolean\"\n  }, false);\n  Vim.defineEx('write', 'w', function() {\n    console.log(':write is not implemented')\n  });\n  defaultKeymap.push(\n    { keys: 'zc', type: 'action', action: 'fold', actionArgs: { open: false } },\n    { keys: 'zC', type: 'action', action: 'fold', actionArgs: { open: false, all: true } },\n    { keys: 'zo', type: 'action', action: 'fold', actionArgs: { open: true } },\n    { keys: 'zO', type: 'action', action: 'fold', actionArgs: { open: true, all: true } },\n    { keys: 'za', type: 'action', action: 'fold', actionArgs: { toggle: true } },\n    { keys: 'zA', type: 'action', action: 'fold', actionArgs: { toggle: true, all: true } },\n    { keys: 'zf', type: 'action', action: 'fold', actionArgs: { open: true, all: true } },\n    { keys: 'zd', type: 'action', action: 'fold', actionArgs: { open: true, all: true } },\n    \n    { keys: '<C-A-k>', type: 'action', action: 'aceCommand', actionArgs: { name: \"addCursorAbove\" } },\n    { keys: '<C-A-j>', type: 'action', action: 'aceCommand', actionArgs: { name: \"addCursorBelow\" } },\n    { keys: '<C-A-S-k>', type: 'action', action: 'aceCommand', actionArgs: { name: \"addCursorAboveSkipCurrent\" } },\n    { keys: '<C-A-S-j>', type: 'action', action: 'aceCommand', actionArgs: { name: \"addCursorBelowSkipCurrent\" } },\n    { keys: '<C-A-h>', type: 'action', action: 'aceCommand', actionArgs: { name: \"selectMoreBefore\" } },\n    { keys: '<C-A-l>', type: 'action', action: 'aceCommand', actionArgs: { name: \"selectMoreAfter\" } },\n    { keys: '<C-A-S-h>', type: 'action', action: 'aceCommand', actionArgs: { name: \"selectNextBefore\" } },\n    { keys: '<C-A-S-l>', type: 'action', action: 'aceCommand', actionArgs: { name: \"selectNextAfter\" } }\n  );\n  actions.aceCommand = function(cm, actionArgs, vim) {\n    cm.vimCmd = actionArgs;\n    if (cm.ace.inVirtualSelectionMode)\n      cm.ace.on(\"beforeEndOperation\", delayedExecAceCommand);\n    else\n      delayedExecAceCommand(null, cm.ace);\n  };\n  function delayedExecAceCommand(op, ace) {\n    ace.off(\"beforeEndOperation\", delayedExecAceCommand);\n    var cmd = ace.state.cm.vimCmd;\n    if (cmd) {\n      ace.execCommand(cmd.exec ? cmd : cmd.name, cmd.args);\n    }\n    ace.curOp = ace.prevOp;\n  }\n  actions.fold = function(cm, actionArgs, vim) {\n    cm.ace.execCommand(['toggleFoldWidget', 'toggleFoldWidget', 'foldOther', 'unfoldall'\n      ][(actionArgs.all ? 2 : 0) + (actionArgs.open ? 1 : 0)]);\n  };\n\n  exports.handler.defaultKeymap = defaultKeymap;\n  exports.handler.actions = actions;\n  exports.Vim = Vim;\n});                (function() {\n                    ace.require([\"ace/keyboard/vim\"], function(m) {\n                        if (typeof module == \"object\" && typeof exports == \"object\" && module) {\n                            module.exports = m;\n                        }\n                    });\n                })();\n            "]},"metadata":{},"sourceType":"script"}