{"ast":null,"code":"import { forEach, map } from \"../utils/utils\";\nimport { RepetitionMandatory, Option, RepetitionMandatoryWithSeparator, RepetitionWithSeparator, Terminal, NonTerminal, Alternation, Alternative, Repetition } from \"../parse/grammar/gast/gast_public\";\n/**\n * Missing features\n * 1. Rule arguments\n * 2. Gates\n * 3. embedded actions\n */\n\nvar NL = \"\\n\";\nexport function genUmdModule(options) {\n  return \"\\n(function (root, factory) {\\n    if (typeof define === 'function' && define.amd) {\\n        // AMD. Register as an anonymous module.\\n        define(['chevrotain'], factory);\\n    } else if (typeof module === 'object' && module.exports) {\\n        // Node. Does not work with strict CommonJS, but\\n        // only CommonJS-like environments that support module.exports,\\n        // like Node.\\n        module.exports = factory(require('chevrotain'));\\n    } else {\\n        // Browser globals (root is window)\\n        root.returnExports = factory(root.b);\\n    }\\n}(typeof self !== 'undefined' ? self : this, function (chevrotain) {\\n\\n\" + genClass(options) + \"\\n    \\nreturn {\\n    \" + options.name + \": \" + options.name + \" \\n}\\n}));\\n\";\n}\nexport function genWrapperFunction(options) {\n  return \"    \\n\" + genClass(options) + \"\\nreturn new \" + options.name + \"(tokenVocabulary, config)    \\n\";\n}\nexport function genClass(options) {\n  // TODO: how to pass the token vocabulary? Constructor? other?\n  var result = \"\\nfunction \" + options.name + \"(tokenVocabulary, config) {\\n    // invoke super constructor\\n    // No support for embedded actions currently, so we can 'hardcode'\\n    // The use of CstParser.\\n    chevrotain.CstParser.call(this, tokenVocabulary, config)\\n\\n    const $ = this\\n\\n    \" + genAllRules(options.rules) + \"\\n\\n    // very important to call this after all the rules have been defined.\\n    // otherwise the parser may not work correctly as it will lack information\\n    // derived during the self analysis phase.\\n    this.performSelfAnalysis(this)\\n}\\n\\n// inheritance as implemented in javascript in the previous decade... :(\\n\" + options.name + \".prototype = Object.create(chevrotain.CstParser.prototype)\\n\" + options.name + \".prototype.constructor = \" + options.name + \"    \\n    \";\n  return result;\n}\nexport function genAllRules(rules) {\n  var rulesText = map(rules, function (currRule) {\n    return genRule(currRule, 1);\n  });\n  return rulesText.join(\"\\n\");\n}\nexport function genRule(prod, n) {\n  var result = indent(n, \"$.RULE(\\\"\" + prod.name + \"\\\", function() {\") + NL;\n  result += genDefinition(prod.definition, n + 1);\n  result += indent(n + 1, \"})\") + NL;\n  return result;\n}\nexport function genTerminal(prod, n) {\n  var name = prod.terminalType.name; // TODO: potential performance optimization, avoid tokenMap Dictionary access\n\n  return indent(n, \"$.CONSUME\" + prod.idx + \"(this.tokensMap.\" + name + \")\" + NL);\n}\nexport function genNonTerminal(prod, n) {\n  return indent(n, \"$.SUBRULE\" + prod.idx + \"($.\" + prod.nonTerminalName + \")\" + NL);\n}\nexport function genAlternation(prod, n) {\n  var result = indent(n, \"$.OR\" + prod.idx + \"([\") + NL;\n  var alts = map(prod.definition, function (altDef) {\n    return genSingleAlt(altDef, n + 1);\n  });\n  result += alts.join(\",\" + NL);\n  result += NL + indent(n, \"])\" + NL);\n  return result;\n}\nexport function genSingleAlt(prod, n) {\n  var result = indent(n, \"{\") + NL;\n  result += indent(n + 1, \"ALT: function() {\") + NL;\n  result += genDefinition(prod.definition, n + 1);\n  result += indent(n + 1, \"}\") + NL;\n  result += indent(n, \"}\");\n  return result;\n}\n\nfunction genProd(prod, n) {\n  /* istanbul ignore else */\n  if (prod instanceof NonTerminal) {\n    return genNonTerminal(prod, n);\n  } else if (prod instanceof Option) {\n    return genDSLRule(\"OPTION\", prod, n);\n  } else if (prod instanceof RepetitionMandatory) {\n    return genDSLRule(\"AT_LEAST_ONE\", prod, n);\n  } else if (prod instanceof RepetitionMandatoryWithSeparator) {\n    return genDSLRule(\"AT_LEAST_ONE_SEP\", prod, n);\n  } else if (prod instanceof RepetitionWithSeparator) {\n    return genDSLRule(\"MANY_SEP\", prod, n);\n  } else if (prod instanceof Repetition) {\n    return genDSLRule(\"MANY\", prod, n);\n  } else if (prod instanceof Alternation) {\n    return genAlternation(prod, n);\n  } else if (prod instanceof Terminal) {\n    return genTerminal(prod, n);\n  } else if (prod instanceof Alternative) {\n    return genDefinition(prod.definition, n);\n  } else {\n    throw Error(\"non exhaustive match\");\n  }\n}\n\nfunction genDSLRule(dslName, prod, n) {\n  var result = indent(n, \"$.\" + (dslName + prod.idx) + \"(\");\n\n  if (prod.separator) {\n    result += \"{\" + NL;\n    result += indent(n + 1, \"SEP: this.tokensMap.\" + prod.separator.name) + \",\" + NL;\n    result += \"DEF: \" + genDefFunction(prod.definition, n + 2) + NL;\n    result += indent(n, \"}\") + NL;\n  } else {\n    result += genDefFunction(prod.definition, n + 1);\n  }\n\n  result += indent(n, \")\") + NL;\n  return result;\n}\n\nfunction genDefFunction(definition, n) {\n  var def = \"function() {\" + NL;\n  def += genDefinition(definition, n);\n  def += indent(n, \"}\") + NL;\n  return def;\n}\n\nfunction genDefinition(def, n) {\n  var result = \"\";\n  forEach(def, function (prod) {\n    result += genProd(prod, n + 1);\n  });\n  return result;\n}\n\nfunction indent(howMuch, text) {\n  var spaces = Array(howMuch * 4 + 1).join(\" \");\n  return spaces + text;\n}","map":{"version":3,"sources":["../../../src/generate/generate.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["import { forEach, map } from \"../utils/utils\";\nimport { RepetitionMandatory, Option, RepetitionMandatoryWithSeparator, RepetitionWithSeparator, Terminal, NonTerminal, Alternation, Alternative, Repetition } from \"../parse/grammar/gast/gast_public\";\n/**\n * Missing features\n * 1. Rule arguments\n * 2. Gates\n * 3. embedded actions\n */\nvar NL = \"\\n\";\nexport function genUmdModule(options) {\n    return \"\\n(function (root, factory) {\\n    if (typeof define === 'function' && define.amd) {\\n        // AMD. Register as an anonymous module.\\n        define(['chevrotain'], factory);\\n    } else if (typeof module === 'object' && module.exports) {\\n        // Node. Does not work with strict CommonJS, but\\n        // only CommonJS-like environments that support module.exports,\\n        // like Node.\\n        module.exports = factory(require('chevrotain'));\\n    } else {\\n        // Browser globals (root is window)\\n        root.returnExports = factory(root.b);\\n    }\\n}(typeof self !== 'undefined' ? self : this, function (chevrotain) {\\n\\n\" + genClass(options) + \"\\n    \\nreturn {\\n    \" + options.name + \": \" + options.name + \" \\n}\\n}));\\n\";\n}\nexport function genWrapperFunction(options) {\n    return \"    \\n\" + genClass(options) + \"\\nreturn new \" + options.name + \"(tokenVocabulary, config)    \\n\";\n}\nexport function genClass(options) {\n    // TODO: how to pass the token vocabulary? Constructor? other?\n    var result = \"\\nfunction \" + options.name + \"(tokenVocabulary, config) {\\n    // invoke super constructor\\n    // No support for embedded actions currently, so we can 'hardcode'\\n    // The use of CstParser.\\n    chevrotain.CstParser.call(this, tokenVocabulary, config)\\n\\n    const $ = this\\n\\n    \" + genAllRules(options.rules) + \"\\n\\n    // very important to call this after all the rules have been defined.\\n    // otherwise the parser may not work correctly as it will lack information\\n    // derived during the self analysis phase.\\n    this.performSelfAnalysis(this)\\n}\\n\\n// inheritance as implemented in javascript in the previous decade... :(\\n\" + options.name + \".prototype = Object.create(chevrotain.CstParser.prototype)\\n\" + options.name + \".prototype.constructor = \" + options.name + \"    \\n    \";\n    return result;\n}\nexport function genAllRules(rules) {\n    var rulesText = map(rules, function (currRule) {\n        return genRule(currRule, 1);\n    });\n    return rulesText.join(\"\\n\");\n}\nexport function genRule(prod, n) {\n    var result = indent(n, \"$.RULE(\\\"\" + prod.name + \"\\\", function() {\") + NL;\n    result += genDefinition(prod.definition, n + 1);\n    result += indent(n + 1, \"})\") + NL;\n    return result;\n}\nexport function genTerminal(prod, n) {\n    var name = prod.terminalType.name;\n    // TODO: potential performance optimization, avoid tokenMap Dictionary access\n    return indent(n, \"$.CONSUME\" + prod.idx + \"(this.tokensMap.\" + name + \")\" + NL);\n}\nexport function genNonTerminal(prod, n) {\n    return indent(n, \"$.SUBRULE\" + prod.idx + \"($.\" + prod.nonTerminalName + \")\" + NL);\n}\nexport function genAlternation(prod, n) {\n    var result = indent(n, \"$.OR\" + prod.idx + \"([\") + NL;\n    var alts = map(prod.definition, function (altDef) { return genSingleAlt(altDef, n + 1); });\n    result += alts.join(\",\" + NL);\n    result += NL + indent(n, \"])\" + NL);\n    return result;\n}\nexport function genSingleAlt(prod, n) {\n    var result = indent(n, \"{\") + NL;\n    result += indent(n + 1, \"ALT: function() {\") + NL;\n    result += genDefinition(prod.definition, n + 1);\n    result += indent(n + 1, \"}\") + NL;\n    result += indent(n, \"}\");\n    return result;\n}\nfunction genProd(prod, n) {\n    /* istanbul ignore else */\n    if (prod instanceof NonTerminal) {\n        return genNonTerminal(prod, n);\n    }\n    else if (prod instanceof Option) {\n        return genDSLRule(\"OPTION\", prod, n);\n    }\n    else if (prod instanceof RepetitionMandatory) {\n        return genDSLRule(\"AT_LEAST_ONE\", prod, n);\n    }\n    else if (prod instanceof RepetitionMandatoryWithSeparator) {\n        return genDSLRule(\"AT_LEAST_ONE_SEP\", prod, n);\n    }\n    else if (prod instanceof RepetitionWithSeparator) {\n        return genDSLRule(\"MANY_SEP\", prod, n);\n    }\n    else if (prod instanceof Repetition) {\n        return genDSLRule(\"MANY\", prod, n);\n    }\n    else if (prod instanceof Alternation) {\n        return genAlternation(prod, n);\n    }\n    else if (prod instanceof Terminal) {\n        return genTerminal(prod, n);\n    }\n    else if (prod instanceof Alternative) {\n        return genDefinition(prod.definition, n);\n    }\n    else {\n        throw Error(\"non exhaustive match\");\n    }\n}\nfunction genDSLRule(dslName, prod, n) {\n    var result = indent(n, \"$.\" + (dslName + prod.idx) + \"(\");\n    if (prod.separator) {\n        result += \"{\" + NL;\n        result +=\n            indent(n + 1, \"SEP: this.tokensMap.\" + prod.separator.name) + \",\" + NL;\n        result += \"DEF: \" + genDefFunction(prod.definition, n + 2) + NL;\n        result += indent(n, \"}\") + NL;\n    }\n    else {\n        result += genDefFunction(prod.definition, n + 1);\n    }\n    result += indent(n, \")\") + NL;\n    return result;\n}\nfunction genDefFunction(definition, n) {\n    var def = \"function() {\" + NL;\n    def += genDefinition(definition, n);\n    def += indent(n, \"}\") + NL;\n    return def;\n}\nfunction genDefinition(def, n) {\n    var result = \"\";\n    forEach(def, function (prod) {\n        result += genProd(prod, n + 1);\n    });\n    return result;\n}\nfunction indent(howMuch, text) {\n    var spaces = Array(howMuch * 4 + 1).join(\" \");\n    return spaces + text;\n}\n//# sourceMappingURL=generate.js.map"]},"metadata":{},"sourceType":"module"}