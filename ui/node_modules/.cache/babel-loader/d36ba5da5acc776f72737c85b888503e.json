{"ast":null,"code":"ace.define(\"ace/mode/latex_highlight_rules\", [\"require\", \"exports\", \"module\", \"ace/lib/oop\", \"ace/mode/text_highlight_rules\"], function (require, exports, module) {\n  \"use strict\";\n\n  var oop = require(\"../lib/oop\");\n\n  var TextHighlightRules = require(\"./text_highlight_rules\").TextHighlightRules;\n\n  var LatexHighlightRules = function () {\n    this.$rules = {\n      \"start\": [{\n        token: \"comment\",\n        regex: \"%.*$\"\n      }, {\n        token: [\"keyword\", \"lparen\", \"variable.parameter\", \"rparen\", \"lparen\", \"storage.type\", \"rparen\"],\n        regex: \"(\\\\\\\\(?:documentclass|usepackage|input))(?:(\\\\[)([^\\\\]]*)(\\\\]))?({)([^}]*)(})\"\n      }, {\n        token: [\"keyword\", \"lparen\", \"variable.parameter\", \"rparen\"],\n        regex: \"(\\\\\\\\(?:label|v?ref|cite(?:[^{]*)))(?:({)([^}]*)(}))?\"\n      }, {\n        token: [\"storage.type\", \"lparen\", \"variable.parameter\", \"rparen\"],\n        regex: \"(\\\\\\\\begin)({)(verbatim)(})\",\n        next: \"verbatim\"\n      }, {\n        token: [\"storage.type\", \"lparen\", \"variable.parameter\", \"rparen\"],\n        regex: \"(\\\\\\\\begin)({)(lstlisting)(})\",\n        next: \"lstlisting\"\n      }, {\n        token: [\"storage.type\", \"lparen\", \"variable.parameter\", \"rparen\"],\n        regex: \"(\\\\\\\\(?:begin|end))({)([\\\\w*]*)(})\"\n      }, {\n        token: \"storage.type\",\n        regex: /\\\\verb\\b\\*?/,\n        next: [{\n          token: [\"keyword.operator\", \"string\", \"keyword.operator\"],\n          regex: \"(.)(.*?)(\\\\1|$)|\",\n          next: \"start\"\n        }]\n      }, {\n        token: \"storage.type\",\n        regex: \"\\\\\\\\[a-zA-Z]+\"\n      }, {\n        token: \"lparen\",\n        regex: \"[[({]\"\n      }, {\n        token: \"rparen\",\n        regex: \"[\\\\])}]\"\n      }, {\n        token: \"constant.character.escape\",\n        regex: \"\\\\\\\\[^a-zA-Z]?\"\n      }, {\n        token: \"string\",\n        regex: \"\\\\${1,2}\",\n        next: \"equation\"\n      }],\n      \"equation\": [{\n        token: \"comment\",\n        regex: \"%.*$\"\n      }, {\n        token: \"string\",\n        regex: \"\\\\${1,2}\",\n        next: \"start\"\n      }, {\n        token: \"constant.character.escape\",\n        regex: \"\\\\\\\\(?:[^a-zA-Z]|[a-zA-Z]+)\"\n      }, {\n        token: \"error\",\n        regex: \"^\\\\s*$\",\n        next: \"start\"\n      }, {\n        defaultToken: \"string\"\n      }],\n      \"verbatim\": [{\n        token: [\"storage.type\", \"lparen\", \"variable.parameter\", \"rparen\"],\n        regex: \"(\\\\\\\\end)({)(verbatim)(})\",\n        next: \"start\"\n      }, {\n        defaultToken: \"text\"\n      }],\n      \"lstlisting\": [{\n        token: [\"storage.type\", \"lparen\", \"variable.parameter\", \"rparen\"],\n        regex: \"(\\\\\\\\end)({)(lstlisting)(})\",\n        next: \"start\"\n      }, {\n        defaultToken: \"text\"\n      }]\n    };\n    this.normalizeRules();\n  };\n\n  oop.inherits(LatexHighlightRules, TextHighlightRules);\n  exports.LatexHighlightRules = LatexHighlightRules;\n});\nace.define(\"ace/mode/folding/latex\", [\"require\", \"exports\", \"module\", \"ace/lib/oop\", \"ace/mode/folding/fold_mode\", \"ace/range\", \"ace/token_iterator\"], function (require, exports, module) {\n  \"use strict\";\n\n  var oop = require(\"../../lib/oop\");\n\n  var BaseFoldMode = require(\"./fold_mode\").FoldMode;\n\n  var Range = require(\"../../range\").Range;\n\n  var TokenIterator = require(\"../../token_iterator\").TokenIterator;\n\n  var keywordLevels = {\n    \"\\\\subparagraph\": 1,\n    \"\\\\paragraph\": 2,\n    \"\\\\subsubsubsection\": 3,\n    \"\\\\subsubsection\": 4,\n    \"\\\\subsection\": 5,\n    \"\\\\section\": 6,\n    \"\\\\chapter\": 7,\n    \"\\\\part\": 8,\n    \"\\\\begin\": 9,\n    \"\\\\end\": 10\n  };\n\n  var FoldMode = exports.FoldMode = function () {};\n\n  oop.inherits(FoldMode, BaseFoldMode);\n  (function () {\n    this.foldingStartMarker = /^\\s*\\\\(begin)|\\s*\\\\(part|chapter|(?:sub)*(?:section|paragraph))\\b|{\\s*$/;\n    this.foldingStopMarker = /^\\s*\\\\(end)\\b|^\\s*}/;\n\n    this.getFoldWidgetRange = function (session, foldStyle, row) {\n      var line = session.doc.getLine(row);\n      var match = this.foldingStartMarker.exec(line);\n\n      if (match) {\n        if (match[1]) return this.latexBlock(session, row, match[0].length - 1);\n        if (match[2]) return this.latexSection(session, row, match[0].length - 1);\n        return this.openingBracketBlock(session, \"{\", row, match.index);\n      }\n\n      var match = this.foldingStopMarker.exec(line);\n\n      if (match) {\n        if (match[1]) return this.latexBlock(session, row, match[0].length - 1);\n        return this.closingBracketBlock(session, \"}\", row, match.index + match[0].length);\n      }\n    };\n\n    this.latexBlock = function (session, row, column, returnRange) {\n      var keywords = {\n        \"\\\\begin\": 1,\n        \"\\\\end\": -1\n      };\n      var stream = new TokenIterator(session, row, column);\n      var token = stream.getCurrentToken();\n      if (!token || !(token.type == \"storage.type\" || token.type == \"constant.character.escape\")) return;\n      var val = token.value;\n      var dir = keywords[val];\n\n      var getType = function () {\n        var token = stream.stepForward();\n        var type = token.type == \"lparen\" ? stream.stepForward().value : \"\";\n\n        if (dir === -1) {\n          stream.stepBackward();\n          if (type) stream.stepBackward();\n        }\n\n        return type;\n      };\n\n      var stack = [getType()];\n      var startColumn = dir === -1 ? stream.getCurrentTokenColumn() : session.getLine(row).length;\n      var startRow = row;\n      stream.step = dir === -1 ? stream.stepBackward : stream.stepForward;\n\n      while (token = stream.step()) {\n        if (!token || !(token.type == \"storage.type\" || token.type == \"constant.character.escape\")) continue;\n        var level = keywords[token.value];\n        if (!level) continue;\n        var type = getType();\n        if (level === dir) stack.unshift(type);else if (stack.shift() !== type || !stack.length) break;\n      }\n\n      if (stack.length) return;\n\n      if (dir == 1) {\n        stream.stepBackward();\n        stream.stepBackward();\n      }\n\n      if (returnRange) return stream.getCurrentTokenRange();\n      var row = stream.getCurrentTokenRow();\n      if (dir === -1) return new Range(row, session.getLine(row).length, startRow, startColumn);else return new Range(startRow, startColumn, row, stream.getCurrentTokenColumn());\n    };\n\n    this.latexSection = function (session, row, column) {\n      var stream = new TokenIterator(session, row, column);\n      var token = stream.getCurrentToken();\n      if (!token || token.type != \"storage.type\") return;\n      var startLevel = keywordLevels[token.value] || 0;\n      var stackDepth = 0;\n      var endRow = row;\n\n      while (token = stream.stepForward()) {\n        if (token.type !== \"storage.type\") continue;\n        var level = keywordLevels[token.value] || 0;\n\n        if (level >= 9) {\n          if (!stackDepth) endRow = stream.getCurrentTokenRow() - 1;\n          stackDepth += level == 9 ? 1 : -1;\n          if (stackDepth < 0) break;\n        } else if (level >= startLevel) break;\n      }\n\n      if (!stackDepth) endRow = stream.getCurrentTokenRow() - 1;\n\n      while (endRow > row && !/\\S/.test(session.getLine(endRow))) endRow--;\n\n      return new Range(row, session.getLine(row).length, endRow, session.getLine(endRow).length);\n    };\n  }).call(FoldMode.prototype);\n});\nace.define(\"ace/mode/latex\", [\"require\", \"exports\", \"module\", \"ace/lib/oop\", \"ace/mode/text\", \"ace/mode/latex_highlight_rules\", \"ace/mode/behaviour/cstyle\", \"ace/mode/folding/latex\"], function (require, exports, module) {\n  \"use strict\";\n\n  var oop = require(\"../lib/oop\");\n\n  var TextMode = require(\"./text\").Mode;\n\n  var LatexHighlightRules = require(\"./latex_highlight_rules\").LatexHighlightRules;\n\n  var CstyleBehaviour = require(\"./behaviour/cstyle\").CstyleBehaviour;\n\n  var LatexFoldMode = require(\"./folding/latex\").FoldMode;\n\n  var Mode = function () {\n    this.HighlightRules = LatexHighlightRules;\n    this.foldingRules = new LatexFoldMode();\n    this.$behaviour = new CstyleBehaviour({\n      braces: true\n    });\n  };\n\n  oop.inherits(Mode, TextMode);\n  (function () {\n    this.type = \"text\";\n    this.lineCommentStart = \"%\";\n    this.$id = \"ace/mode/latex\";\n\n    this.getMatching = function (session, row, column) {\n      if (row == undefined) row = session.selection.lead;\n\n      if (typeof row == \"object\") {\n        column = row.column;\n        row = row.row;\n      }\n\n      var startToken = session.getTokenAt(row, column);\n      if (!startToken) return;\n\n      if (startToken.value == \"\\\\begin\" || startToken.value == \"\\\\end\") {\n        return this.foldingRules.latexBlock(session, row, column, true);\n      }\n    };\n  }).call(Mode.prototype);\n  exports.Mode = Mode;\n});\n\n(function () {\n  ace.require([\"ace/mode/latex\"], function (m) {\n    if (typeof module == \"object\" && typeof exports == \"object\" && module) {\n      module.exports = m;\n    }\n  });\n})();","map":{"version":3,"sources":["/home/magoo/projects/keyrier-json/node_modules/ace-builds/src-noconflict/mode-latex.js"],"names":["ace","define","require","exports","module","oop","TextHighlightRules","LatexHighlightRules","$rules","token","regex","next","defaultToken","normalizeRules","inherits","BaseFoldMode","FoldMode","Range","TokenIterator","keywordLevels","foldingStartMarker","foldingStopMarker","getFoldWidgetRange","session","foldStyle","row","line","doc","getLine","match","exec","latexBlock","length","latexSection","openingBracketBlock","index","closingBracketBlock","column","returnRange","keywords","stream","getCurrentToken","type","val","value","dir","getType","stepForward","stepBackward","stack","startColumn","getCurrentTokenColumn","startRow","step","level","unshift","shift","getCurrentTokenRange","getCurrentTokenRow","startLevel","stackDepth","endRow","test","call","prototype","TextMode","Mode","CstyleBehaviour","LatexFoldMode","HighlightRules","foldingRules","$behaviour","braces","lineCommentStart","$id","getMatching","undefined","selection","lead","startToken","getTokenAt","m"],"mappings":"AAAAA,GAAG,CAACC,MAAJ,CAAW,gCAAX,EAA4C,CAAC,SAAD,EAAW,SAAX,EAAqB,QAArB,EAA8B,aAA9B,EAA4C,+BAA5C,CAA5C,EAA0H,UAASC,OAAT,EAAkBC,OAAlB,EAA2BC,MAA3B,EAAmC;AAC7J;;AAEA,MAAIC,GAAG,GAAGH,OAAO,CAAC,YAAD,CAAjB;;AACA,MAAII,kBAAkB,GAAGJ,OAAO,CAAC,wBAAD,CAAP,CAAkCI,kBAA3D;;AAEA,MAAIC,mBAAmB,GAAG,YAAW;AAEjC,SAAKC,MAAL,GAAc;AACV,eAAU,CAAC;AACPC,QAAAA,KAAK,EAAG,SADD;AAEPC,QAAAA,KAAK,EAAG;AAFD,OAAD,EAGP;AACCD,QAAAA,KAAK,EAAG,CAAC,SAAD,EAAY,QAAZ,EAAsB,oBAAtB,EAA4C,QAA5C,EAAsD,QAAtD,EAAgE,cAAhE,EAAgF,QAAhF,CADT;AAECC,QAAAA,KAAK,EAAG;AAFT,OAHO,EAMP;AACCD,QAAAA,KAAK,EAAG,CAAC,SAAD,EAAW,QAAX,EAAqB,oBAArB,EAA2C,QAA3C,CADT;AAECC,QAAAA,KAAK,EAAG;AAFT,OANO,EASP;AACCD,QAAAA,KAAK,EAAG,CAAC,cAAD,EAAiB,QAAjB,EAA2B,oBAA3B,EAAiD,QAAjD,CADT;AAECC,QAAAA,KAAK,EAAG,6BAFT;AAGCC,QAAAA,IAAI,EAAG;AAHR,OATO,EAaN;AACAF,QAAAA,KAAK,EAAG,CAAC,cAAD,EAAiB,QAAjB,EAA2B,oBAA3B,EAAiD,QAAjD,CADR;AAEAC,QAAAA,KAAK,EAAG,+BAFR;AAGAC,QAAAA,IAAI,EAAG;AAHP,OAbM,EAiBN;AACAF,QAAAA,KAAK,EAAG,CAAC,cAAD,EAAiB,QAAjB,EAA2B,oBAA3B,EAAiD,QAAjD,CADR;AAEAC,QAAAA,KAAK,EAAG;AAFR,OAjBM,EAoBP;AACCD,QAAAA,KAAK,EAAG,cADT;AAECC,QAAAA,KAAK,EAAG,aAFT;AAGCC,QAAAA,IAAI,EAAG,CAAC;AACJF,UAAAA,KAAK,EAAG,CAAC,kBAAD,EAAqB,QAArB,EAA+B,kBAA/B,CADJ;AAEJC,UAAAA,KAAK,EAAG,kBAFJ;AAGJC,UAAAA,IAAI,EAAG;AAHH,SAAD;AAHR,OApBO,EA4BP;AACCF,QAAAA,KAAK,EAAG,cADT;AAECC,QAAAA,KAAK,EAAG;AAFT,OA5BO,EA+BP;AACCD,QAAAA,KAAK,EAAG,QADT;AAECC,QAAAA,KAAK,EAAG;AAFT,OA/BO,EAkCP;AACCD,QAAAA,KAAK,EAAG,QADT;AAECC,QAAAA,KAAK,EAAG;AAFT,OAlCO,EAqCP;AACCD,QAAAA,KAAK,EAAG,2BADT;AAECC,QAAAA,KAAK,EAAG;AAFT,OArCO,EAwCP;AACCD,QAAAA,KAAK,EAAG,QADT;AAECC,QAAAA,KAAK,EAAG,UAFT;AAGCC,QAAAA,IAAI,EAAI;AAHT,OAxCO,CADA;AA8CV,kBAAa,CAAC;AACVF,QAAAA,KAAK,EAAG,SADE;AAEVC,QAAAA,KAAK,EAAG;AAFE,OAAD,EAGV;AACCD,QAAAA,KAAK,EAAG,QADT;AAECC,QAAAA,KAAK,EAAG,UAFT;AAGCC,QAAAA,IAAI,EAAI;AAHT,OAHU,EAOV;AACCF,QAAAA,KAAK,EAAG,2BADT;AAECC,QAAAA,KAAK,EAAG;AAFT,OAPU,EAUV;AACCD,QAAAA,KAAK,EAAG,OADT;AAECC,QAAAA,KAAK,EAAG,QAFT;AAGCC,QAAAA,IAAI,EAAG;AAHR,OAVU,EAcV;AACCC,QAAAA,YAAY,EAAG;AADhB,OAdU,CA9CH;AA+DV,kBAAY,CAAC;AACTH,QAAAA,KAAK,EAAG,CAAC,cAAD,EAAiB,QAAjB,EAA2B,oBAA3B,EAAiD,QAAjD,CADC;AAETC,QAAAA,KAAK,EAAG,2BAFC;AAGTC,QAAAA,IAAI,EAAG;AAHE,OAAD,EAIT;AACCC,QAAAA,YAAY,EAAG;AADhB,OAJS,CA/DF;AAsEV,oBAAc,CAAC;AACXH,QAAAA,KAAK,EAAG,CAAC,cAAD,EAAiB,QAAjB,EAA2B,oBAA3B,EAAiD,QAAjD,CADG;AAEXC,QAAAA,KAAK,EAAG,6BAFG;AAGXC,QAAAA,IAAI,EAAG;AAHI,OAAD,EAIX;AACCC,QAAAA,YAAY,EAAG;AADhB,OAJW;AAtEJ,KAAd;AA+EA,SAAKC,cAAL;AACH,GAlFD;;AAmFAR,EAAAA,GAAG,CAACS,QAAJ,CAAaP,mBAAb,EAAkCD,kBAAlC;AAEAH,EAAAA,OAAO,CAACI,mBAAR,GAA8BA,mBAA9B;AAEC,CA7FD;AA+FAP,GAAG,CAACC,MAAJ,CAAW,wBAAX,EAAoC,CAAC,SAAD,EAAW,SAAX,EAAqB,QAArB,EAA8B,aAA9B,EAA4C,4BAA5C,EAAyE,WAAzE,EAAqF,oBAArF,CAApC,EAAgJ,UAASC,OAAT,EAAkBC,OAAlB,EAA2BC,MAA3B,EAAmC;AACnL;;AAEA,MAAIC,GAAG,GAAGH,OAAO,CAAC,eAAD,CAAjB;;AACA,MAAIa,YAAY,GAAGb,OAAO,CAAC,aAAD,CAAP,CAAuBc,QAA1C;;AACA,MAAIC,KAAK,GAAGf,OAAO,CAAC,aAAD,CAAP,CAAuBe,KAAnC;;AACA,MAAIC,aAAa,GAAGhB,OAAO,CAAC,sBAAD,CAAP,CAAgCgB,aAApD;;AACA,MAAIC,aAAa,GAAG;AAChB,sBAAkB,CADF;AAEhB,mBAAe,CAFC;AAGhB,0BAAsB,CAHN;AAIhB,uBAAmB,CAJH;AAKhB,oBAAgB,CALA;AAMhB,iBAAa,CANG;AAOhB,iBAAa,CAPG;AAQhB,cAAU,CARM;AAShB,eAAW,CATK;AAUhB,aAAS;AAVO,GAApB;;AAaA,MAAIH,QAAQ,GAAGb,OAAO,CAACa,QAAR,GAAmB,YAAW,CAAE,CAA/C;;AAEAX,EAAAA,GAAG,CAACS,QAAJ,CAAaE,QAAb,EAAuBD,YAAvB;AAEA,GAAC,YAAW;AAER,SAAKK,kBAAL,GAA0B,yEAA1B;AACA,SAAKC,iBAAL,GAAyB,qBAAzB;;AAEA,SAAKC,kBAAL,GAA0B,UAASC,OAAT,EAAkBC,SAAlB,EAA6BC,GAA7B,EAAkC;AACxD,UAAIC,IAAI,GAAGH,OAAO,CAACI,GAAR,CAAYC,OAAZ,CAAoBH,GAApB,CAAX;AACA,UAAII,KAAK,GAAG,KAAKT,kBAAL,CAAwBU,IAAxB,CAA6BJ,IAA7B,CAAZ;;AACA,UAAIG,KAAJ,EAAW;AACP,YAAIA,KAAK,CAAC,CAAD,CAAT,EACI,OAAO,KAAKE,UAAL,CAAgBR,OAAhB,EAAyBE,GAAzB,EAA8BI,KAAK,CAAC,CAAD,CAAL,CAASG,MAAT,GAAkB,CAAhD,CAAP;AACJ,YAAIH,KAAK,CAAC,CAAD,CAAT,EACI,OAAO,KAAKI,YAAL,CAAkBV,OAAlB,EAA2BE,GAA3B,EAAgCI,KAAK,CAAC,CAAD,CAAL,CAASG,MAAT,GAAkB,CAAlD,CAAP;AAEJ,eAAO,KAAKE,mBAAL,CAAyBX,OAAzB,EAAkC,GAAlC,EAAuCE,GAAvC,EAA4CI,KAAK,CAACM,KAAlD,CAAP;AACH;;AAED,UAAIN,KAAK,GAAG,KAAKR,iBAAL,CAAuBS,IAAvB,CAA4BJ,IAA5B,CAAZ;;AACA,UAAIG,KAAJ,EAAW;AACP,YAAIA,KAAK,CAAC,CAAD,CAAT,EACI,OAAO,KAAKE,UAAL,CAAgBR,OAAhB,EAAyBE,GAAzB,EAA8BI,KAAK,CAAC,CAAD,CAAL,CAASG,MAAT,GAAkB,CAAhD,CAAP;AAEJ,eAAO,KAAKI,mBAAL,CAAyBb,OAAzB,EAAkC,GAAlC,EAAuCE,GAAvC,EAA4CI,KAAK,CAACM,KAAN,GAAcN,KAAK,CAAC,CAAD,CAAL,CAASG,MAAnE,CAAP;AACH;AACJ,KAnBD;;AAqBA,SAAKD,UAAL,GAAkB,UAASR,OAAT,EAAkBE,GAAlB,EAAuBY,MAAvB,EAA+BC,WAA/B,EAA4C;AAC1D,UAAIC,QAAQ,GAAG;AACX,mBAAW,CADA;AAEX,iBAAS,CAAC;AAFC,OAAf;AAKA,UAAIC,MAAM,GAAG,IAAItB,aAAJ,CAAkBK,OAAlB,EAA2BE,GAA3B,EAAgCY,MAAhC,CAAb;AACA,UAAI5B,KAAK,GAAG+B,MAAM,CAACC,eAAP,EAAZ;AACA,UAAI,CAAChC,KAAD,IAAU,EAAEA,KAAK,CAACiC,IAAN,IAAc,cAAd,IAAgCjC,KAAK,CAACiC,IAAN,IAAc,2BAAhD,CAAd,EACI;AAEJ,UAAIC,GAAG,GAAGlC,KAAK,CAACmC,KAAhB;AACA,UAAIC,GAAG,GAAGN,QAAQ,CAACI,GAAD,CAAlB;;AAEA,UAAIG,OAAO,GAAG,YAAW;AACrB,YAAIrC,KAAK,GAAG+B,MAAM,CAACO,WAAP,EAAZ;AACA,YAAIL,IAAI,GAAGjC,KAAK,CAACiC,IAAN,IAAc,QAAd,GAAwBF,MAAM,CAACO,WAAP,GAAqBH,KAA7C,GAAqD,EAAhE;;AACA,YAAIC,GAAG,KAAK,CAAC,CAAb,EAAgB;AACZL,UAAAA,MAAM,CAACQ,YAAP;AACA,cAAIN,IAAJ,EACIF,MAAM,CAACQ,YAAP;AACP;;AACD,eAAON,IAAP;AACH,OATD;;AAUA,UAAIO,KAAK,GAAG,CAACH,OAAO,EAAR,CAAZ;AACA,UAAII,WAAW,GAAGL,GAAG,KAAK,CAAC,CAAT,GAAaL,MAAM,CAACW,qBAAP,EAAb,GAA8C5B,OAAO,CAACK,OAAR,CAAgBH,GAAhB,EAAqBO,MAArF;AACA,UAAIoB,QAAQ,GAAG3B,GAAf;AAEAe,MAAAA,MAAM,CAACa,IAAP,GAAcR,GAAG,KAAK,CAAC,CAAT,GAAaL,MAAM,CAACQ,YAApB,GAAmCR,MAAM,CAACO,WAAxD;;AACA,aAAMtC,KAAK,GAAG+B,MAAM,CAACa,IAAP,EAAd,EAA6B;AACzB,YAAI,CAAC5C,KAAD,IAAU,EAAEA,KAAK,CAACiC,IAAN,IAAc,cAAd,IAAgCjC,KAAK,CAACiC,IAAN,IAAc,2BAAhD,CAAd,EACI;AACJ,YAAIY,KAAK,GAAGf,QAAQ,CAAC9B,KAAK,CAACmC,KAAP,CAApB;AACA,YAAI,CAACU,KAAL,EACI;AACJ,YAAIZ,IAAI,GAAGI,OAAO,EAAlB;AACA,YAAIQ,KAAK,KAAKT,GAAd,EACII,KAAK,CAACM,OAAN,CAAcb,IAAd,EADJ,KAEK,IAAIO,KAAK,CAACO,KAAN,OAAkBd,IAAlB,IAA0B,CAACO,KAAK,CAACjB,MAArC,EACD;AACP;;AAED,UAAIiB,KAAK,CAACjB,MAAV,EACI;;AAEJ,UAAIa,GAAG,IAAI,CAAX,EAAc;AACVL,QAAAA,MAAM,CAACQ,YAAP;AACAR,QAAAA,MAAM,CAACQ,YAAP;AACH;;AAED,UAAIV,WAAJ,EACI,OAAOE,MAAM,CAACiB,oBAAP,EAAP;AAEJ,UAAIhC,GAAG,GAAGe,MAAM,CAACkB,kBAAP,EAAV;AACA,UAAIb,GAAG,KAAK,CAAC,CAAb,EACI,OAAO,IAAI5B,KAAJ,CAAUQ,GAAV,EAAeF,OAAO,CAACK,OAAR,CAAgBH,GAAhB,EAAqBO,MAApC,EAA4CoB,QAA5C,EAAsDF,WAAtD,CAAP,CADJ,KAGI,OAAO,IAAIjC,KAAJ,CAAUmC,QAAV,EAAoBF,WAApB,EAAiCzB,GAAjC,EAAsCe,MAAM,CAACW,qBAAP,EAAtC,CAAP;AACP,KA1DD;;AA4DA,SAAKlB,YAAL,GAAoB,UAASV,OAAT,EAAkBE,GAAlB,EAAuBY,MAAvB,EAA+B;AAC/C,UAAIG,MAAM,GAAG,IAAItB,aAAJ,CAAkBK,OAAlB,EAA2BE,GAA3B,EAAgCY,MAAhC,CAAb;AACA,UAAI5B,KAAK,GAAG+B,MAAM,CAACC,eAAP,EAAZ;AACA,UAAI,CAAChC,KAAD,IAAUA,KAAK,CAACiC,IAAN,IAAc,cAA5B,EACI;AAEJ,UAAIiB,UAAU,GAAGxC,aAAa,CAACV,KAAK,CAACmC,KAAP,CAAb,IAA8B,CAA/C;AACA,UAAIgB,UAAU,GAAG,CAAjB;AACA,UAAIC,MAAM,GAAGpC,GAAb;;AAEA,aAAMhB,KAAK,GAAG+B,MAAM,CAACO,WAAP,EAAd,EAAoC;AAChC,YAAItC,KAAK,CAACiC,IAAN,KAAe,cAAnB,EACI;AACJ,YAAIY,KAAK,GAAGnC,aAAa,CAACV,KAAK,CAACmC,KAAP,CAAb,IAA8B,CAA1C;;AAEA,YAAIU,KAAK,IAAI,CAAb,EAAgB;AACZ,cAAI,CAACM,UAAL,EACIC,MAAM,GAAGrB,MAAM,CAACkB,kBAAP,KAA8B,CAAvC;AACJE,UAAAA,UAAU,IAAIN,KAAK,IAAI,CAAT,GAAa,CAAb,GAAiB,CAAE,CAAjC;AACA,cAAIM,UAAU,GAAG,CAAjB,EACI;AACP,SAND,MAMO,IAAIN,KAAK,IAAIK,UAAb,EACH;AACP;;AAED,UAAI,CAACC,UAAL,EACIC,MAAM,GAAGrB,MAAM,CAACkB,kBAAP,KAA8B,CAAvC;;AAEJ,aAAOG,MAAM,GAAGpC,GAAT,IAAgB,CAAC,KAAKqC,IAAL,CAAUvC,OAAO,CAACK,OAAR,CAAgBiC,MAAhB,CAAV,CAAxB,EACIA,MAAM;;AAEV,aAAO,IAAI5C,KAAJ,CACHQ,GADG,EACEF,OAAO,CAACK,OAAR,CAAgBH,GAAhB,EAAqBO,MADvB,EAEH6B,MAFG,EAEKtC,OAAO,CAACK,OAAR,CAAgBiC,MAAhB,EAAwB7B,MAF7B,CAAP;AAIH,KAnCD;AAqCH,GA3HD,EA2HG+B,IA3HH,CA2HQ/C,QAAQ,CAACgD,SA3HjB;AA6HC,CArJD;AAuJAhE,GAAG,CAACC,MAAJ,CAAW,gBAAX,EAA4B,CAAC,SAAD,EAAW,SAAX,EAAqB,QAArB,EAA8B,aAA9B,EAA4C,eAA5C,EAA4D,gCAA5D,EAA6F,2BAA7F,EAAyH,wBAAzH,CAA5B,EAAgL,UAASC,OAAT,EAAkBC,OAAlB,EAA2BC,MAA3B,EAAmC;AACnN;;AAEA,MAAIC,GAAG,GAAGH,OAAO,CAAC,YAAD,CAAjB;;AACA,MAAI+D,QAAQ,GAAG/D,OAAO,CAAC,QAAD,CAAP,CAAkBgE,IAAjC;;AACA,MAAI3D,mBAAmB,GAAGL,OAAO,CAAC,yBAAD,CAAP,CAAmCK,mBAA7D;;AACA,MAAI4D,eAAe,GAAGjE,OAAO,CAAC,oBAAD,CAAP,CAA8BiE,eAApD;;AACA,MAAIC,aAAa,GAAGlE,OAAO,CAAC,iBAAD,CAAP,CAA2Bc,QAA/C;;AAEA,MAAIkD,IAAI,GAAG,YAAW;AAClB,SAAKG,cAAL,GAAsB9D,mBAAtB;AACA,SAAK+D,YAAL,GAAoB,IAAIF,aAAJ,EAApB;AACA,SAAKG,UAAL,GAAkB,IAAIJ,eAAJ,CAAoB;AAAEK,MAAAA,MAAM,EAAE;AAAV,KAApB,CAAlB;AACH,GAJD;;AAKAnE,EAAAA,GAAG,CAACS,QAAJ,CAAaoD,IAAb,EAAmBD,QAAnB;AAEA,GAAC,YAAW;AACR,SAAKvB,IAAL,GAAY,MAAZ;AAEA,SAAK+B,gBAAL,GAAwB,GAAxB;AAEA,SAAKC,GAAL,GAAW,gBAAX;;AAEA,SAAKC,WAAL,GAAmB,UAASpD,OAAT,EAAkBE,GAAlB,EAAuBY,MAAvB,EAA+B;AAC9C,UAAIZ,GAAG,IAAImD,SAAX,EACInD,GAAG,GAAGF,OAAO,CAACsD,SAAR,CAAkBC,IAAxB;;AACJ,UAAI,OAAOrD,GAAP,IAAc,QAAlB,EAA4B;AACxBY,QAAAA,MAAM,GAAGZ,GAAG,CAACY,MAAb;AACAZ,QAAAA,GAAG,GAAGA,GAAG,CAACA,GAAV;AACH;;AAED,UAAIsD,UAAU,GAAGxD,OAAO,CAACyD,UAAR,CAAmBvD,GAAnB,EAAwBY,MAAxB,CAAjB;AACA,UAAI,CAAC0C,UAAL,EACI;;AACJ,UAAIA,UAAU,CAACnC,KAAX,IAAoB,SAApB,IAAiCmC,UAAU,CAACnC,KAAX,IAAoB,OAAzD,EAAkE;AAC9D,eAAO,KAAK0B,YAAL,CAAkBvC,UAAlB,CAA6BR,OAA7B,EAAsCE,GAAtC,EAA2CY,MAA3C,EAAmD,IAAnD,CAAP;AACH;AACJ,KAdD;AAeH,GAtBD,EAsBG0B,IAtBH,CAsBQG,IAAI,CAACF,SAtBb;AAwBA7D,EAAAA,OAAO,CAAC+D,IAAR,GAAeA,IAAf;AAEC,CA1CD;;AA0CmB,CAAC,YAAW;AACXlE,EAAAA,GAAG,CAACE,OAAJ,CAAY,CAAC,gBAAD,CAAZ,EAAgC,UAAS+E,CAAT,EAAY;AACxC,QAAI,OAAO7E,MAAP,IAAiB,QAAjB,IAA6B,OAAOD,OAAP,IAAkB,QAA/C,IAA2DC,MAA/D,EAAuE;AACnEA,MAAAA,MAAM,CAACD,OAAP,GAAiB8E,CAAjB;AACH;AACJ,GAJD;AAKH,CANE","sourcesContent":["ace.define(\"ace/mode/latex_highlight_rules\",[\"require\",\"exports\",\"module\",\"ace/lib/oop\",\"ace/mode/text_highlight_rules\"], function(require, exports, module) {\n\"use strict\";\n\nvar oop = require(\"../lib/oop\");\nvar TextHighlightRules = require(\"./text_highlight_rules\").TextHighlightRules;\n\nvar LatexHighlightRules = function() {  \n\n    this.$rules = {\n        \"start\" : [{\n            token : \"comment\",\n            regex : \"%.*$\"\n        }, {\n            token : [\"keyword\", \"lparen\", \"variable.parameter\", \"rparen\", \"lparen\", \"storage.type\", \"rparen\"],\n            regex : \"(\\\\\\\\(?:documentclass|usepackage|input))(?:(\\\\[)([^\\\\]]*)(\\\\]))?({)([^}]*)(})\"\n        }, {\n            token : [\"keyword\",\"lparen\", \"variable.parameter\", \"rparen\"],\n            regex : \"(\\\\\\\\(?:label|v?ref|cite(?:[^{]*)))(?:({)([^}]*)(}))?\"\n        }, {\n            token : [\"storage.type\", \"lparen\", \"variable.parameter\", \"rparen\"],\n            regex : \"(\\\\\\\\begin)({)(verbatim)(})\",\n            next : \"verbatim\"\n        },  {\n            token : [\"storage.type\", \"lparen\", \"variable.parameter\", \"rparen\"],\n            regex : \"(\\\\\\\\begin)({)(lstlisting)(})\",\n            next : \"lstlisting\"\n        },  {\n            token : [\"storage.type\", \"lparen\", \"variable.parameter\", \"rparen\"],\n            regex : \"(\\\\\\\\(?:begin|end))({)([\\\\w*]*)(})\"\n        }, {\n            token : \"storage.type\",\n            regex : /\\\\verb\\b\\*?/,\n            next : [{\n                token : [\"keyword.operator\", \"string\", \"keyword.operator\"],\n                regex : \"(.)(.*?)(\\\\1|$)|\",\n                next : \"start\"\n            }]\n        }, {\n            token : \"storage.type\",\n            regex : \"\\\\\\\\[a-zA-Z]+\"\n        }, {\n            token : \"lparen\",\n            regex : \"[[({]\"\n        }, {\n            token : \"rparen\",\n            regex : \"[\\\\])}]\"\n        }, {\n            token : \"constant.character.escape\",\n            regex : \"\\\\\\\\[^a-zA-Z]?\"\n        }, {\n            token : \"string\",\n            regex : \"\\\\${1,2}\",\n            next  : \"equation\"\n        }],\n        \"equation\" : [{\n            token : \"comment\",\n            regex : \"%.*$\"\n        }, {\n            token : \"string\",\n            regex : \"\\\\${1,2}\",\n            next  : \"start\"\n        }, {\n            token : \"constant.character.escape\",\n            regex : \"\\\\\\\\(?:[^a-zA-Z]|[a-zA-Z]+)\"\n        }, {\n            token : \"error\", \n            regex : \"^\\\\s*$\", \n            next : \"start\" \n        }, {\n            defaultToken : \"string\"\n        }],\n        \"verbatim\": [{\n            token : [\"storage.type\", \"lparen\", \"variable.parameter\", \"rparen\"],\n            regex : \"(\\\\\\\\end)({)(verbatim)(})\",\n            next : \"start\"\n        }, {\n            defaultToken : \"text\"\n        }],\n        \"lstlisting\": [{\n            token : [\"storage.type\", \"lparen\", \"variable.parameter\", \"rparen\"],\n            regex : \"(\\\\\\\\end)({)(lstlisting)(})\",\n            next : \"start\"\n        }, {\n            defaultToken : \"text\"\n        }]\n    };\n    \n    this.normalizeRules();\n};\noop.inherits(LatexHighlightRules, TextHighlightRules);\n\nexports.LatexHighlightRules = LatexHighlightRules;\n\n});\n\nace.define(\"ace/mode/folding/latex\",[\"require\",\"exports\",\"module\",\"ace/lib/oop\",\"ace/mode/folding/fold_mode\",\"ace/range\",\"ace/token_iterator\"], function(require, exports, module) {\n\"use strict\";\n\nvar oop = require(\"../../lib/oop\");\nvar BaseFoldMode = require(\"./fold_mode\").FoldMode;\nvar Range = require(\"../../range\").Range;\nvar TokenIterator = require(\"../../token_iterator\").TokenIterator;\nvar keywordLevels = {\n    \"\\\\subparagraph\": 1,\n    \"\\\\paragraph\": 2,\n    \"\\\\subsubsubsection\": 3,\n    \"\\\\subsubsection\": 4,\n    \"\\\\subsection\": 5,\n    \"\\\\section\": 6,\n    \"\\\\chapter\": 7,\n    \"\\\\part\": 8,\n    \"\\\\begin\": 9,\n    \"\\\\end\": 10\n};\n\nvar FoldMode = exports.FoldMode = function() {};\n\noop.inherits(FoldMode, BaseFoldMode);\n\n(function() {\n\n    this.foldingStartMarker = /^\\s*\\\\(begin)|\\s*\\\\(part|chapter|(?:sub)*(?:section|paragraph))\\b|{\\s*$/;\n    this.foldingStopMarker = /^\\s*\\\\(end)\\b|^\\s*}/;\n\n    this.getFoldWidgetRange = function(session, foldStyle, row) {\n        var line = session.doc.getLine(row);\n        var match = this.foldingStartMarker.exec(line);\n        if (match) {\n            if (match[1])\n                return this.latexBlock(session, row, match[0].length - 1);\n            if (match[2])\n                return this.latexSection(session, row, match[0].length - 1);\n\n            return this.openingBracketBlock(session, \"{\", row, match.index);\n        }\n\n        var match = this.foldingStopMarker.exec(line);\n        if (match) {\n            if (match[1])\n                return this.latexBlock(session, row, match[0].length - 1);\n\n            return this.closingBracketBlock(session, \"}\", row, match.index + match[0].length);\n        }\n    };\n\n    this.latexBlock = function(session, row, column, returnRange) {\n        var keywords = {\n            \"\\\\begin\": 1,\n            \"\\\\end\": -1\n        };\n\n        var stream = new TokenIterator(session, row, column);\n        var token = stream.getCurrentToken();\n        if (!token || !(token.type == \"storage.type\" || token.type == \"constant.character.escape\"))\n            return;\n\n        var val = token.value;\n        var dir = keywords[val];\n\n        var getType = function() {\n            var token = stream.stepForward();\n            var type = token.type == \"lparen\" ?stream.stepForward().value : \"\";\n            if (dir === -1) {\n                stream.stepBackward();\n                if (type)\n                    stream.stepBackward();\n            }\n            return type;\n        };\n        var stack = [getType()];\n        var startColumn = dir === -1 ? stream.getCurrentTokenColumn() : session.getLine(row).length;\n        var startRow = row;\n\n        stream.step = dir === -1 ? stream.stepBackward : stream.stepForward;\n        while(token = stream.step()) {\n            if (!token || !(token.type == \"storage.type\" || token.type == \"constant.character.escape\"))\n                continue;\n            var level = keywords[token.value];\n            if (!level)\n                continue;\n            var type = getType();\n            if (level === dir)\n                stack.unshift(type);\n            else if (stack.shift() !== type || !stack.length)\n                break;\n        }\n\n        if (stack.length)\n            return;\n        \n        if (dir == 1) {\n            stream.stepBackward();\n            stream.stepBackward();\n        }\n        \n        if (returnRange)\n            return stream.getCurrentTokenRange();\n\n        var row = stream.getCurrentTokenRow();\n        if (dir === -1)\n            return new Range(row, session.getLine(row).length, startRow, startColumn);\n        else\n            return new Range(startRow, startColumn, row, stream.getCurrentTokenColumn());\n    };\n\n    this.latexSection = function(session, row, column) {\n        var stream = new TokenIterator(session, row, column);\n        var token = stream.getCurrentToken();\n        if (!token || token.type != \"storage.type\")\n            return;\n\n        var startLevel = keywordLevels[token.value] || 0;\n        var stackDepth = 0;\n        var endRow = row;\n\n        while(token = stream.stepForward()) {\n            if (token.type !== \"storage.type\")\n                continue;\n            var level = keywordLevels[token.value] || 0;\n\n            if (level >= 9) {\n                if (!stackDepth)\n                    endRow = stream.getCurrentTokenRow() - 1;\n                stackDepth += level == 9 ? 1 : - 1;\n                if (stackDepth < 0)\n                    break;\n            } else if (level >= startLevel)\n                break;\n        }\n\n        if (!stackDepth)\n            endRow = stream.getCurrentTokenRow() - 1;\n\n        while (endRow > row && !/\\S/.test(session.getLine(endRow)))\n            endRow--;\n\n        return new Range(\n            row, session.getLine(row).length,\n            endRow, session.getLine(endRow).length\n        );\n    };\n\n}).call(FoldMode.prototype);\n\n});\n\nace.define(\"ace/mode/latex\",[\"require\",\"exports\",\"module\",\"ace/lib/oop\",\"ace/mode/text\",\"ace/mode/latex_highlight_rules\",\"ace/mode/behaviour/cstyle\",\"ace/mode/folding/latex\"], function(require, exports, module) {\n\"use strict\";\n\nvar oop = require(\"../lib/oop\");\nvar TextMode = require(\"./text\").Mode;\nvar LatexHighlightRules = require(\"./latex_highlight_rules\").LatexHighlightRules;\nvar CstyleBehaviour = require(\"./behaviour/cstyle\").CstyleBehaviour;\nvar LatexFoldMode = require(\"./folding/latex\").FoldMode;\n\nvar Mode = function() {\n    this.HighlightRules = LatexHighlightRules;\n    this.foldingRules = new LatexFoldMode();\n    this.$behaviour = new CstyleBehaviour({ braces: true });\n};\noop.inherits(Mode, TextMode);\n\n(function() {\n    this.type = \"text\";\n    \n    this.lineCommentStart = \"%\";\n\n    this.$id = \"ace/mode/latex\";\n    \n    this.getMatching = function(session, row, column) {\n        if (row == undefined)\n            row = session.selection.lead;\n        if (typeof row == \"object\") {\n            column = row.column;\n            row = row.row;\n        }\n\n        var startToken = session.getTokenAt(row, column);\n        if (!startToken)\n            return;\n        if (startToken.value == \"\\\\begin\" || startToken.value == \"\\\\end\") {\n            return this.foldingRules.latexBlock(session, row, column, true);\n        }\n    };\n}).call(Mode.prototype);\n\nexports.Mode = Mode;\n\n});                (function() {\n                    ace.require([\"ace/mode/latex\"], function(m) {\n                        if (typeof module == \"object\" && typeof exports == \"object\" && module) {\n                            module.exports = m;\n                        }\n                    });\n                })();\n            "]},"metadata":{},"sourceType":"script"}