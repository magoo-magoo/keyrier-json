{"ast":null,"code":"import { cloneArr, compact, contains, difference, flatten, forEach, has, isArray, isEmpty, map } from \"../utils/utils\";\nexport function tokenStructuredMatcher(tokInstance, tokConstructor) {\n  var instanceType = tokInstance.tokenTypeIdx;\n\n  if (instanceType === tokConstructor.tokenTypeIdx) {\n    return true;\n  } else {\n    return tokConstructor.isParent === true && tokConstructor.categoryMatchesMap[instanceType] === true;\n  }\n} // Optimized tokenMatcher in case our grammar does not use token categories\n// Being so tiny it is much more likely to be in-lined and this avoid the function call overhead\n\nexport function tokenStructuredMatcherNoCategories(token, tokType) {\n  return token.tokenTypeIdx === tokType.tokenTypeIdx;\n}\nexport var tokenShortNameIdx = 1;\nexport var tokenIdxToClass = {};\nexport function augmentTokenTypes(tokenTypes) {\n  // collect the parent Token Types as well.\n  var tokenTypesAndParents = expandCategories(tokenTypes); // add required tokenType and categoryMatches properties\n\n  assignTokenDefaultProps(tokenTypesAndParents); // fill up the categoryMatches\n\n  assignCategoriesMapProp(tokenTypesAndParents);\n  assignCategoriesTokensProp(tokenTypesAndParents);\n  forEach(tokenTypesAndParents, function (tokType) {\n    tokType.isParent = tokType.categoryMatches.length > 0;\n  });\n}\nexport function expandCategories(tokenTypes) {\n  var result = cloneArr(tokenTypes);\n  var categories = tokenTypes;\n  var searching = true;\n\n  while (searching) {\n    categories = compact(flatten(map(categories, function (currTokType) {\n      return currTokType.CATEGORIES;\n    })));\n    var newCategories = difference(categories, result);\n    result = result.concat(newCategories);\n\n    if (isEmpty(newCategories)) {\n      searching = false;\n    } else {\n      categories = newCategories;\n    }\n  }\n\n  return result;\n}\nexport function assignTokenDefaultProps(tokenTypes) {\n  forEach(tokenTypes, function (currTokType) {\n    if (!hasShortKeyProperty(currTokType)) {\n      tokenIdxToClass[tokenShortNameIdx] = currTokType;\n      currTokType.tokenTypeIdx = tokenShortNameIdx++;\n    } // CATEGORIES? : TokenType | TokenType[]\n\n\n    if (hasCategoriesProperty(currTokType) && !isArray(currTokType.CATEGORIES) // &&\n    // !isUndefined(currTokType.CATEGORIES.PATTERN)\n    ) {\n        currTokType.CATEGORIES = [currTokType.CATEGORIES];\n      }\n\n    if (!hasCategoriesProperty(currTokType)) {\n      currTokType.CATEGORIES = [];\n    }\n\n    if (!hasExtendingTokensTypesProperty(currTokType)) {\n      currTokType.categoryMatches = [];\n    }\n\n    if (!hasExtendingTokensTypesMapProperty(currTokType)) {\n      currTokType.categoryMatchesMap = {};\n    }\n  });\n}\nexport function assignCategoriesTokensProp(tokenTypes) {\n  forEach(tokenTypes, function (currTokType) {\n    // avoid duplications\n    currTokType.categoryMatches = [];\n    forEach(currTokType.categoryMatchesMap, function (val, key) {\n      currTokType.categoryMatches.push(tokenIdxToClass[key].tokenTypeIdx);\n    });\n  });\n}\nexport function assignCategoriesMapProp(tokenTypes) {\n  forEach(tokenTypes, function (currTokType) {\n    singleAssignCategoriesToksMap([], currTokType);\n  });\n}\nexport function singleAssignCategoriesToksMap(path, nextNode) {\n  forEach(path, function (pathNode) {\n    nextNode.categoryMatchesMap[pathNode.tokenTypeIdx] = true;\n  });\n  forEach(nextNode.CATEGORIES, function (nextCategory) {\n    var newPath = path.concat(nextNode); // avoids infinite loops due to cyclic categories.\n\n    if (!contains(newPath, nextCategory)) {\n      singleAssignCategoriesToksMap(newPath, nextCategory);\n    }\n  });\n}\nexport function hasShortKeyProperty(tokType) {\n  return has(tokType, \"tokenTypeIdx\");\n}\nexport function hasCategoriesProperty(tokType) {\n  return has(tokType, \"CATEGORIES\");\n}\nexport function hasExtendingTokensTypesProperty(tokType) {\n  return has(tokType, \"categoryMatches\");\n}\nexport function hasExtendingTokensTypesMapProperty(tokType) {\n  return has(tokType, \"categoryMatchesMap\");\n}\nexport function isTokenType(tokType) {\n  return has(tokType, \"tokenTypeIdx\");\n}","map":{"version":3,"sources":["../../../src/scan/tokens.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["import { cloneArr, compact, contains, difference, flatten, forEach, has, isArray, isEmpty, map } from \"../utils/utils\";\nexport function tokenStructuredMatcher(tokInstance, tokConstructor) {\n    var instanceType = tokInstance.tokenTypeIdx;\n    if (instanceType === tokConstructor.tokenTypeIdx) {\n        return true;\n    }\n    else {\n        return (tokConstructor.isParent === true &&\n            tokConstructor.categoryMatchesMap[instanceType] === true);\n    }\n}\n// Optimized tokenMatcher in case our grammar does not use token categories\n// Being so tiny it is much more likely to be in-lined and this avoid the function call overhead\nexport function tokenStructuredMatcherNoCategories(token, tokType) {\n    return token.tokenTypeIdx === tokType.tokenTypeIdx;\n}\nexport var tokenShortNameIdx = 1;\nexport var tokenIdxToClass = {};\nexport function augmentTokenTypes(tokenTypes) {\n    // collect the parent Token Types as well.\n    var tokenTypesAndParents = expandCategories(tokenTypes);\n    // add required tokenType and categoryMatches properties\n    assignTokenDefaultProps(tokenTypesAndParents);\n    // fill up the categoryMatches\n    assignCategoriesMapProp(tokenTypesAndParents);\n    assignCategoriesTokensProp(tokenTypesAndParents);\n    forEach(tokenTypesAndParents, function (tokType) {\n        tokType.isParent = tokType.categoryMatches.length > 0;\n    });\n}\nexport function expandCategories(tokenTypes) {\n    var result = cloneArr(tokenTypes);\n    var categories = tokenTypes;\n    var searching = true;\n    while (searching) {\n        categories = compact(flatten(map(categories, function (currTokType) { return currTokType.CATEGORIES; })));\n        var newCategories = difference(categories, result);\n        result = result.concat(newCategories);\n        if (isEmpty(newCategories)) {\n            searching = false;\n        }\n        else {\n            categories = newCategories;\n        }\n    }\n    return result;\n}\nexport function assignTokenDefaultProps(tokenTypes) {\n    forEach(tokenTypes, function (currTokType) {\n        if (!hasShortKeyProperty(currTokType)) {\n            tokenIdxToClass[tokenShortNameIdx] = currTokType;\n            currTokType.tokenTypeIdx = tokenShortNameIdx++;\n        }\n        // CATEGORIES? : TokenType | TokenType[]\n        if (hasCategoriesProperty(currTokType) &&\n            !isArray(currTokType.CATEGORIES)\n        // &&\n        // !isUndefined(currTokType.CATEGORIES.PATTERN)\n        ) {\n            currTokType.CATEGORIES = [currTokType.CATEGORIES];\n        }\n        if (!hasCategoriesProperty(currTokType)) {\n            currTokType.CATEGORIES = [];\n        }\n        if (!hasExtendingTokensTypesProperty(currTokType)) {\n            currTokType.categoryMatches = [];\n        }\n        if (!hasExtendingTokensTypesMapProperty(currTokType)) {\n            currTokType.categoryMatchesMap = {};\n        }\n    });\n}\nexport function assignCategoriesTokensProp(tokenTypes) {\n    forEach(tokenTypes, function (currTokType) {\n        // avoid duplications\n        currTokType.categoryMatches = [];\n        forEach(currTokType.categoryMatchesMap, function (val, key) {\n            currTokType.categoryMatches.push(tokenIdxToClass[key].tokenTypeIdx);\n        });\n    });\n}\nexport function assignCategoriesMapProp(tokenTypes) {\n    forEach(tokenTypes, function (currTokType) {\n        singleAssignCategoriesToksMap([], currTokType);\n    });\n}\nexport function singleAssignCategoriesToksMap(path, nextNode) {\n    forEach(path, function (pathNode) {\n        nextNode.categoryMatchesMap[pathNode.tokenTypeIdx] = true;\n    });\n    forEach(nextNode.CATEGORIES, function (nextCategory) {\n        var newPath = path.concat(nextNode);\n        // avoids infinite loops due to cyclic categories.\n        if (!contains(newPath, nextCategory)) {\n            singleAssignCategoriesToksMap(newPath, nextCategory);\n        }\n    });\n}\nexport function hasShortKeyProperty(tokType) {\n    return has(tokType, \"tokenTypeIdx\");\n}\nexport function hasCategoriesProperty(tokType) {\n    return has(tokType, \"CATEGORIES\");\n}\nexport function hasExtendingTokensTypesProperty(tokType) {\n    return has(tokType, \"categoryMatches\");\n}\nexport function hasExtendingTokensTypesMapProperty(tokType) {\n    return has(tokType, \"categoryMatchesMap\");\n}\nexport function isTokenType(tokType) {\n    return has(tokType, \"tokenTypeIdx\");\n}\n//# sourceMappingURL=tokens.js.map"]},"metadata":{},"sourceType":"module"}