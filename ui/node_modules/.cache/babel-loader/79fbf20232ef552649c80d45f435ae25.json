{"ast":null,"code":"import { compact, contains, forEach, isArray, isEmpty, isFunction, isUndefined, keys, map } from \"../../utils/utils\";\nimport { defineNameProp, functionName } from \"../../lang/lang_extensions\";\nimport { validTermsPattern } from \"../grammar/checks\";\nexport function defaultVisit(ctx, param) {\n  var childrenNames = keys(ctx);\n  var childrenNamesLength = childrenNames.length;\n\n  for (var i = 0; i < childrenNamesLength; i++) {\n    var currChildName = childrenNames[i];\n    var currChildArray = ctx[currChildName];\n    var currChildArrayLength = currChildArray.length;\n\n    for (var j = 0; j < currChildArrayLength; j++) {\n      var currChild = currChildArray[j]; // distinction between Tokens Children and CstNode children\n\n      if (currChild.tokenTypeIdx === undefined) {\n        this[currChild.name](currChild.children, param);\n      }\n    }\n  } // defaultVisit does not support generic out param\n\n\n  return undefined;\n}\nexport function createBaseSemanticVisitorConstructor(grammarName, ruleNames) {\n  var derivedConstructor = function () {}; // can be overwritten according to:\n  // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function/\n  // name?redirectlocale=en-US&redirectslug=JavaScript%2FReference%2FGlobal_Objects%2FFunction%2Fname\n\n\n  defineNameProp(derivedConstructor, grammarName + \"BaseSemantics\");\n  var semanticProto = {\n    visit: function (cstNode, param) {\n      // enables writing more concise visitor methods when CstNode has only a single child\n      if (isArray(cstNode)) {\n        // A CST Node's children dictionary can never have empty arrays as values\n        // If a key is defined there will be at least one element in the corresponding value array.\n        cstNode = cstNode[0];\n      } // enables passing optional CstNodes concisely.\n\n\n      if (isUndefined(cstNode)) {\n        return undefined;\n      }\n\n      return this[cstNode.name](cstNode.children, param);\n    },\n    validateVisitor: function () {\n      var semanticDefinitionErrors = validateVisitor(this, ruleNames);\n\n      if (!isEmpty(semanticDefinitionErrors)) {\n        var errorMessages = map(semanticDefinitionErrors, function (currDefError) {\n          return currDefError.msg;\n        });\n        throw Error(\"Errors Detected in CST Visitor <\" + functionName(this.constructor) + \">:\\n\\t\" + (\"\" + errorMessages.join(\"\\n\\n\").replace(/\\n/g, \"\\n\\t\")));\n      }\n    }\n  };\n  derivedConstructor.prototype = semanticProto;\n  derivedConstructor.prototype.constructor = derivedConstructor;\n  derivedConstructor._RULE_NAMES = ruleNames;\n  return derivedConstructor;\n}\nexport function createBaseVisitorConstructorWithDefaults(grammarName, ruleNames, baseConstructor) {\n  var derivedConstructor = function () {}; // can be overwritten according to:\n  // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function/\n  // name?redirectlocale=en-US&redirectslug=JavaScript%2FReference%2FGlobal_Objects%2FFunction%2Fname\n\n\n  defineNameProp(derivedConstructor, grammarName + \"BaseSemanticsWithDefaults\");\n  var withDefaultsProto = Object.create(baseConstructor.prototype);\n  forEach(ruleNames, function (ruleName) {\n    withDefaultsProto[ruleName] = defaultVisit;\n  });\n  derivedConstructor.prototype = withDefaultsProto;\n  derivedConstructor.prototype.constructor = derivedConstructor;\n  return derivedConstructor;\n}\nexport var CstVisitorDefinitionError;\n\n(function (CstVisitorDefinitionError) {\n  CstVisitorDefinitionError[CstVisitorDefinitionError[\"REDUNDANT_METHOD\"] = 0] = \"REDUNDANT_METHOD\";\n  CstVisitorDefinitionError[CstVisitorDefinitionError[\"MISSING_METHOD\"] = 1] = \"MISSING_METHOD\";\n})(CstVisitorDefinitionError || (CstVisitorDefinitionError = {}));\n\nexport function validateVisitor(visitorInstance, ruleNames) {\n  var missingErrors = validateMissingCstMethods(visitorInstance, ruleNames);\n  var redundantErrors = validateRedundantMethods(visitorInstance, ruleNames);\n  return missingErrors.concat(redundantErrors);\n}\nexport function validateMissingCstMethods(visitorInstance, ruleNames) {\n  var errors = map(ruleNames, function (currRuleName) {\n    if (!isFunction(visitorInstance[currRuleName])) {\n      return {\n        msg: \"Missing visitor method: <\" + currRuleName + \"> on \" + functionName(visitorInstance.constructor) + \" CST Visitor.\",\n        type: CstVisitorDefinitionError.MISSING_METHOD,\n        methodName: currRuleName\n      };\n    }\n  });\n  return compact(errors);\n}\nvar VALID_PROP_NAMES = [\"constructor\", \"visit\", \"validateVisitor\"];\nexport function validateRedundantMethods(visitorInstance, ruleNames) {\n  var errors = [];\n\n  for (var prop in visitorInstance) {\n    if (validTermsPattern.test(prop) && isFunction(visitorInstance[prop]) && !contains(VALID_PROP_NAMES, prop) && !contains(ruleNames, prop)) {\n      errors.push({\n        msg: \"Redundant visitor method: <\" + prop + \"> on \" + functionName(visitorInstance.constructor) + \" CST Visitor\\n\" + \"There is no Grammar Rule corresponding to this method's name.\\n\" + (\"For utility methods on visitor classes use methods names that do not match /\" + validTermsPattern.source + \"/.\"),\n        type: CstVisitorDefinitionError.REDUNDANT_METHOD,\n        methodName: prop\n      });\n    }\n  }\n\n  return errors;\n}","map":{"version":3,"sources":["../../../../src/parse/cst/cst_visitor.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["import { compact, contains, forEach, isArray, isEmpty, isFunction, isUndefined, keys, map } from \"../../utils/utils\";\nimport { defineNameProp, functionName } from \"../../lang/lang_extensions\";\nimport { validTermsPattern } from \"../grammar/checks\";\nexport function defaultVisit(ctx, param) {\n    var childrenNames = keys(ctx);\n    var childrenNamesLength = childrenNames.length;\n    for (var i = 0; i < childrenNamesLength; i++) {\n        var currChildName = childrenNames[i];\n        var currChildArray = ctx[currChildName];\n        var currChildArrayLength = currChildArray.length;\n        for (var j = 0; j < currChildArrayLength; j++) {\n            var currChild = currChildArray[j];\n            // distinction between Tokens Children and CstNode children\n            if (currChild.tokenTypeIdx === undefined) {\n                this[currChild.name](currChild.children, param);\n            }\n        }\n    }\n    // defaultVisit does not support generic out param\n    return undefined;\n}\nexport function createBaseSemanticVisitorConstructor(grammarName, ruleNames) {\n    var derivedConstructor = function () { };\n    // can be overwritten according to:\n    // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function/\n    // name?redirectlocale=en-US&redirectslug=JavaScript%2FReference%2FGlobal_Objects%2FFunction%2Fname\n    defineNameProp(derivedConstructor, grammarName + \"BaseSemantics\");\n    var semanticProto = {\n        visit: function (cstNode, param) {\n            // enables writing more concise visitor methods when CstNode has only a single child\n            if (isArray(cstNode)) {\n                // A CST Node's children dictionary can never have empty arrays as values\n                // If a key is defined there will be at least one element in the corresponding value array.\n                cstNode = cstNode[0];\n            }\n            // enables passing optional CstNodes concisely.\n            if (isUndefined(cstNode)) {\n                return undefined;\n            }\n            return this[cstNode.name](cstNode.children, param);\n        },\n        validateVisitor: function () {\n            var semanticDefinitionErrors = validateVisitor(this, ruleNames);\n            if (!isEmpty(semanticDefinitionErrors)) {\n                var errorMessages = map(semanticDefinitionErrors, function (currDefError) { return currDefError.msg; });\n                throw Error(\"Errors Detected in CST Visitor <\" + functionName(this.constructor) + \">:\\n\\t\" + (\"\" + errorMessages.join(\"\\n\\n\").replace(/\\n/g, \"\\n\\t\")));\n            }\n        }\n    };\n    derivedConstructor.prototype = semanticProto;\n    derivedConstructor.prototype.constructor = derivedConstructor;\n    derivedConstructor._RULE_NAMES = ruleNames;\n    return derivedConstructor;\n}\nexport function createBaseVisitorConstructorWithDefaults(grammarName, ruleNames, baseConstructor) {\n    var derivedConstructor = function () { };\n    // can be overwritten according to:\n    // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function/\n    // name?redirectlocale=en-US&redirectslug=JavaScript%2FReference%2FGlobal_Objects%2FFunction%2Fname\n    defineNameProp(derivedConstructor, grammarName + \"BaseSemanticsWithDefaults\");\n    var withDefaultsProto = Object.create(baseConstructor.prototype);\n    forEach(ruleNames, function (ruleName) {\n        withDefaultsProto[ruleName] = defaultVisit;\n    });\n    derivedConstructor.prototype = withDefaultsProto;\n    derivedConstructor.prototype.constructor = derivedConstructor;\n    return derivedConstructor;\n}\nexport var CstVisitorDefinitionError;\n(function (CstVisitorDefinitionError) {\n    CstVisitorDefinitionError[CstVisitorDefinitionError[\"REDUNDANT_METHOD\"] = 0] = \"REDUNDANT_METHOD\";\n    CstVisitorDefinitionError[CstVisitorDefinitionError[\"MISSING_METHOD\"] = 1] = \"MISSING_METHOD\";\n})(CstVisitorDefinitionError || (CstVisitorDefinitionError = {}));\nexport function validateVisitor(visitorInstance, ruleNames) {\n    var missingErrors = validateMissingCstMethods(visitorInstance, ruleNames);\n    var redundantErrors = validateRedundantMethods(visitorInstance, ruleNames);\n    return missingErrors.concat(redundantErrors);\n}\nexport function validateMissingCstMethods(visitorInstance, ruleNames) {\n    var errors = map(ruleNames, function (currRuleName) {\n        if (!isFunction(visitorInstance[currRuleName])) {\n            return {\n                msg: \"Missing visitor method: <\" + currRuleName + \"> on \" + functionName(visitorInstance.constructor) + \" CST Visitor.\",\n                type: CstVisitorDefinitionError.MISSING_METHOD,\n                methodName: currRuleName\n            };\n        }\n    });\n    return compact(errors);\n}\nvar VALID_PROP_NAMES = [\"constructor\", \"visit\", \"validateVisitor\"];\nexport function validateRedundantMethods(visitorInstance, ruleNames) {\n    var errors = [];\n    for (var prop in visitorInstance) {\n        if (validTermsPattern.test(prop) &&\n            isFunction(visitorInstance[prop]) &&\n            !contains(VALID_PROP_NAMES, prop) &&\n            !contains(ruleNames, prop)) {\n            errors.push({\n                msg: \"Redundant visitor method: <\" + prop + \"> on \" + functionName(visitorInstance.constructor) + \" CST Visitor\\n\" +\n                    \"There is no Grammar Rule corresponding to this method's name.\\n\" +\n                    (\"For utility methods on visitor classes use methods names that do not match /\" + validTermsPattern.source + \"/.\"),\n                type: CstVisitorDefinitionError.REDUNDANT_METHOD,\n                methodName: prop\n            });\n        }\n    }\n    return errors;\n}\n//# sourceMappingURL=cst_visitor.js.map"]},"metadata":{},"sourceType":"module"}