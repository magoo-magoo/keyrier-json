{"ast":null,"code":"import { createTokenInstance, EOF } from \"../../../scan/tokens_public\";\nimport { cloneArr, contains, dropRight, find, flatten, has, isEmpty, map } from \"../../../utils/utils\";\nimport { MismatchedTokenException } from \"../../exceptions_public\";\nimport { IN } from \"../../constants\";\nimport { DEFAULT_PARSER_CONFIG } from \"../parser\";\nexport var EOF_FOLLOW_KEY = {};\nexport var IN_RULE_RECOVERY_EXCEPTION = \"InRuleRecoveryException\";\nexport function InRuleRecoveryException(message) {\n  this.name = IN_RULE_RECOVERY_EXCEPTION;\n  this.message = message;\n}\nInRuleRecoveryException.prototype = Error.prototype;\n/**\n * This trait is responsible for the error recovery and fault tolerant logic\n */\n\nvar Recoverable =\n/** @class */\nfunction () {\n  function Recoverable() {}\n\n  Recoverable.prototype.initRecoverable = function (config) {\n    this.firstAfterRepMap = {};\n    this.resyncFollows = {};\n    this.recoveryEnabled = has(config, \"recoveryEnabled\") ? config.recoveryEnabled : DEFAULT_PARSER_CONFIG.recoveryEnabled; // performance optimization, NOOP will be inlined which\n    // effectively means that this optional feature does not exist\n    // when not used.\n\n    if (this.recoveryEnabled) {\n      this.attemptInRepetitionRecovery = attemptInRepetitionRecovery;\n    }\n  };\n\n  Recoverable.prototype.getTokenToInsert = function (tokType) {\n    var tokToInsert = createTokenInstance(tokType, \"\", NaN, NaN, NaN, NaN, NaN, NaN);\n    tokToInsert.isInsertedInRecovery = true;\n    return tokToInsert;\n  };\n\n  Recoverable.prototype.canTokenTypeBeInsertedInRecovery = function (tokType) {\n    return true;\n  };\n\n  Recoverable.prototype.tryInRepetitionRecovery = function (grammarRule, grammarRuleArgs, lookAheadFunc, expectedTokType) {\n    var _this = this; // TODO: can the resyncTokenType be cached?\n\n\n    var reSyncTokType = this.findReSyncTokenType();\n    var savedLexerState = this.exportLexerState();\n    var resyncedTokens = [];\n    var passedResyncPoint = false;\n    var nextTokenWithoutResync = this.LA(1);\n    var currToken = this.LA(1);\n\n    var generateErrorMessage = function () {\n      var previousToken = _this.LA(0); // we are preemptively re-syncing before an error has been detected, therefor we must reproduce\n      // the error that would have been thrown\n\n\n      var msg = _this.errorMessageProvider.buildMismatchTokenMessage({\n        expected: expectedTokType,\n        actual: nextTokenWithoutResync,\n        previous: previousToken,\n        ruleName: _this.getCurrRuleFullName()\n      });\n\n      var error = new MismatchedTokenException(msg, nextTokenWithoutResync, _this.LA(0)); // the first token here will be the original cause of the error, this is not part of the resyncedTokens property.\n\n      error.resyncedTokens = dropRight(resyncedTokens);\n\n      _this.SAVE_ERROR(error);\n    };\n\n    while (!passedResyncPoint) {\n      // re-synced to a point where we can safely exit the repetition/\n      if (this.tokenMatcher(currToken, expectedTokType)) {\n        generateErrorMessage();\n        return; // must return here to avoid reverting the inputIdx\n      } else if (lookAheadFunc.call(this)) {\n        // we skipped enough tokens so we can resync right back into another iteration of the repetition grammar rule\n        generateErrorMessage(); // recursive invocation in other to support multiple re-syncs in the same top level repetition grammar rule\n\n        grammarRule.apply(this, grammarRuleArgs);\n        return; // must return here to avoid reverting the inputIdx\n      } else if (this.tokenMatcher(currToken, reSyncTokType)) {\n        passedResyncPoint = true;\n      } else {\n        currToken = this.SKIP_TOKEN();\n        this.addToResyncTokens(currToken, resyncedTokens);\n      }\n    } // we were unable to find a CLOSER point to resync inside the Repetition, reset the state.\n    // The parsing exception we were trying to prevent will happen in the NEXT parsing step. it may be handled by\n    // \"between rules\" resync recovery later in the flow.\n\n\n    this.importLexerState(savedLexerState);\n  };\n\n  Recoverable.prototype.shouldInRepetitionRecoveryBeTried = function (expectTokAfterLastMatch, nextTokIdx, notStuck) {\n    // Edge case of arriving from a MANY repetition which is stuck\n    // Attempting recovery in this case could cause an infinite loop\n    if (notStuck === false) {\n      return false;\n    } // arguments to try and perform resync into the next iteration of the many are missing\n\n\n    if (expectTokAfterLastMatch === undefined || nextTokIdx === undefined) {\n      return false;\n    } // no need to recover, next token is what we expect...\n\n\n    if (this.tokenMatcher(this.LA(1), expectTokAfterLastMatch)) {\n      return false;\n    } // error recovery is disabled during backtracking as it can make the parser ignore a valid grammar path\n    // and prefer some backtracking path that includes recovered errors.\n\n\n    if (this.isBackTracking()) {\n      return false;\n    } // if we can perform inRule recovery (single token insertion or deletion) we always prefer that recovery algorithm\n    // because if it works, it makes the least amount of changes to the input stream (greedy algorithm)\n    //noinspection RedundantIfStatementJS\n\n\n    if (this.canPerformInRuleRecovery(expectTokAfterLastMatch, this.getFollowsForInRuleRecovery(expectTokAfterLastMatch, nextTokIdx))) {\n      return false;\n    }\n\n    return true;\n  }; // Error Recovery functionality\n\n\n  Recoverable.prototype.getFollowsForInRuleRecovery = function (tokType, tokIdxInRule) {\n    var grammarPath = this.getCurrentGrammarPath(tokType, tokIdxInRule);\n    var follows = this.getNextPossibleTokenTypes(grammarPath);\n    return follows;\n  };\n\n  Recoverable.prototype.tryInRuleRecovery = function (expectedTokType, follows) {\n    if (this.canRecoverWithSingleTokenInsertion(expectedTokType, follows)) {\n      var tokToInsert = this.getTokenToInsert(expectedTokType);\n      return tokToInsert;\n    }\n\n    if (this.canRecoverWithSingleTokenDeletion(expectedTokType)) {\n      var nextTok = this.SKIP_TOKEN();\n      this.consumeToken();\n      return nextTok;\n    }\n\n    throw new InRuleRecoveryException(\"sad sad panda\");\n  };\n\n  Recoverable.prototype.canPerformInRuleRecovery = function (expectedToken, follows) {\n    return this.canRecoverWithSingleTokenInsertion(expectedToken, follows) || this.canRecoverWithSingleTokenDeletion(expectedToken);\n  };\n\n  Recoverable.prototype.canRecoverWithSingleTokenInsertion = function (expectedTokType, follows) {\n    var _this = this;\n\n    if (!this.canTokenTypeBeInsertedInRecovery(expectedTokType)) {\n      return false;\n    } // must know the possible following tokens to perform single token insertion\n\n\n    if (isEmpty(follows)) {\n      return false;\n    }\n\n    var mismatchedTok = this.LA(1);\n    var isMisMatchedTokInFollows = find(follows, function (possibleFollowsTokType) {\n      return _this.tokenMatcher(mismatchedTok, possibleFollowsTokType);\n    }) !== undefined;\n    return isMisMatchedTokInFollows;\n  };\n\n  Recoverable.prototype.canRecoverWithSingleTokenDeletion = function (expectedTokType) {\n    var isNextTokenWhatIsExpected = this.tokenMatcher(this.LA(2), expectedTokType);\n    return isNextTokenWhatIsExpected;\n  };\n\n  Recoverable.prototype.isInCurrentRuleReSyncSet = function (tokenTypeIdx) {\n    var followKey = this.getCurrFollowKey();\n    var currentRuleReSyncSet = this.getFollowSetFromFollowKey(followKey);\n    return contains(currentRuleReSyncSet, tokenTypeIdx);\n  };\n\n  Recoverable.prototype.findReSyncTokenType = function () {\n    var allPossibleReSyncTokTypes = this.flattenFollowSet(); // this loop will always terminate as EOF is always in the follow stack and also always (virtually) in the input\n\n    var nextToken = this.LA(1);\n    var k = 2;\n\n    while (true) {\n      var nextTokenType = nextToken.tokenType;\n\n      if (contains(allPossibleReSyncTokTypes, nextTokenType)) {\n        return nextTokenType;\n      }\n\n      nextToken = this.LA(k);\n      k++;\n    }\n  };\n\n  Recoverable.prototype.getCurrFollowKey = function () {\n    // the length is at least one as we always add the ruleName to the stack before invoking the rule.\n    if (this.RULE_STACK.length === 1) {\n      return EOF_FOLLOW_KEY;\n    }\n\n    var currRuleShortName = this.getLastExplicitRuleShortName();\n    var currRuleIdx = this.getLastExplicitRuleOccurrenceIndex();\n    var prevRuleShortName = this.getPreviousExplicitRuleShortName();\n    return {\n      ruleName: this.shortRuleNameToFullName(currRuleShortName),\n      idxInCallingRule: currRuleIdx,\n      inRule: this.shortRuleNameToFullName(prevRuleShortName)\n    };\n  };\n\n  Recoverable.prototype.buildFullFollowKeyStack = function () {\n    var _this = this;\n\n    var explicitRuleStack = this.RULE_STACK;\n    var explicitOccurrenceStack = this.RULE_OCCURRENCE_STACK;\n    return map(explicitRuleStack, function (ruleName, idx) {\n      if (idx === 0) {\n        return EOF_FOLLOW_KEY;\n      }\n\n      return {\n        ruleName: _this.shortRuleNameToFullName(ruleName),\n        idxInCallingRule: explicitOccurrenceStack[idx],\n        inRule: _this.shortRuleNameToFullName(explicitRuleStack[idx - 1])\n      };\n    });\n  };\n\n  Recoverable.prototype.flattenFollowSet = function () {\n    var _this = this;\n\n    var followStack = map(this.buildFullFollowKeyStack(), function (currKey) {\n      return _this.getFollowSetFromFollowKey(currKey);\n    });\n    return flatten(followStack);\n  };\n\n  Recoverable.prototype.getFollowSetFromFollowKey = function (followKey) {\n    if (followKey === EOF_FOLLOW_KEY) {\n      return [EOF];\n    }\n\n    var followName = followKey.ruleName + followKey.idxInCallingRule + IN + followKey.inRule;\n    return this.resyncFollows[followName];\n  }; // It does not make any sense to include a virtual EOF token in the list of resynced tokens\n  // as EOF does not really exist and thus does not contain any useful information (line/column numbers)\n\n\n  Recoverable.prototype.addToResyncTokens = function (token, resyncTokens) {\n    if (!this.tokenMatcher(token, EOF)) {\n      resyncTokens.push(token);\n    }\n\n    return resyncTokens;\n  };\n\n  Recoverable.prototype.reSyncTo = function (tokType) {\n    var resyncedTokens = [];\n    var nextTok = this.LA(1);\n\n    while (this.tokenMatcher(nextTok, tokType) === false) {\n      nextTok = this.SKIP_TOKEN();\n      this.addToResyncTokens(nextTok, resyncedTokens);\n    } // the last token is not part of the error.\n\n\n    return dropRight(resyncedTokens);\n  };\n\n  Recoverable.prototype.attemptInRepetitionRecovery = function (prodFunc, args, lookaheadFunc, dslMethodIdx, prodOccurrence, nextToksWalker, notStuck) {// by default this is a NO-OP\n    // The actual implementation is with the function(not method) below\n  };\n\n  Recoverable.prototype.getCurrentGrammarPath = function (tokType, tokIdxInRule) {\n    var pathRuleStack = this.getHumanReadableRuleStack();\n    var pathOccurrenceStack = cloneArr(this.RULE_OCCURRENCE_STACK);\n    var grammarPath = {\n      ruleStack: pathRuleStack,\n      occurrenceStack: pathOccurrenceStack,\n      lastTok: tokType,\n      lastTokOccurrence: tokIdxInRule\n    };\n    return grammarPath;\n  };\n\n  Recoverable.prototype.getHumanReadableRuleStack = function () {\n    var _this = this;\n\n    return map(this.RULE_STACK, function (currShortName) {\n      return _this.shortRuleNameToFullName(currShortName);\n    });\n  };\n\n  return Recoverable;\n}();\n\nexport { Recoverable };\nexport function attemptInRepetitionRecovery(prodFunc, args, lookaheadFunc, dslMethodIdx, prodOccurrence, nextToksWalker, notStuck) {\n  var key = this.getKeyForAutomaticLookahead(dslMethodIdx, prodOccurrence);\n  var firstAfterRepInfo = this.firstAfterRepMap[key];\n\n  if (firstAfterRepInfo === undefined) {\n    var currRuleName = this.getCurrRuleFullName();\n    var ruleGrammar = this.getGAstProductions()[currRuleName];\n    var walker = new nextToksWalker(ruleGrammar, prodOccurrence);\n    firstAfterRepInfo = walker.startWalking();\n    this.firstAfterRepMap[key] = firstAfterRepInfo;\n  }\n\n  var expectTokAfterLastMatch = firstAfterRepInfo.token;\n  var nextTokIdx = firstAfterRepInfo.occurrence;\n  var isEndOfRule = firstAfterRepInfo.isEndOfRule; // special edge case of a TOP most repetition after which the input should END.\n  // this will force an attempt for inRule recovery in that scenario.\n\n  if (this.RULE_STACK.length === 1 && isEndOfRule && expectTokAfterLastMatch === undefined) {\n    expectTokAfterLastMatch = EOF;\n    nextTokIdx = 1;\n  }\n\n  if (this.shouldInRepetitionRecoveryBeTried(expectTokAfterLastMatch, nextTokIdx, notStuck)) {\n    // TODO: performance optimization: instead of passing the original args here, we modify\n    // the args param (or create a new one) and make sure the lookahead func is explicitly provided\n    // to avoid searching the cache for it once more.\n    this.tryInRepetitionRecovery(prodFunc, args, lookaheadFunc, expectTokAfterLastMatch);\n  }\n}","map":{"version":3,"sources":["../../../../../src/parse/parser/traits/recoverable.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["import { createTokenInstance, EOF } from \"../../../scan/tokens_public\";\nimport { cloneArr, contains, dropRight, find, flatten, has, isEmpty, map } from \"../../../utils/utils\";\nimport { MismatchedTokenException } from \"../../exceptions_public\";\nimport { IN } from \"../../constants\";\nimport { DEFAULT_PARSER_CONFIG } from \"../parser\";\nexport var EOF_FOLLOW_KEY = {};\nexport var IN_RULE_RECOVERY_EXCEPTION = \"InRuleRecoveryException\";\nexport function InRuleRecoveryException(message) {\n    this.name = IN_RULE_RECOVERY_EXCEPTION;\n    this.message = message;\n}\nInRuleRecoveryException.prototype = Error.prototype;\n/**\n * This trait is responsible for the error recovery and fault tolerant logic\n */\nvar Recoverable = /** @class */ (function () {\n    function Recoverable() {\n    }\n    Recoverable.prototype.initRecoverable = function (config) {\n        this.firstAfterRepMap = {};\n        this.resyncFollows = {};\n        this.recoveryEnabled = has(config, \"recoveryEnabled\")\n            ? config.recoveryEnabled\n            : DEFAULT_PARSER_CONFIG.recoveryEnabled;\n        // performance optimization, NOOP will be inlined which\n        // effectively means that this optional feature does not exist\n        // when not used.\n        if (this.recoveryEnabled) {\n            this.attemptInRepetitionRecovery = attemptInRepetitionRecovery;\n        }\n    };\n    Recoverable.prototype.getTokenToInsert = function (tokType) {\n        var tokToInsert = createTokenInstance(tokType, \"\", NaN, NaN, NaN, NaN, NaN, NaN);\n        tokToInsert.isInsertedInRecovery = true;\n        return tokToInsert;\n    };\n    Recoverable.prototype.canTokenTypeBeInsertedInRecovery = function (tokType) {\n        return true;\n    };\n    Recoverable.prototype.tryInRepetitionRecovery = function (grammarRule, grammarRuleArgs, lookAheadFunc, expectedTokType) {\n        var _this = this;\n        // TODO: can the resyncTokenType be cached?\n        var reSyncTokType = this.findReSyncTokenType();\n        var savedLexerState = this.exportLexerState();\n        var resyncedTokens = [];\n        var passedResyncPoint = false;\n        var nextTokenWithoutResync = this.LA(1);\n        var currToken = this.LA(1);\n        var generateErrorMessage = function () {\n            var previousToken = _this.LA(0);\n            // we are preemptively re-syncing before an error has been detected, therefor we must reproduce\n            // the error that would have been thrown\n            var msg = _this.errorMessageProvider.buildMismatchTokenMessage({\n                expected: expectedTokType,\n                actual: nextTokenWithoutResync,\n                previous: previousToken,\n                ruleName: _this.getCurrRuleFullName()\n            });\n            var error = new MismatchedTokenException(msg, nextTokenWithoutResync, _this.LA(0));\n            // the first token here will be the original cause of the error, this is not part of the resyncedTokens property.\n            error.resyncedTokens = dropRight(resyncedTokens);\n            _this.SAVE_ERROR(error);\n        };\n        while (!passedResyncPoint) {\n            // re-synced to a point where we can safely exit the repetition/\n            if (this.tokenMatcher(currToken, expectedTokType)) {\n                generateErrorMessage();\n                return; // must return here to avoid reverting the inputIdx\n            }\n            else if (lookAheadFunc.call(this)) {\n                // we skipped enough tokens so we can resync right back into another iteration of the repetition grammar rule\n                generateErrorMessage();\n                // recursive invocation in other to support multiple re-syncs in the same top level repetition grammar rule\n                grammarRule.apply(this, grammarRuleArgs);\n                return; // must return here to avoid reverting the inputIdx\n            }\n            else if (this.tokenMatcher(currToken, reSyncTokType)) {\n                passedResyncPoint = true;\n            }\n            else {\n                currToken = this.SKIP_TOKEN();\n                this.addToResyncTokens(currToken, resyncedTokens);\n            }\n        }\n        // we were unable to find a CLOSER point to resync inside the Repetition, reset the state.\n        // The parsing exception we were trying to prevent will happen in the NEXT parsing step. it may be handled by\n        // \"between rules\" resync recovery later in the flow.\n        this.importLexerState(savedLexerState);\n    };\n    Recoverable.prototype.shouldInRepetitionRecoveryBeTried = function (expectTokAfterLastMatch, nextTokIdx, notStuck) {\n        // Edge case of arriving from a MANY repetition which is stuck\n        // Attempting recovery in this case could cause an infinite loop\n        if (notStuck === false) {\n            return false;\n        }\n        // arguments to try and perform resync into the next iteration of the many are missing\n        if (expectTokAfterLastMatch === undefined || nextTokIdx === undefined) {\n            return false;\n        }\n        // no need to recover, next token is what we expect...\n        if (this.tokenMatcher(this.LA(1), expectTokAfterLastMatch)) {\n            return false;\n        }\n        // error recovery is disabled during backtracking as it can make the parser ignore a valid grammar path\n        // and prefer some backtracking path that includes recovered errors.\n        if (this.isBackTracking()) {\n            return false;\n        }\n        // if we can perform inRule recovery (single token insertion or deletion) we always prefer that recovery algorithm\n        // because if it works, it makes the least amount of changes to the input stream (greedy algorithm)\n        //noinspection RedundantIfStatementJS\n        if (this.canPerformInRuleRecovery(expectTokAfterLastMatch, this.getFollowsForInRuleRecovery(expectTokAfterLastMatch, nextTokIdx))) {\n            return false;\n        }\n        return true;\n    };\n    // Error Recovery functionality\n    Recoverable.prototype.getFollowsForInRuleRecovery = function (tokType, tokIdxInRule) {\n        var grammarPath = this.getCurrentGrammarPath(tokType, tokIdxInRule);\n        var follows = this.getNextPossibleTokenTypes(grammarPath);\n        return follows;\n    };\n    Recoverable.prototype.tryInRuleRecovery = function (expectedTokType, follows) {\n        if (this.canRecoverWithSingleTokenInsertion(expectedTokType, follows)) {\n            var tokToInsert = this.getTokenToInsert(expectedTokType);\n            return tokToInsert;\n        }\n        if (this.canRecoverWithSingleTokenDeletion(expectedTokType)) {\n            var nextTok = this.SKIP_TOKEN();\n            this.consumeToken();\n            return nextTok;\n        }\n        throw new InRuleRecoveryException(\"sad sad panda\");\n    };\n    Recoverable.prototype.canPerformInRuleRecovery = function (expectedToken, follows) {\n        return (this.canRecoverWithSingleTokenInsertion(expectedToken, follows) ||\n            this.canRecoverWithSingleTokenDeletion(expectedToken));\n    };\n    Recoverable.prototype.canRecoverWithSingleTokenInsertion = function (expectedTokType, follows) {\n        var _this = this;\n        if (!this.canTokenTypeBeInsertedInRecovery(expectedTokType)) {\n            return false;\n        }\n        // must know the possible following tokens to perform single token insertion\n        if (isEmpty(follows)) {\n            return false;\n        }\n        var mismatchedTok = this.LA(1);\n        var isMisMatchedTokInFollows = find(follows, function (possibleFollowsTokType) {\n            return _this.tokenMatcher(mismatchedTok, possibleFollowsTokType);\n        }) !== undefined;\n        return isMisMatchedTokInFollows;\n    };\n    Recoverable.prototype.canRecoverWithSingleTokenDeletion = function (expectedTokType) {\n        var isNextTokenWhatIsExpected = this.tokenMatcher(this.LA(2), expectedTokType);\n        return isNextTokenWhatIsExpected;\n    };\n    Recoverable.prototype.isInCurrentRuleReSyncSet = function (tokenTypeIdx) {\n        var followKey = this.getCurrFollowKey();\n        var currentRuleReSyncSet = this.getFollowSetFromFollowKey(followKey);\n        return contains(currentRuleReSyncSet, tokenTypeIdx);\n    };\n    Recoverable.prototype.findReSyncTokenType = function () {\n        var allPossibleReSyncTokTypes = this.flattenFollowSet();\n        // this loop will always terminate as EOF is always in the follow stack and also always (virtually) in the input\n        var nextToken = this.LA(1);\n        var k = 2;\n        while (true) {\n            var nextTokenType = nextToken.tokenType;\n            if (contains(allPossibleReSyncTokTypes, nextTokenType)) {\n                return nextTokenType;\n            }\n            nextToken = this.LA(k);\n            k++;\n        }\n    };\n    Recoverable.prototype.getCurrFollowKey = function () {\n        // the length is at least one as we always add the ruleName to the stack before invoking the rule.\n        if (this.RULE_STACK.length === 1) {\n            return EOF_FOLLOW_KEY;\n        }\n        var currRuleShortName = this.getLastExplicitRuleShortName();\n        var currRuleIdx = this.getLastExplicitRuleOccurrenceIndex();\n        var prevRuleShortName = this.getPreviousExplicitRuleShortName();\n        return {\n            ruleName: this.shortRuleNameToFullName(currRuleShortName),\n            idxInCallingRule: currRuleIdx,\n            inRule: this.shortRuleNameToFullName(prevRuleShortName)\n        };\n    };\n    Recoverable.prototype.buildFullFollowKeyStack = function () {\n        var _this = this;\n        var explicitRuleStack = this.RULE_STACK;\n        var explicitOccurrenceStack = this.RULE_OCCURRENCE_STACK;\n        return map(explicitRuleStack, function (ruleName, idx) {\n            if (idx === 0) {\n                return EOF_FOLLOW_KEY;\n            }\n            return {\n                ruleName: _this.shortRuleNameToFullName(ruleName),\n                idxInCallingRule: explicitOccurrenceStack[idx],\n                inRule: _this.shortRuleNameToFullName(explicitRuleStack[idx - 1])\n            };\n        });\n    };\n    Recoverable.prototype.flattenFollowSet = function () {\n        var _this = this;\n        var followStack = map(this.buildFullFollowKeyStack(), function (currKey) {\n            return _this.getFollowSetFromFollowKey(currKey);\n        });\n        return flatten(followStack);\n    };\n    Recoverable.prototype.getFollowSetFromFollowKey = function (followKey) {\n        if (followKey === EOF_FOLLOW_KEY) {\n            return [EOF];\n        }\n        var followName = followKey.ruleName + followKey.idxInCallingRule + IN + followKey.inRule;\n        return this.resyncFollows[followName];\n    };\n    // It does not make any sense to include a virtual EOF token in the list of resynced tokens\n    // as EOF does not really exist and thus does not contain any useful information (line/column numbers)\n    Recoverable.prototype.addToResyncTokens = function (token, resyncTokens) {\n        if (!this.tokenMatcher(token, EOF)) {\n            resyncTokens.push(token);\n        }\n        return resyncTokens;\n    };\n    Recoverable.prototype.reSyncTo = function (tokType) {\n        var resyncedTokens = [];\n        var nextTok = this.LA(1);\n        while (this.tokenMatcher(nextTok, tokType) === false) {\n            nextTok = this.SKIP_TOKEN();\n            this.addToResyncTokens(nextTok, resyncedTokens);\n        }\n        // the last token is not part of the error.\n        return dropRight(resyncedTokens);\n    };\n    Recoverable.prototype.attemptInRepetitionRecovery = function (prodFunc, args, lookaheadFunc, dslMethodIdx, prodOccurrence, nextToksWalker, notStuck) {\n        // by default this is a NO-OP\n        // The actual implementation is with the function(not method) below\n    };\n    Recoverable.prototype.getCurrentGrammarPath = function (tokType, tokIdxInRule) {\n        var pathRuleStack = this.getHumanReadableRuleStack();\n        var pathOccurrenceStack = cloneArr(this.RULE_OCCURRENCE_STACK);\n        var grammarPath = {\n            ruleStack: pathRuleStack,\n            occurrenceStack: pathOccurrenceStack,\n            lastTok: tokType,\n            lastTokOccurrence: tokIdxInRule\n        };\n        return grammarPath;\n    };\n    Recoverable.prototype.getHumanReadableRuleStack = function () {\n        var _this = this;\n        return map(this.RULE_STACK, function (currShortName) {\n            return _this.shortRuleNameToFullName(currShortName);\n        });\n    };\n    return Recoverable;\n}());\nexport { Recoverable };\nexport function attemptInRepetitionRecovery(prodFunc, args, lookaheadFunc, dslMethodIdx, prodOccurrence, nextToksWalker, notStuck) {\n    var key = this.getKeyForAutomaticLookahead(dslMethodIdx, prodOccurrence);\n    var firstAfterRepInfo = this.firstAfterRepMap[key];\n    if (firstAfterRepInfo === undefined) {\n        var currRuleName = this.getCurrRuleFullName();\n        var ruleGrammar = this.getGAstProductions()[currRuleName];\n        var walker = new nextToksWalker(ruleGrammar, prodOccurrence);\n        firstAfterRepInfo = walker.startWalking();\n        this.firstAfterRepMap[key] = firstAfterRepInfo;\n    }\n    var expectTokAfterLastMatch = firstAfterRepInfo.token;\n    var nextTokIdx = firstAfterRepInfo.occurrence;\n    var isEndOfRule = firstAfterRepInfo.isEndOfRule;\n    // special edge case of a TOP most repetition after which the input should END.\n    // this will force an attempt for inRule recovery in that scenario.\n    if (this.RULE_STACK.length === 1 &&\n        isEndOfRule &&\n        expectTokAfterLastMatch === undefined) {\n        expectTokAfterLastMatch = EOF;\n        nextTokIdx = 1;\n    }\n    if (this.shouldInRepetitionRecoveryBeTried(expectTokAfterLastMatch, nextTokIdx, notStuck)) {\n        // TODO: performance optimization: instead of passing the original args here, we modify\n        // the args param (or create a new one) and make sure the lookahead func is explicitly provided\n        // to avoid searching the cache for it once more.\n        this.tryInRepetitionRecovery(prodFunc, args, lookaheadFunc, expectTokAfterLastMatch);\n    }\n}\n//# sourceMappingURL=recoverable.js.map"]},"metadata":{},"sourceType":"module"}