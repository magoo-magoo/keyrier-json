{"ast":null,"code":"import { EarlyExitException, isRecognitionException, NoViableAltException } from \"../../exceptions_public\";\nimport { cloneArr, has } from \"../../../utils/utils\";\nimport { getLookaheadPathsForOptionalProd, getLookaheadPathsForOr } from \"../../grammar/lookahead\";\nimport { DEFAULT_PARSER_CONFIG } from \"../parser\";\n/**\n * Trait responsible for runtime parsing errors.\n */\n\nvar ErrorHandler =\n/** @class */\nfunction () {\n  function ErrorHandler() {}\n\n  ErrorHandler.prototype.initErrorHandler = function (config) {\n    this._errors = [];\n    this.errorMessageProvider = has(config, \"errorMessageProvider\") ? config.errorMessageProvider : DEFAULT_PARSER_CONFIG.errorMessageProvider;\n  };\n\n  ErrorHandler.prototype.SAVE_ERROR = function (error) {\n    if (isRecognitionException(error)) {\n      error.context = {\n        ruleStack: this.getHumanReadableRuleStack(),\n        ruleOccurrenceStack: cloneArr(this.RULE_OCCURRENCE_STACK)\n      };\n\n      this._errors.push(error);\n\n      return error;\n    } else {\n      throw Error(\"Trying to save an Error which is not a RecognitionException\");\n    }\n  };\n\n  Object.defineProperty(ErrorHandler.prototype, \"errors\", {\n    get: function () {\n      return cloneArr(this._errors);\n    },\n    set: function (newErrors) {\n      this._errors = newErrors;\n    },\n    enumerable: true,\n    configurable: true\n  }); // TODO: consider caching the error message computed information\n\n  ErrorHandler.prototype.raiseEarlyExitException = function (occurrence, prodType, userDefinedErrMsg) {\n    var ruleName = this.getCurrRuleFullName();\n    var ruleGrammar = this.getGAstProductions()[ruleName];\n    var lookAheadPathsPerAlternative = getLookaheadPathsForOptionalProd(occurrence, ruleGrammar, prodType, this.maxLookahead);\n    var insideProdPaths = lookAheadPathsPerAlternative[0];\n    var actualTokens = [];\n\n    for (var i = 1; i <= this.maxLookahead; i++) {\n      actualTokens.push(this.LA(i));\n    }\n\n    var msg = this.errorMessageProvider.buildEarlyExitMessage({\n      expectedIterationPaths: insideProdPaths,\n      actual: actualTokens,\n      previous: this.LA(0),\n      customUserDescription: userDefinedErrMsg,\n      ruleName: ruleName\n    });\n    throw this.SAVE_ERROR(new EarlyExitException(msg, this.LA(1), this.LA(0)));\n  }; // TODO: consider caching the error message computed information\n\n\n  ErrorHandler.prototype.raiseNoAltException = function (occurrence, errMsgTypes) {\n    var ruleName = this.getCurrRuleFullName();\n    var ruleGrammar = this.getGAstProductions()[ruleName]; // TODO: getLookaheadPathsForOr can be slow for large enough maxLookahead and certain grammars, consider caching ?\n\n    var lookAheadPathsPerAlternative = getLookaheadPathsForOr(occurrence, ruleGrammar, this.maxLookahead);\n    var actualTokens = [];\n\n    for (var i = 1; i <= this.maxLookahead; i++) {\n      actualTokens.push(this.LA(i));\n    }\n\n    var previousToken = this.LA(0);\n    var errMsg = this.errorMessageProvider.buildNoViableAltMessage({\n      expectedPathsPerAlt: lookAheadPathsPerAlternative,\n      actual: actualTokens,\n      previous: previousToken,\n      customUserDescription: errMsgTypes,\n      ruleName: this.getCurrRuleFullName()\n    });\n    throw this.SAVE_ERROR(new NoViableAltException(errMsg, this.LA(1), previousToken));\n  };\n\n  return ErrorHandler;\n}();\n\nexport { ErrorHandler };","map":{"version":3,"sources":["../../../../../src/parse/parser/traits/error_handler.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["import { EarlyExitException, isRecognitionException, NoViableAltException } from \"../../exceptions_public\";\nimport { cloneArr, has } from \"../../../utils/utils\";\nimport { getLookaheadPathsForOptionalProd, getLookaheadPathsForOr } from \"../../grammar/lookahead\";\nimport { DEFAULT_PARSER_CONFIG } from \"../parser\";\n/**\n * Trait responsible for runtime parsing errors.\n */\nvar ErrorHandler = /** @class */ (function () {\n    function ErrorHandler() {\n    }\n    ErrorHandler.prototype.initErrorHandler = function (config) {\n        this._errors = [];\n        this.errorMessageProvider = has(config, \"errorMessageProvider\")\n            ? config.errorMessageProvider\n            : DEFAULT_PARSER_CONFIG.errorMessageProvider;\n    };\n    ErrorHandler.prototype.SAVE_ERROR = function (error) {\n        if (isRecognitionException(error)) {\n            error.context = {\n                ruleStack: this.getHumanReadableRuleStack(),\n                ruleOccurrenceStack: cloneArr(this.RULE_OCCURRENCE_STACK)\n            };\n            this._errors.push(error);\n            return error;\n        }\n        else {\n            throw Error(\"Trying to save an Error which is not a RecognitionException\");\n        }\n    };\n    Object.defineProperty(ErrorHandler.prototype, \"errors\", {\n        get: function () {\n            return cloneArr(this._errors);\n        },\n        set: function (newErrors) {\n            this._errors = newErrors;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    // TODO: consider caching the error message computed information\n    ErrorHandler.prototype.raiseEarlyExitException = function (occurrence, prodType, userDefinedErrMsg) {\n        var ruleName = this.getCurrRuleFullName();\n        var ruleGrammar = this.getGAstProductions()[ruleName];\n        var lookAheadPathsPerAlternative = getLookaheadPathsForOptionalProd(occurrence, ruleGrammar, prodType, this.maxLookahead);\n        var insideProdPaths = lookAheadPathsPerAlternative[0];\n        var actualTokens = [];\n        for (var i = 1; i <= this.maxLookahead; i++) {\n            actualTokens.push(this.LA(i));\n        }\n        var msg = this.errorMessageProvider.buildEarlyExitMessage({\n            expectedIterationPaths: insideProdPaths,\n            actual: actualTokens,\n            previous: this.LA(0),\n            customUserDescription: userDefinedErrMsg,\n            ruleName: ruleName\n        });\n        throw this.SAVE_ERROR(new EarlyExitException(msg, this.LA(1), this.LA(0)));\n    };\n    // TODO: consider caching the error message computed information\n    ErrorHandler.prototype.raiseNoAltException = function (occurrence, errMsgTypes) {\n        var ruleName = this.getCurrRuleFullName();\n        var ruleGrammar = this.getGAstProductions()[ruleName];\n        // TODO: getLookaheadPathsForOr can be slow for large enough maxLookahead and certain grammars, consider caching ?\n        var lookAheadPathsPerAlternative = getLookaheadPathsForOr(occurrence, ruleGrammar, this.maxLookahead);\n        var actualTokens = [];\n        for (var i = 1; i <= this.maxLookahead; i++) {\n            actualTokens.push(this.LA(i));\n        }\n        var previousToken = this.LA(0);\n        var errMsg = this.errorMessageProvider.buildNoViableAltMessage({\n            expectedPathsPerAlt: lookAheadPathsPerAlternative,\n            actual: actualTokens,\n            previous: previousToken,\n            customUserDescription: errMsgTypes,\n            ruleName: this.getCurrRuleFullName()\n        });\n        throw this.SAVE_ERROR(new NoViableAltException(errMsg, this.LA(1), previousToken));\n    };\n    return ErrorHandler;\n}());\nexport { ErrorHandler };\n//# sourceMappingURL=error_handler.js.map"]},"metadata":{},"sourceType":"module"}