{"ast":null,"code":"\"use strict\";\n\nfunction _typeof(obj) {\n  if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") {\n    _typeof = function _typeof(obj) {\n      return typeof obj;\n    };\n  } else {\n    _typeof = function _typeof(obj) {\n      return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj;\n    };\n  }\n\n  return _typeof(obj);\n}\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports[\"default\"] = undoable;\n\nvar debug = _interopRequireWildcard(require(\"./debug\"));\n\nvar _actions = require(\"./actions\");\n\nvar _helpers = require(\"./helpers\");\n\nfunction _getRequireWildcardCache() {\n  if (typeof WeakMap !== \"function\") return null;\n  var cache = new WeakMap();\n\n  _getRequireWildcardCache = function _getRequireWildcardCache() {\n    return cache;\n  };\n\n  return cache;\n}\n\nfunction _interopRequireWildcard(obj) {\n  if (obj && obj.__esModule) {\n    return obj;\n  }\n\n  if (obj === null || _typeof(obj) !== \"object\" && typeof obj !== \"function\") {\n    return {\n      \"default\": obj\n    };\n  }\n\n  var cache = _getRequireWildcardCache();\n\n  if (cache && cache.has(obj)) {\n    return cache.get(obj);\n  }\n\n  var newObj = {};\n  var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;\n\n  for (var key in obj) {\n    if (Object.prototype.hasOwnProperty.call(obj, key)) {\n      var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;\n\n      if (desc && (desc.get || desc.set)) {\n        Object.defineProperty(newObj, key, desc);\n      } else {\n        newObj[key] = obj[key];\n      }\n    }\n  }\n\n  newObj[\"default\"] = obj;\n\n  if (cache) {\n    cache.set(obj, newObj);\n  }\n\n  return newObj;\n}\n\nfunction ownKeys(object, enumerableOnly) {\n  var keys = Object.keys(object);\n\n  if (Object.getOwnPropertySymbols) {\n    var symbols = Object.getOwnPropertySymbols(object);\n    if (enumerableOnly) symbols = symbols.filter(function (sym) {\n      return Object.getOwnPropertyDescriptor(object, sym).enumerable;\n    });\n    keys.push.apply(keys, symbols);\n  }\n\n  return keys;\n}\n\nfunction _objectSpread(target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = arguments[i] != null ? arguments[i] : {};\n\n    if (i % 2) {\n      ownKeys(Object(source), true).forEach(function (key) {\n        _defineProperty(target, key, source[key]);\n      });\n    } else if (Object.getOwnPropertyDescriptors) {\n      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));\n    } else {\n      ownKeys(Object(source)).forEach(function (key) {\n        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));\n      });\n    }\n  }\n\n  return target;\n}\n\nfunction _defineProperty(obj, key, value) {\n  if (key in obj) {\n    Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n  } else {\n    obj[key] = value;\n  }\n\n  return obj;\n}\n\nfunction _toConsumableArray(arr) {\n  return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _nonIterableSpread();\n}\n\nfunction _nonIterableSpread() {\n  throw new TypeError(\"Invalid attempt to spread non-iterable instance\");\n}\n\nfunction _iterableToArray(iter) {\n  if (Symbol.iterator in Object(iter) || Object.prototype.toString.call(iter) === \"[object Arguments]\") return Array.from(iter);\n}\n\nfunction _arrayWithoutHoles(arr) {\n  if (Array.isArray(arr)) {\n    for (var i = 0, arr2 = new Array(arr.length); i < arr.length; i++) {\n      arr2[i] = arr[i];\n    }\n\n    return arr2;\n  }\n}\n\nfunction createHistory(state, ignoreInitialState) {\n  // ignoreInitialState essentially prevents the user from undoing to the\n  // beginning, in the case that the undoable reducer handles initialization\n  // in a way that can't be redone simply\n  var history = (0, _helpers.newHistory)([], state, []);\n\n  if (ignoreInitialState) {\n    history._latestUnfiltered = null;\n  }\n\n  return history;\n} // insert: insert `state` into history, which means adding the current state\n//         into `past`, setting the new `state` as `present` and erasing\n//         the `future`.\n\n\nfunction insert(history, state, limit, group) {\n  var lengthWithoutFuture = history.past.length + 1;\n  debug.log('inserting', state);\n  debug.log('new free: ', limit - lengthWithoutFuture);\n  var past = history.past,\n      _latestUnfiltered = history._latestUnfiltered;\n  var isHistoryOverflow = limit && limit <= lengthWithoutFuture;\n  var pastSliced = past.slice(isHistoryOverflow ? 1 : 0);\n  var newPast = _latestUnfiltered != null ? [].concat(_toConsumableArray(pastSliced), [_latestUnfiltered]) : pastSliced;\n  return (0, _helpers.newHistory)(newPast, state, [], group);\n} // jumpToFuture: jump to requested index in future history\n\n\nfunction jumpToFuture(history, index) {\n  if (index < 0 || index >= history.future.length) return history;\n  var past = history.past,\n      future = history.future,\n      _latestUnfiltered = history._latestUnfiltered;\n  var newPast = [].concat(_toConsumableArray(past), [_latestUnfiltered], _toConsumableArray(future.slice(0, index)));\n  var newPresent = future[index];\n  var newFuture = future.slice(index + 1);\n  return (0, _helpers.newHistory)(newPast, newPresent, newFuture);\n} // jumpToPast: jump to requested index in past history\n\n\nfunction jumpToPast(history, index) {\n  if (index < 0 || index >= history.past.length) return history;\n  var past = history.past,\n      future = history.future,\n      _latestUnfiltered = history._latestUnfiltered;\n  var newPast = past.slice(0, index);\n  var newFuture = [].concat(_toConsumableArray(past.slice(index + 1)), [_latestUnfiltered], _toConsumableArray(future));\n  var newPresent = past[index];\n  return (0, _helpers.newHistory)(newPast, newPresent, newFuture);\n} // jump: jump n steps in the past or forward\n\n\nfunction jump(history, n) {\n  if (n > 0) return jumpToFuture(history, n - 1);\n  if (n < 0) return jumpToPast(history, history.past.length + n);\n  return history;\n} // helper to dynamically match in the reducer's switch-case\n\n\nfunction actionTypeAmongClearHistoryType(actionType, clearHistoryType) {\n  return clearHistoryType.indexOf(actionType) > -1 ? actionType : !actionType;\n} // redux-undo higher order reducer\n\n\nfunction undoable(reducer) {\n  var rawConfig = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  debug.set(rawConfig.debug);\n\n  var config = _objectSpread({\n    limit: undefined,\n    filter: function filter() {\n      return true;\n    },\n    groupBy: function groupBy() {\n      return null;\n    },\n    undoType: _actions.ActionTypes.UNDO,\n    redoType: _actions.ActionTypes.REDO,\n    jumpToPastType: _actions.ActionTypes.JUMP_TO_PAST,\n    jumpToFutureType: _actions.ActionTypes.JUMP_TO_FUTURE,\n    jumpType: _actions.ActionTypes.JUMP,\n    neverSkipReducer: false,\n    ignoreInitialState: false,\n    syncFilter: false\n  }, rawConfig, {\n    initTypes: (0, _helpers.parseActions)(rawConfig.initTypes, ['@@redux-undo/INIT']),\n    clearHistoryType: (0, _helpers.parseActions)(rawConfig.clearHistoryType, [_actions.ActionTypes.CLEAR_HISTORY])\n  }); // Allows the user to call the reducer with redux-undo specific actions\n\n\n  var skipReducer = config.neverSkipReducer ? function (res, action) {\n    for (var _len = arguments.length, slices = new Array(_len > 2 ? _len - 2 : 0), _key = 2; _key < _len; _key++) {\n      slices[_key - 2] = arguments[_key];\n    }\n\n    return _objectSpread({}, res, {\n      present: reducer.apply(void 0, [res.present, action].concat(slices))\n    });\n  } : function (res) {\n    return res;\n  };\n  var initialState;\n  return function () {\n    var state = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : initialState;\n    var action = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    debug.start(action, state);\n    var history = state;\n\n    for (var _len2 = arguments.length, slices = new Array(_len2 > 2 ? _len2 - 2 : 0), _key2 = 2; _key2 < _len2; _key2++) {\n      slices[_key2 - 2] = arguments[_key2];\n    }\n\n    if (!initialState) {\n      debug.log('history is uninitialized');\n\n      if (state === undefined) {\n        var createHistoryAction = {\n          type: '@@redux-undo/CREATE_HISTORY'\n        };\n        var start = reducer.apply(void 0, [state, createHistoryAction].concat(slices));\n        history = createHistory(start, config.ignoreInitialState);\n        debug.log('do not set initialState on probe actions');\n        debug.end(history);\n        return history;\n      } else if ((0, _helpers.isHistory)(state)) {\n        history = initialState = config.ignoreInitialState ? state : (0, _helpers.newHistory)(state.past, state.present, state.future);\n        debug.log('initialHistory initialized: initialState is a history', initialState);\n      } else {\n        history = initialState = createHistory(state, config.ignoreInitialState);\n        debug.log('initialHistory initialized: initialState is not a history', initialState);\n      }\n    }\n\n    var res;\n\n    switch (action.type) {\n      case undefined:\n        return history;\n\n      case config.undoType:\n        res = jump(history, -1);\n        debug.log('perform undo');\n        debug.end(res);\n        return skipReducer.apply(void 0, [res, action].concat(slices));\n\n      case config.redoType:\n        res = jump(history, 1);\n        debug.log('perform redo');\n        debug.end(res);\n        return skipReducer.apply(void 0, [res, action].concat(slices));\n\n      case config.jumpToPastType:\n        res = jumpToPast(history, action.index);\n        debug.log(\"perform jumpToPast to \".concat(action.index));\n        debug.end(res);\n        return skipReducer.apply(void 0, [res, action].concat(slices));\n\n      case config.jumpToFutureType:\n        res = jumpToFuture(history, action.index);\n        debug.log(\"perform jumpToFuture to \".concat(action.index));\n        debug.end(res);\n        return skipReducer.apply(void 0, [res, action].concat(slices));\n\n      case config.jumpType:\n        res = jump(history, action.index);\n        debug.log(\"perform jump to \".concat(action.index));\n        debug.end(res);\n        return skipReducer.apply(void 0, [res, action].concat(slices));\n\n      case actionTypeAmongClearHistoryType(action.type, config.clearHistoryType):\n        res = createHistory(history.present, config.ignoreInitialState);\n        debug.log('perform clearHistory');\n        debug.end(res);\n        return skipReducer.apply(void 0, [res, action].concat(slices));\n\n      default:\n        res = reducer.apply(void 0, [history.present, action].concat(slices));\n\n        if (config.initTypes.some(function (actionType) {\n          return actionType === action.type;\n        })) {\n          debug.log('reset history due to init action');\n          debug.end(initialState);\n          return initialState;\n        }\n\n        if (history._latestUnfiltered === res) {\n          // Don't handle this action. Do not call debug.end here,\n          // because this action should not produce side effects to the console\n          return history;\n        }\n        /* eslint-disable-next-line no-case-declarations */\n\n\n        var filtered = typeof config.filter === 'function' && !config.filter(action, res, history);\n\n        if (filtered) {\n          // if filtering an action, merely update the present\n          var filteredState = (0, _helpers.newHistory)(history.past, res, history.future, history.group);\n\n          if (!config.syncFilter) {\n            filteredState._latestUnfiltered = history._latestUnfiltered;\n          }\n\n          debug.log('filter ignored action, not storing it in past');\n          debug.end(filteredState);\n          return filteredState;\n        }\n        /* eslint-disable-next-line no-case-declarations */\n\n\n        var group = config.groupBy(action, res, history);\n\n        if (group != null && group === history.group) {\n          // if grouping with the previous action, only update the present\n          var groupedState = (0, _helpers.newHistory)(history.past, res, history.future, history.group);\n          debug.log('groupBy grouped the action with the previous action');\n          debug.end(groupedState);\n          return groupedState;\n        } // If the action wasn't filtered or grouped, insert normally\n\n\n        history = insert(history, res, config.limit, group);\n        debug.log('inserted new state into history');\n        debug.end(history);\n        return history;\n    }\n  };\n}","map":{"version":3,"sources":["/home/magoo/projects/keyrier-json/node_modules/redux-undo/lib/reducer.js"],"names":["_typeof","obj","Symbol","iterator","constructor","prototype","Object","defineProperty","exports","value","undoable","debug","_interopRequireWildcard","require","_actions","_helpers","_getRequireWildcardCache","WeakMap","cache","__esModule","has","get","newObj","hasPropertyDescriptor","getOwnPropertyDescriptor","key","hasOwnProperty","call","desc","set","ownKeys","object","enumerableOnly","keys","getOwnPropertySymbols","symbols","filter","sym","enumerable","push","apply","_objectSpread","target","i","arguments","length","source","forEach","_defineProperty","getOwnPropertyDescriptors","defineProperties","configurable","writable","_toConsumableArray","arr","_arrayWithoutHoles","_iterableToArray","_nonIterableSpread","TypeError","iter","toString","Array","from","isArray","arr2","createHistory","state","ignoreInitialState","history","newHistory","_latestUnfiltered","insert","limit","group","lengthWithoutFuture","past","log","isHistoryOverflow","pastSliced","slice","newPast","concat","jumpToFuture","index","future","newPresent","newFuture","jumpToPast","jump","n","actionTypeAmongClearHistoryType","actionType","clearHistoryType","indexOf","reducer","rawConfig","undefined","config","groupBy","undoType","ActionTypes","UNDO","redoType","REDO","jumpToPastType","JUMP_TO_PAST","jumpToFutureType","JUMP_TO_FUTURE","jumpType","JUMP","neverSkipReducer","syncFilter","initTypes","parseActions","CLEAR_HISTORY","skipReducer","res","action","_len","slices","_key","present","initialState","start","_len2","_key2","createHistoryAction","type","end","isHistory","some","filtered","filteredState","groupedState"],"mappings":"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","sourcesContent":["\"use strict\";\n\nfunction _typeof(obj) { if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }; } return _typeof(obj); }\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports[\"default\"] = undoable;\n\nvar debug = _interopRequireWildcard(require(\"./debug\"));\n\nvar _actions = require(\"./actions\");\n\nvar _helpers = require(\"./helpers\");\n\nfunction _getRequireWildcardCache() { if (typeof WeakMap !== \"function\") return null; var cache = new WeakMap(); _getRequireWildcardCache = function _getRequireWildcardCache() { return cache; }; return cache; }\n\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } if (obj === null || _typeof(obj) !== \"object\" && typeof obj !== \"function\") { return { \"default\": obj }; } var cache = _getRequireWildcardCache(); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj[\"default\"] = obj; if (cache) { cache.set(obj, newObj); } return newObj; }\n\nfunction ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }\n\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }\n\nfunction _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\nfunction _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _nonIterableSpread(); }\n\nfunction _nonIterableSpread() { throw new TypeError(\"Invalid attempt to spread non-iterable instance\"); }\n\nfunction _iterableToArray(iter) { if (Symbol.iterator in Object(iter) || Object.prototype.toString.call(iter) === \"[object Arguments]\") return Array.from(iter); }\n\nfunction _arrayWithoutHoles(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = new Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } }\n\nfunction createHistory(state, ignoreInitialState) {\n  // ignoreInitialState essentially prevents the user from undoing to the\n  // beginning, in the case that the undoable reducer handles initialization\n  // in a way that can't be redone simply\n  var history = (0, _helpers.newHistory)([], state, []);\n\n  if (ignoreInitialState) {\n    history._latestUnfiltered = null;\n  }\n\n  return history;\n} // insert: insert `state` into history, which means adding the current state\n//         into `past`, setting the new `state` as `present` and erasing\n//         the `future`.\n\n\nfunction insert(history, state, limit, group) {\n  var lengthWithoutFuture = history.past.length + 1;\n  debug.log('inserting', state);\n  debug.log('new free: ', limit - lengthWithoutFuture);\n  var past = history.past,\n      _latestUnfiltered = history._latestUnfiltered;\n  var isHistoryOverflow = limit && limit <= lengthWithoutFuture;\n  var pastSliced = past.slice(isHistoryOverflow ? 1 : 0);\n  var newPast = _latestUnfiltered != null ? [].concat(_toConsumableArray(pastSliced), [_latestUnfiltered]) : pastSliced;\n  return (0, _helpers.newHistory)(newPast, state, [], group);\n} // jumpToFuture: jump to requested index in future history\n\n\nfunction jumpToFuture(history, index) {\n  if (index < 0 || index >= history.future.length) return history;\n  var past = history.past,\n      future = history.future,\n      _latestUnfiltered = history._latestUnfiltered;\n  var newPast = [].concat(_toConsumableArray(past), [_latestUnfiltered], _toConsumableArray(future.slice(0, index)));\n  var newPresent = future[index];\n  var newFuture = future.slice(index + 1);\n  return (0, _helpers.newHistory)(newPast, newPresent, newFuture);\n} // jumpToPast: jump to requested index in past history\n\n\nfunction jumpToPast(history, index) {\n  if (index < 0 || index >= history.past.length) return history;\n  var past = history.past,\n      future = history.future,\n      _latestUnfiltered = history._latestUnfiltered;\n  var newPast = past.slice(0, index);\n  var newFuture = [].concat(_toConsumableArray(past.slice(index + 1)), [_latestUnfiltered], _toConsumableArray(future));\n  var newPresent = past[index];\n  return (0, _helpers.newHistory)(newPast, newPresent, newFuture);\n} // jump: jump n steps in the past or forward\n\n\nfunction jump(history, n) {\n  if (n > 0) return jumpToFuture(history, n - 1);\n  if (n < 0) return jumpToPast(history, history.past.length + n);\n  return history;\n} // helper to dynamically match in the reducer's switch-case\n\n\nfunction actionTypeAmongClearHistoryType(actionType, clearHistoryType) {\n  return clearHistoryType.indexOf(actionType) > -1 ? actionType : !actionType;\n} // redux-undo higher order reducer\n\n\nfunction undoable(reducer) {\n  var rawConfig = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  debug.set(rawConfig.debug);\n\n  var config = _objectSpread({\n    limit: undefined,\n    filter: function filter() {\n      return true;\n    },\n    groupBy: function groupBy() {\n      return null;\n    },\n    undoType: _actions.ActionTypes.UNDO,\n    redoType: _actions.ActionTypes.REDO,\n    jumpToPastType: _actions.ActionTypes.JUMP_TO_PAST,\n    jumpToFutureType: _actions.ActionTypes.JUMP_TO_FUTURE,\n    jumpType: _actions.ActionTypes.JUMP,\n    neverSkipReducer: false,\n    ignoreInitialState: false,\n    syncFilter: false\n  }, rawConfig, {\n    initTypes: (0, _helpers.parseActions)(rawConfig.initTypes, ['@@redux-undo/INIT']),\n    clearHistoryType: (0, _helpers.parseActions)(rawConfig.clearHistoryType, [_actions.ActionTypes.CLEAR_HISTORY])\n  }); // Allows the user to call the reducer with redux-undo specific actions\n\n\n  var skipReducer = config.neverSkipReducer ? function (res, action) {\n    for (var _len = arguments.length, slices = new Array(_len > 2 ? _len - 2 : 0), _key = 2; _key < _len; _key++) {\n      slices[_key - 2] = arguments[_key];\n    }\n\n    return _objectSpread({}, res, {\n      present: reducer.apply(void 0, [res.present, action].concat(slices))\n    });\n  } : function (res) {\n    return res;\n  };\n  var initialState;\n  return function () {\n    var state = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : initialState;\n    var action = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    debug.start(action, state);\n    var history = state;\n\n    for (var _len2 = arguments.length, slices = new Array(_len2 > 2 ? _len2 - 2 : 0), _key2 = 2; _key2 < _len2; _key2++) {\n      slices[_key2 - 2] = arguments[_key2];\n    }\n\n    if (!initialState) {\n      debug.log('history is uninitialized');\n\n      if (state === undefined) {\n        var createHistoryAction = {\n          type: '@@redux-undo/CREATE_HISTORY'\n        };\n        var start = reducer.apply(void 0, [state, createHistoryAction].concat(slices));\n        history = createHistory(start, config.ignoreInitialState);\n        debug.log('do not set initialState on probe actions');\n        debug.end(history);\n        return history;\n      } else if ((0, _helpers.isHistory)(state)) {\n        history = initialState = config.ignoreInitialState ? state : (0, _helpers.newHistory)(state.past, state.present, state.future);\n        debug.log('initialHistory initialized: initialState is a history', initialState);\n      } else {\n        history = initialState = createHistory(state, config.ignoreInitialState);\n        debug.log('initialHistory initialized: initialState is not a history', initialState);\n      }\n    }\n\n    var res;\n\n    switch (action.type) {\n      case undefined:\n        return history;\n\n      case config.undoType:\n        res = jump(history, -1);\n        debug.log('perform undo');\n        debug.end(res);\n        return skipReducer.apply(void 0, [res, action].concat(slices));\n\n      case config.redoType:\n        res = jump(history, 1);\n        debug.log('perform redo');\n        debug.end(res);\n        return skipReducer.apply(void 0, [res, action].concat(slices));\n\n      case config.jumpToPastType:\n        res = jumpToPast(history, action.index);\n        debug.log(\"perform jumpToPast to \".concat(action.index));\n        debug.end(res);\n        return skipReducer.apply(void 0, [res, action].concat(slices));\n\n      case config.jumpToFutureType:\n        res = jumpToFuture(history, action.index);\n        debug.log(\"perform jumpToFuture to \".concat(action.index));\n        debug.end(res);\n        return skipReducer.apply(void 0, [res, action].concat(slices));\n\n      case config.jumpType:\n        res = jump(history, action.index);\n        debug.log(\"perform jump to \".concat(action.index));\n        debug.end(res);\n        return skipReducer.apply(void 0, [res, action].concat(slices));\n\n      case actionTypeAmongClearHistoryType(action.type, config.clearHistoryType):\n        res = createHistory(history.present, config.ignoreInitialState);\n        debug.log('perform clearHistory');\n        debug.end(res);\n        return skipReducer.apply(void 0, [res, action].concat(slices));\n\n      default:\n        res = reducer.apply(void 0, [history.present, action].concat(slices));\n\n        if (config.initTypes.some(function (actionType) {\n          return actionType === action.type;\n        })) {\n          debug.log('reset history due to init action');\n          debug.end(initialState);\n          return initialState;\n        }\n\n        if (history._latestUnfiltered === res) {\n          // Don't handle this action. Do not call debug.end here,\n          // because this action should not produce side effects to the console\n          return history;\n        }\n        /* eslint-disable-next-line no-case-declarations */\n\n\n        var filtered = typeof config.filter === 'function' && !config.filter(action, res, history);\n\n        if (filtered) {\n          // if filtering an action, merely update the present\n          var filteredState = (0, _helpers.newHistory)(history.past, res, history.future, history.group);\n\n          if (!config.syncFilter) {\n            filteredState._latestUnfiltered = history._latestUnfiltered;\n          }\n\n          debug.log('filter ignored action, not storing it in past');\n          debug.end(filteredState);\n          return filteredState;\n        }\n        /* eslint-disable-next-line no-case-declarations */\n\n\n        var group = config.groupBy(action, res, history);\n\n        if (group != null && group === history.group) {\n          // if grouping with the previous action, only update the present\n          var groupedState = (0, _helpers.newHistory)(history.past, res, history.future, history.group);\n          debug.log('groupBy grouped the action with the previous action');\n          debug.end(groupedState);\n          return groupedState;\n        } // If the action wasn't filtered or grouped, insert normally\n\n\n        history = insert(history, res, config.limit, group);\n        debug.log('inserted new state into history');\n        debug.end(history);\n        return history;\n    }\n  };\n}"]},"metadata":{},"sourceType":"script"}