{"ast":null,"code":"var __extends = this && this.__extends || function () {\n  var extendStatics = function (d, b) {\n    extendStatics = Object.setPrototypeOf || {\n      __proto__: []\n    } instanceof Array && function (d, b) {\n      d.__proto__ = b;\n    } || function (d, b) {\n      for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    };\n\n    return extendStatics(d, b);\n  };\n\n  return function (d, b) {\n    extendStatics(d, b);\n\n    function __() {\n      this.constructor = d;\n    }\n\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n  };\n}();\n\nimport * as utils from \"../../utils/utils\";\nimport { contains, every, findAll, flatten, forEach, isEmpty, map, reduce, reject } from \"../../utils/utils\";\nimport { ParserDefinitionErrorType } from \"../parser/parser\";\nimport { getProductionDslName, isOptionalProd } from \"./gast/gast\";\nimport { containsPath, getLookaheadPathsForOptionalProd, getLookaheadPathsForOr, getProdType, isStrictPrefixOfPath } from \"./lookahead\";\nimport { nextPossibleTokensAfter } from \"./interpreter\";\nimport { Alternation, Alternative as AlternativeGAST, NonTerminal, Option, Repetition, RepetitionMandatory, RepetitionMandatoryWithSeparator, RepetitionWithSeparator, Terminal } from \"./gast/gast_public\";\nimport { GAstVisitor } from \"./gast/gast_visitor_public\";\nexport function validateGrammar(topLevels, globalMaxLookahead, tokenTypes, errMsgProvider, grammarName) {\n  var duplicateErrors = utils.map(topLevels, function (currTopLevel) {\n    return validateDuplicateProductions(currTopLevel, errMsgProvider);\n  });\n  var leftRecursionErrors = utils.map(topLevels, function (currTopRule) {\n    return validateNoLeftRecursion(currTopRule, currTopRule, errMsgProvider);\n  });\n  var emptyAltErrors = [];\n  var ambiguousAltsErrors = [];\n  var emptyRepetitionErrors = []; // left recursion could cause infinite loops in the following validations.\n  // It is safest to first have the user fix the left recursion errors first and only then examine Further issues.\n\n  if (every(leftRecursionErrors, isEmpty)) {\n    emptyAltErrors = map(topLevels, function (currTopRule) {\n      return validateEmptyOrAlternative(currTopRule, errMsgProvider);\n    });\n    ambiguousAltsErrors = map(topLevels, function (currTopRule) {\n      return validateAmbiguousAlternationAlternatives(currTopRule, globalMaxLookahead, errMsgProvider);\n    });\n    emptyRepetitionErrors = validateSomeNonEmptyLookaheadPath(topLevels, globalMaxLookahead, errMsgProvider);\n  }\n\n  var termsNamespaceConflictErrors = checkTerminalAndNoneTerminalsNameSpace(topLevels, tokenTypes, errMsgProvider);\n  var tokenNameErrors = utils.map(tokenTypes, function (currTokType) {\n    return validateTokenName(currTokType, errMsgProvider);\n  });\n  var tooManyAltsErrors = map(topLevels, function (curRule) {\n    return validateTooManyAlts(curRule, errMsgProvider);\n  });\n  var ruleNameErrors = map(topLevels, function (curRule) {\n    return validateRuleName(curRule, errMsgProvider);\n  });\n  var duplicateRulesError = map(topLevels, function (curRule) {\n    return validateRuleDoesNotAlreadyExist(curRule, topLevels, grammarName, errMsgProvider);\n  });\n  return utils.flatten(duplicateErrors.concat(tokenNameErrors, emptyRepetitionErrors, leftRecursionErrors, emptyAltErrors, ambiguousAltsErrors, termsNamespaceConflictErrors, tooManyAltsErrors, ruleNameErrors, duplicateRulesError));\n}\n\nfunction validateDuplicateProductions(topLevelRule, errMsgProvider) {\n  var collectorVisitor = new OccurrenceValidationCollector();\n  topLevelRule.accept(collectorVisitor);\n  var allRuleProductions = collectorVisitor.allProductions;\n  var productionGroups = utils.groupBy(allRuleProductions, identifyProductionForDuplicates);\n  var duplicates = utils.pick(productionGroups, function (currGroup) {\n    return currGroup.length > 1;\n  });\n  var errors = utils.map(utils.values(duplicates), function (currDuplicates) {\n    var firstProd = utils.first(currDuplicates);\n    var msg = errMsgProvider.buildDuplicateFoundError(topLevelRule, currDuplicates);\n    var dslName = getProductionDslName(firstProd);\n    var defError = {\n      message: msg,\n      type: ParserDefinitionErrorType.DUPLICATE_PRODUCTIONS,\n      ruleName: topLevelRule.name,\n      dslName: dslName,\n      occurrence: firstProd.idx\n    };\n    var param = getExtraProductionArgument(firstProd);\n\n    if (param) {\n      defError.parameter = param;\n    }\n\n    return defError;\n  });\n  return errors;\n}\n\nexport function identifyProductionForDuplicates(prod) {\n  return getProductionDslName(prod) + \"_#_\" + prod.idx + \"_#_\" + getExtraProductionArgument(prod);\n}\n\nfunction getExtraProductionArgument(prod) {\n  if (prod instanceof Terminal) {\n    return prod.terminalType.name;\n  } else if (prod instanceof NonTerminal) {\n    return prod.nonTerminalName;\n  } else {\n    return \"\";\n  }\n}\n\nvar OccurrenceValidationCollector =\n/** @class */\nfunction (_super) {\n  __extends(OccurrenceValidationCollector, _super);\n\n  function OccurrenceValidationCollector() {\n    var _this = _super !== null && _super.apply(this, arguments) || this;\n\n    _this.allProductions = [];\n    return _this;\n  }\n\n  OccurrenceValidationCollector.prototype.visitNonTerminal = function (subrule) {\n    this.allProductions.push(subrule);\n  };\n\n  OccurrenceValidationCollector.prototype.visitOption = function (option) {\n    this.allProductions.push(option);\n  };\n\n  OccurrenceValidationCollector.prototype.visitRepetitionWithSeparator = function (manySep) {\n    this.allProductions.push(manySep);\n  };\n\n  OccurrenceValidationCollector.prototype.visitRepetitionMandatory = function (atLeastOne) {\n    this.allProductions.push(atLeastOne);\n  };\n\n  OccurrenceValidationCollector.prototype.visitRepetitionMandatoryWithSeparator = function (atLeastOneSep) {\n    this.allProductions.push(atLeastOneSep);\n  };\n\n  OccurrenceValidationCollector.prototype.visitRepetition = function (many) {\n    this.allProductions.push(many);\n  };\n\n  OccurrenceValidationCollector.prototype.visitAlternation = function (or) {\n    this.allProductions.push(or);\n  };\n\n  OccurrenceValidationCollector.prototype.visitTerminal = function (terminal) {\n    this.allProductions.push(terminal);\n  };\n\n  return OccurrenceValidationCollector;\n}(GAstVisitor);\n\nexport { OccurrenceValidationCollector };\nexport var validTermsPattern = /^[a-zA-Z_]\\w*$/; // TODO: remove this limitation now that we use recorders\n\nexport function validateRuleName(rule, errMsgProvider) {\n  var errors = [];\n  var ruleName = rule.name;\n\n  if (!ruleName.match(validTermsPattern)) {\n    errors.push({\n      message: errMsgProvider.buildInvalidRuleNameError({\n        topLevelRule: rule,\n        expectedPattern: validTermsPattern\n      }),\n      type: ParserDefinitionErrorType.INVALID_RULE_NAME,\n      ruleName: ruleName\n    });\n  }\n\n  return errors;\n} // TODO: remove this limitation now that we use recorders\n\nexport function validateTokenName(tokenType, errMsgProvider) {\n  var errors = [];\n  var tokTypeName = tokenType.name;\n\n  if (!tokTypeName.match(validTermsPattern)) {\n    errors.push({\n      message: errMsgProvider.buildTokenNameError({\n        tokenType: tokenType,\n        expectedPattern: validTermsPattern\n      }),\n      type: ParserDefinitionErrorType.INVALID_TOKEN_NAME\n    });\n  }\n\n  return errors;\n}\nexport function validateRuleDoesNotAlreadyExist(rule, allRules, className, errMsgProvider) {\n  var errors = [];\n  var occurrences = reduce(allRules, function (result, curRule) {\n    if (curRule.name === rule.name) {\n      return result + 1;\n    }\n\n    return result;\n  }, 0);\n\n  if (occurrences > 1) {\n    var errMsg = errMsgProvider.buildDuplicateRuleNameError({\n      topLevelRule: rule,\n      grammarName: className\n    });\n    errors.push({\n      message: errMsg,\n      type: ParserDefinitionErrorType.DUPLICATE_RULE_NAME,\n      ruleName: rule.name\n    });\n  }\n\n  return errors;\n} // TODO: is there anyway to get only the rule names of rules inherited from the super grammars?\n// This is not part of the IGrammarErrorProvider because the validation cannot be performed on\n// The grammar structure, only at runtime.\n\nexport function validateRuleIsOverridden(ruleName, definedRulesNames, className) {\n  var errors = [];\n  var errMsg;\n\n  if (!utils.contains(definedRulesNames, ruleName)) {\n    errMsg = \"Invalid rule override, rule: ->\" + ruleName + \"<- cannot be overridden in the grammar: ->\" + className + \"<-\" + \"as it is not defined in any of the super grammars \";\n    errors.push({\n      message: errMsg,\n      type: ParserDefinitionErrorType.INVALID_RULE_OVERRIDE,\n      ruleName: ruleName\n    });\n  }\n\n  return errors;\n}\nexport function validateNoLeftRecursion(topRule, currRule, errMsgProvider, path) {\n  if (path === void 0) {\n    path = [];\n  }\n\n  var errors = [];\n  var nextNonTerminals = getFirstNoneTerminal(currRule.definition);\n\n  if (utils.isEmpty(nextNonTerminals)) {\n    return [];\n  } else {\n    var ruleName = topRule.name;\n    var foundLeftRecursion = utils.contains(nextNonTerminals, topRule);\n\n    if (foundLeftRecursion) {\n      errors.push({\n        message: errMsgProvider.buildLeftRecursionError({\n          topLevelRule: topRule,\n          leftRecursionPath: path\n        }),\n        type: ParserDefinitionErrorType.LEFT_RECURSION,\n        ruleName: ruleName\n      });\n    } // we are only looking for cyclic paths leading back to the specific topRule\n    // other cyclic paths are ignored, we still need this difference to avoid infinite loops...\n\n\n    var validNextSteps = utils.difference(nextNonTerminals, path.concat([topRule]));\n    var errorsFromNextSteps = utils.map(validNextSteps, function (currRefRule) {\n      var newPath = utils.cloneArr(path);\n      newPath.push(currRefRule);\n      return validateNoLeftRecursion(topRule, currRefRule, errMsgProvider, newPath);\n    });\n    return errors.concat(utils.flatten(errorsFromNextSteps));\n  }\n}\nexport function getFirstNoneTerminal(definition) {\n  var result = [];\n\n  if (utils.isEmpty(definition)) {\n    return result;\n  }\n\n  var firstProd = utils.first(definition);\n  /* istanbul ignore else */\n\n  if (firstProd instanceof NonTerminal) {\n    result.push(firstProd.referencedRule);\n  } else if (firstProd instanceof AlternativeGAST || firstProd instanceof Option || firstProd instanceof RepetitionMandatory || firstProd instanceof RepetitionMandatoryWithSeparator || firstProd instanceof RepetitionWithSeparator || firstProd instanceof Repetition) {\n    result = result.concat(getFirstNoneTerminal(firstProd.definition));\n  } else if (firstProd instanceof Alternation) {\n    // each sub definition in alternation is a FLAT\n    result = utils.flatten(utils.map(firstProd.definition, function (currSubDef) {\n      return getFirstNoneTerminal(currSubDef.definition);\n    }));\n  } else if (firstProd instanceof Terminal) {// nothing to see, move along\n  } else {\n    throw Error(\"non exhaustive match\");\n  }\n\n  var isFirstOptional = isOptionalProd(firstProd);\n  var hasMore = definition.length > 1;\n\n  if (isFirstOptional && hasMore) {\n    var rest = utils.drop(definition);\n    return result.concat(getFirstNoneTerminal(rest));\n  } else {\n    return result;\n  }\n}\n\nvar OrCollector =\n/** @class */\nfunction (_super) {\n  __extends(OrCollector, _super);\n\n  function OrCollector() {\n    var _this = _super !== null && _super.apply(this, arguments) || this;\n\n    _this.alternations = [];\n    return _this;\n  }\n\n  OrCollector.prototype.visitAlternation = function (node) {\n    this.alternations.push(node);\n  };\n\n  return OrCollector;\n}(GAstVisitor);\n\nexport function validateEmptyOrAlternative(topLevelRule, errMsgProvider) {\n  var orCollector = new OrCollector();\n  topLevelRule.accept(orCollector);\n  var ors = orCollector.alternations;\n  var errors = utils.reduce(ors, function (errors, currOr) {\n    var exceptLast = utils.dropRight(currOr.definition);\n    var currErrors = utils.map(exceptLast, function (currAlternative, currAltIdx) {\n      var possibleFirstInAlt = nextPossibleTokensAfter([currAlternative], [], null, 1);\n\n      if (utils.isEmpty(possibleFirstInAlt)) {\n        return {\n          message: errMsgProvider.buildEmptyAlternationError({\n            topLevelRule: topLevelRule,\n            alternation: currOr,\n            emptyChoiceIdx: currAltIdx\n          }),\n          type: ParserDefinitionErrorType.NONE_LAST_EMPTY_ALT,\n          ruleName: topLevelRule.name,\n          occurrence: currOr.idx,\n          alternative: currAltIdx + 1\n        };\n      } else {\n        return null;\n      }\n    });\n    return errors.concat(utils.compact(currErrors));\n  }, []);\n  return errors;\n}\nexport function validateAmbiguousAlternationAlternatives(topLevelRule, globalMaxLookahead, errMsgProvider) {\n  var orCollector = new OrCollector();\n  topLevelRule.accept(orCollector);\n  var ors = orCollector.alternations; // New Handling of ignoring ambiguities\n  // - https://github.com/SAP/chevrotain/issues/869\n\n  ors = reject(ors, function (currOr) {\n    return currOr.ignoreAmbiguities === true;\n  });\n  var errors = utils.reduce(ors, function (result, currOr) {\n    var currOccurrence = currOr.idx;\n    var actualMaxLookahead = currOr.maxLookahead || globalMaxLookahead;\n    var alternatives = getLookaheadPathsForOr(currOccurrence, topLevelRule, actualMaxLookahead, currOr);\n    var altsAmbiguityErrors = checkAlternativesAmbiguities(alternatives, currOr, topLevelRule, errMsgProvider);\n    var altsPrefixAmbiguityErrors = checkPrefixAlternativesAmbiguities(alternatives, currOr, topLevelRule, errMsgProvider);\n    return result.concat(altsAmbiguityErrors, altsPrefixAmbiguityErrors);\n  }, []);\n  return errors;\n}\n\nvar RepetionCollector =\n/** @class */\nfunction (_super) {\n  __extends(RepetionCollector, _super);\n\n  function RepetionCollector() {\n    var _this = _super !== null && _super.apply(this, arguments) || this;\n\n    _this.allProductions = [];\n    return _this;\n  }\n\n  RepetionCollector.prototype.visitRepetitionWithSeparator = function (manySep) {\n    this.allProductions.push(manySep);\n  };\n\n  RepetionCollector.prototype.visitRepetitionMandatory = function (atLeastOne) {\n    this.allProductions.push(atLeastOne);\n  };\n\n  RepetionCollector.prototype.visitRepetitionMandatoryWithSeparator = function (atLeastOneSep) {\n    this.allProductions.push(atLeastOneSep);\n  };\n\n  RepetionCollector.prototype.visitRepetition = function (many) {\n    this.allProductions.push(many);\n  };\n\n  return RepetionCollector;\n}(GAstVisitor);\n\nexport { RepetionCollector };\nexport function validateTooManyAlts(topLevelRule, errMsgProvider) {\n  var orCollector = new OrCollector();\n  topLevelRule.accept(orCollector);\n  var ors = orCollector.alternations;\n  var errors = utils.reduce(ors, function (errors, currOr) {\n    if (currOr.definition.length > 255) {\n      errors.push({\n        message: errMsgProvider.buildTooManyAlternativesError({\n          topLevelRule: topLevelRule,\n          alternation: currOr\n        }),\n        type: ParserDefinitionErrorType.TOO_MANY_ALTS,\n        ruleName: topLevelRule.name,\n        occurrence: currOr.idx\n      });\n    }\n\n    return errors;\n  }, []);\n  return errors;\n}\nexport function validateSomeNonEmptyLookaheadPath(topLevelRules, maxLookahead, errMsgProvider) {\n  var errors = [];\n  forEach(topLevelRules, function (currTopRule) {\n    var collectorVisitor = new RepetionCollector();\n    currTopRule.accept(collectorVisitor);\n    var allRuleProductions = collectorVisitor.allProductions;\n    forEach(allRuleProductions, function (currProd) {\n      var prodType = getProdType(currProd);\n      var actualMaxLookahead = currProd.maxLookahead || maxLookahead;\n      var currOccurrence = currProd.idx;\n      var paths = getLookaheadPathsForOptionalProd(currOccurrence, currTopRule, prodType, actualMaxLookahead);\n      var pathsInsideProduction = paths[0];\n\n      if (isEmpty(flatten(pathsInsideProduction))) {\n        var errMsg = errMsgProvider.buildEmptyRepetitionError({\n          topLevelRule: currTopRule,\n          repetition: currProd\n        });\n        errors.push({\n          message: errMsg,\n          type: ParserDefinitionErrorType.NO_NON_EMPTY_LOOKAHEAD,\n          ruleName: currTopRule.name\n        });\n      }\n    });\n  });\n  return errors;\n}\n\nfunction checkAlternativesAmbiguities(alternatives, alternation, rule, errMsgProvider) {\n  var foundAmbiguousPaths = [];\n  var identicalAmbiguities = reduce(alternatives, function (result, currAlt, currAltIdx) {\n    // ignore (skip) ambiguities with this alternative\n    if (alternation.definition[currAltIdx].ignoreAmbiguities === true) {\n      return result;\n    }\n\n    forEach(currAlt, function (currPath) {\n      var altsCurrPathAppearsIn = [currAltIdx];\n      forEach(alternatives, function (currOtherAlt, currOtherAltIdx) {\n        if (currAltIdx !== currOtherAltIdx && containsPath(currOtherAlt, currPath) && // ignore (skip) ambiguities with this \"other\" alternative\n        alternation.definition[currOtherAltIdx].ignoreAmbiguities !== true) {\n          altsCurrPathAppearsIn.push(currOtherAltIdx);\n        }\n      });\n\n      if (altsCurrPathAppearsIn.length > 1 && !containsPath(foundAmbiguousPaths, currPath)) {\n        foundAmbiguousPaths.push(currPath);\n        result.push({\n          alts: altsCurrPathAppearsIn,\n          path: currPath\n        });\n      }\n    });\n    return result;\n  }, []);\n  var currErrors = utils.map(identicalAmbiguities, function (currAmbDescriptor) {\n    var ambgIndices = map(currAmbDescriptor.alts, function (currAltIdx) {\n      return currAltIdx + 1;\n    });\n    var currMessage = errMsgProvider.buildAlternationAmbiguityError({\n      topLevelRule: rule,\n      alternation: alternation,\n      ambiguityIndices: ambgIndices,\n      prefixPath: currAmbDescriptor.path\n    });\n    return {\n      message: currMessage,\n      type: ParserDefinitionErrorType.AMBIGUOUS_ALTS,\n      ruleName: rule.name,\n      occurrence: alternation.idx,\n      alternatives: [currAmbDescriptor.alts]\n    };\n  });\n  return currErrors;\n}\n\nexport function checkPrefixAlternativesAmbiguities(alternatives, alternation, rule, errMsgProvider) {\n  var errors = []; // flatten\n\n  var pathsAndIndices = reduce(alternatives, function (result, currAlt, idx) {\n    var currPathsAndIdx = map(currAlt, function (currPath) {\n      return {\n        idx: idx,\n        path: currPath\n      };\n    });\n    return result.concat(currPathsAndIdx);\n  }, []);\n  forEach(pathsAndIndices, function (currPathAndIdx) {\n    var alternativeGast = alternation.definition[currPathAndIdx.idx]; // ignore (skip) ambiguities with this alternative\n\n    if (alternativeGast.ignoreAmbiguities === true) {\n      return;\n    }\n\n    var targetIdx = currPathAndIdx.idx;\n    var targetPath = currPathAndIdx.path;\n    var prefixAmbiguitiesPathsAndIndices = findAll(pathsAndIndices, function (searchPathAndIdx) {\n      // prefix ambiguity can only be created from lower idx (higher priority) path\n      return (// ignore (skip) ambiguities with this \"other\" alternative\n        alternation.definition[searchPathAndIdx.idx].ignoreAmbiguities !== true && searchPathAndIdx.idx < targetIdx && // checking for strict prefix because identical lookaheads\n        // will be be detected using a different validation.\n        isStrictPrefixOfPath(searchPathAndIdx.path, targetPath)\n      );\n    });\n    var currPathPrefixErrors = map(prefixAmbiguitiesPathsAndIndices, function (currAmbPathAndIdx) {\n      var ambgIndices = [currAmbPathAndIdx.idx + 1, targetIdx + 1];\n      var occurrence = alternation.idx === 0 ? \"\" : alternation.idx;\n      var message = errMsgProvider.buildAlternationPrefixAmbiguityError({\n        topLevelRule: rule,\n        alternation: alternation,\n        ambiguityIndices: ambgIndices,\n        prefixPath: currAmbPathAndIdx.path\n      });\n      return {\n        message: message,\n        type: ParserDefinitionErrorType.AMBIGUOUS_PREFIX_ALTS,\n        ruleName: rule.name,\n        occurrence: occurrence,\n        alternatives: ambgIndices\n      };\n    });\n    errors = errors.concat(currPathPrefixErrors);\n  });\n  return errors;\n}\n\nfunction checkTerminalAndNoneTerminalsNameSpace(topLevels, tokenTypes, errMsgProvider) {\n  var errors = [];\n  var tokenNames = map(tokenTypes, function (currToken) {\n    return currToken.name;\n  });\n  forEach(topLevels, function (currRule) {\n    var currRuleName = currRule.name;\n\n    if (contains(tokenNames, currRuleName)) {\n      var errMsg = errMsgProvider.buildNamespaceConflictError(currRule);\n      errors.push({\n        message: errMsg,\n        type: ParserDefinitionErrorType.CONFLICT_TOKENS_RULES_NAMESPACE,\n        ruleName: currRuleName\n      });\n    }\n  });\n  return errors;\n}","map":{"version":3,"sources":["../../../../src/parse/grammar/checks.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["var __extends = (this && this.__extends) || (function () {\n    var extendStatics = function (d, b) {\n        extendStatics = Object.setPrototypeOf ||\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\n        return extendStatics(d, b);\n    };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nimport * as utils from \"../../utils/utils\";\nimport { contains, every, findAll, flatten, forEach, isEmpty, map, reduce, reject } from \"../../utils/utils\";\nimport { ParserDefinitionErrorType } from \"../parser/parser\";\nimport { getProductionDslName, isOptionalProd } from \"./gast/gast\";\nimport { containsPath, getLookaheadPathsForOptionalProd, getLookaheadPathsForOr, getProdType, isStrictPrefixOfPath } from \"./lookahead\";\nimport { nextPossibleTokensAfter } from \"./interpreter\";\nimport { Alternation, Alternative as AlternativeGAST, NonTerminal, Option, Repetition, RepetitionMandatory, RepetitionMandatoryWithSeparator, RepetitionWithSeparator, Terminal } from \"./gast/gast_public\";\nimport { GAstVisitor } from \"./gast/gast_visitor_public\";\nexport function validateGrammar(topLevels, globalMaxLookahead, tokenTypes, errMsgProvider, grammarName) {\n    var duplicateErrors = utils.map(topLevels, function (currTopLevel) {\n        return validateDuplicateProductions(currTopLevel, errMsgProvider);\n    });\n    var leftRecursionErrors = utils.map(topLevels, function (currTopRule) {\n        return validateNoLeftRecursion(currTopRule, currTopRule, errMsgProvider);\n    });\n    var emptyAltErrors = [];\n    var ambiguousAltsErrors = [];\n    var emptyRepetitionErrors = [];\n    // left recursion could cause infinite loops in the following validations.\n    // It is safest to first have the user fix the left recursion errors first and only then examine Further issues.\n    if (every(leftRecursionErrors, isEmpty)) {\n        emptyAltErrors = map(topLevels, function (currTopRule) {\n            return validateEmptyOrAlternative(currTopRule, errMsgProvider);\n        });\n        ambiguousAltsErrors = map(topLevels, function (currTopRule) {\n            return validateAmbiguousAlternationAlternatives(currTopRule, globalMaxLookahead, errMsgProvider);\n        });\n        emptyRepetitionErrors = validateSomeNonEmptyLookaheadPath(topLevels, globalMaxLookahead, errMsgProvider);\n    }\n    var termsNamespaceConflictErrors = checkTerminalAndNoneTerminalsNameSpace(topLevels, tokenTypes, errMsgProvider);\n    var tokenNameErrors = utils.map(tokenTypes, function (currTokType) {\n        return validateTokenName(currTokType, errMsgProvider);\n    });\n    var tooManyAltsErrors = map(topLevels, function (curRule) {\n        return validateTooManyAlts(curRule, errMsgProvider);\n    });\n    var ruleNameErrors = map(topLevels, function (curRule) {\n        return validateRuleName(curRule, errMsgProvider);\n    });\n    var duplicateRulesError = map(topLevels, function (curRule) {\n        return validateRuleDoesNotAlreadyExist(curRule, topLevels, grammarName, errMsgProvider);\n    });\n    return (utils.flatten(duplicateErrors.concat(tokenNameErrors, emptyRepetitionErrors, leftRecursionErrors, emptyAltErrors, ambiguousAltsErrors, termsNamespaceConflictErrors, tooManyAltsErrors, ruleNameErrors, duplicateRulesError)));\n}\nfunction validateDuplicateProductions(topLevelRule, errMsgProvider) {\n    var collectorVisitor = new OccurrenceValidationCollector();\n    topLevelRule.accept(collectorVisitor);\n    var allRuleProductions = collectorVisitor.allProductions;\n    var productionGroups = utils.groupBy(allRuleProductions, identifyProductionForDuplicates);\n    var duplicates = utils.pick(productionGroups, function (currGroup) {\n        return currGroup.length > 1;\n    });\n    var errors = utils.map(utils.values(duplicates), function (currDuplicates) {\n        var firstProd = utils.first(currDuplicates);\n        var msg = errMsgProvider.buildDuplicateFoundError(topLevelRule, currDuplicates);\n        var dslName = getProductionDslName(firstProd);\n        var defError = {\n            message: msg,\n            type: ParserDefinitionErrorType.DUPLICATE_PRODUCTIONS,\n            ruleName: topLevelRule.name,\n            dslName: dslName,\n            occurrence: firstProd.idx\n        };\n        var param = getExtraProductionArgument(firstProd);\n        if (param) {\n            defError.parameter = param;\n        }\n        return defError;\n    });\n    return errors;\n}\nexport function identifyProductionForDuplicates(prod) {\n    return getProductionDslName(prod) + \"_#_\" + prod.idx + \"_#_\" + getExtraProductionArgument(prod);\n}\nfunction getExtraProductionArgument(prod) {\n    if (prod instanceof Terminal) {\n        return prod.terminalType.name;\n    }\n    else if (prod instanceof NonTerminal) {\n        return prod.nonTerminalName;\n    }\n    else {\n        return \"\";\n    }\n}\nvar OccurrenceValidationCollector = /** @class */ (function (_super) {\n    __extends(OccurrenceValidationCollector, _super);\n    function OccurrenceValidationCollector() {\n        var _this = _super !== null && _super.apply(this, arguments) || this;\n        _this.allProductions = [];\n        return _this;\n    }\n    OccurrenceValidationCollector.prototype.visitNonTerminal = function (subrule) {\n        this.allProductions.push(subrule);\n    };\n    OccurrenceValidationCollector.prototype.visitOption = function (option) {\n        this.allProductions.push(option);\n    };\n    OccurrenceValidationCollector.prototype.visitRepetitionWithSeparator = function (manySep) {\n        this.allProductions.push(manySep);\n    };\n    OccurrenceValidationCollector.prototype.visitRepetitionMandatory = function (atLeastOne) {\n        this.allProductions.push(atLeastOne);\n    };\n    OccurrenceValidationCollector.prototype.visitRepetitionMandatoryWithSeparator = function (atLeastOneSep) {\n        this.allProductions.push(atLeastOneSep);\n    };\n    OccurrenceValidationCollector.prototype.visitRepetition = function (many) {\n        this.allProductions.push(many);\n    };\n    OccurrenceValidationCollector.prototype.visitAlternation = function (or) {\n        this.allProductions.push(or);\n    };\n    OccurrenceValidationCollector.prototype.visitTerminal = function (terminal) {\n        this.allProductions.push(terminal);\n    };\n    return OccurrenceValidationCollector;\n}(GAstVisitor));\nexport { OccurrenceValidationCollector };\nexport var validTermsPattern = /^[a-zA-Z_]\\w*$/;\n// TODO: remove this limitation now that we use recorders\nexport function validateRuleName(rule, errMsgProvider) {\n    var errors = [];\n    var ruleName = rule.name;\n    if (!ruleName.match(validTermsPattern)) {\n        errors.push({\n            message: errMsgProvider.buildInvalidRuleNameError({\n                topLevelRule: rule,\n                expectedPattern: validTermsPattern\n            }),\n            type: ParserDefinitionErrorType.INVALID_RULE_NAME,\n            ruleName: ruleName\n        });\n    }\n    return errors;\n}\n// TODO: remove this limitation now that we use recorders\nexport function validateTokenName(tokenType, errMsgProvider) {\n    var errors = [];\n    var tokTypeName = tokenType.name;\n    if (!tokTypeName.match(validTermsPattern)) {\n        errors.push({\n            message: errMsgProvider.buildTokenNameError({\n                tokenType: tokenType,\n                expectedPattern: validTermsPattern\n            }),\n            type: ParserDefinitionErrorType.INVALID_TOKEN_NAME\n        });\n    }\n    return errors;\n}\nexport function validateRuleDoesNotAlreadyExist(rule, allRules, className, errMsgProvider) {\n    var errors = [];\n    var occurrences = reduce(allRules, function (result, curRule) {\n        if (curRule.name === rule.name) {\n            return result + 1;\n        }\n        return result;\n    }, 0);\n    if (occurrences > 1) {\n        var errMsg = errMsgProvider.buildDuplicateRuleNameError({\n            topLevelRule: rule,\n            grammarName: className\n        });\n        errors.push({\n            message: errMsg,\n            type: ParserDefinitionErrorType.DUPLICATE_RULE_NAME,\n            ruleName: rule.name\n        });\n    }\n    return errors;\n}\n// TODO: is there anyway to get only the rule names of rules inherited from the super grammars?\n// This is not part of the IGrammarErrorProvider because the validation cannot be performed on\n// The grammar structure, only at runtime.\nexport function validateRuleIsOverridden(ruleName, definedRulesNames, className) {\n    var errors = [];\n    var errMsg;\n    if (!utils.contains(definedRulesNames, ruleName)) {\n        errMsg =\n            \"Invalid rule override, rule: ->\" + ruleName + \"<- cannot be overridden in the grammar: ->\" + className + \"<-\" +\n                \"as it is not defined in any of the super grammars \";\n        errors.push({\n            message: errMsg,\n            type: ParserDefinitionErrorType.INVALID_RULE_OVERRIDE,\n            ruleName: ruleName\n        });\n    }\n    return errors;\n}\nexport function validateNoLeftRecursion(topRule, currRule, errMsgProvider, path) {\n    if (path === void 0) { path = []; }\n    var errors = [];\n    var nextNonTerminals = getFirstNoneTerminal(currRule.definition);\n    if (utils.isEmpty(nextNonTerminals)) {\n        return [];\n    }\n    else {\n        var ruleName = topRule.name;\n        var foundLeftRecursion = utils.contains(nextNonTerminals, topRule);\n        if (foundLeftRecursion) {\n            errors.push({\n                message: errMsgProvider.buildLeftRecursionError({\n                    topLevelRule: topRule,\n                    leftRecursionPath: path\n                }),\n                type: ParserDefinitionErrorType.LEFT_RECURSION,\n                ruleName: ruleName\n            });\n        }\n        // we are only looking for cyclic paths leading back to the specific topRule\n        // other cyclic paths are ignored, we still need this difference to avoid infinite loops...\n        var validNextSteps = utils.difference(nextNonTerminals, path.concat([topRule]));\n        var errorsFromNextSteps = utils.map(validNextSteps, function (currRefRule) {\n            var newPath = utils.cloneArr(path);\n            newPath.push(currRefRule);\n            return validateNoLeftRecursion(topRule, currRefRule, errMsgProvider, newPath);\n        });\n        return errors.concat(utils.flatten(errorsFromNextSteps));\n    }\n}\nexport function getFirstNoneTerminal(definition) {\n    var result = [];\n    if (utils.isEmpty(definition)) {\n        return result;\n    }\n    var firstProd = utils.first(definition);\n    /* istanbul ignore else */\n    if (firstProd instanceof NonTerminal) {\n        result.push(firstProd.referencedRule);\n    }\n    else if (firstProd instanceof AlternativeGAST ||\n        firstProd instanceof Option ||\n        firstProd instanceof RepetitionMandatory ||\n        firstProd instanceof RepetitionMandatoryWithSeparator ||\n        firstProd instanceof RepetitionWithSeparator ||\n        firstProd instanceof Repetition) {\n        result = result.concat(getFirstNoneTerminal(firstProd.definition));\n    }\n    else if (firstProd instanceof Alternation) {\n        // each sub definition in alternation is a FLAT\n        result = utils.flatten(utils.map(firstProd.definition, function (currSubDef) {\n            return getFirstNoneTerminal(currSubDef.definition);\n        }));\n    }\n    else if (firstProd instanceof Terminal) {\n        // nothing to see, move along\n    }\n    else {\n        throw Error(\"non exhaustive match\");\n    }\n    var isFirstOptional = isOptionalProd(firstProd);\n    var hasMore = definition.length > 1;\n    if (isFirstOptional && hasMore) {\n        var rest = utils.drop(definition);\n        return result.concat(getFirstNoneTerminal(rest));\n    }\n    else {\n        return result;\n    }\n}\nvar OrCollector = /** @class */ (function (_super) {\n    __extends(OrCollector, _super);\n    function OrCollector() {\n        var _this = _super !== null && _super.apply(this, arguments) || this;\n        _this.alternations = [];\n        return _this;\n    }\n    OrCollector.prototype.visitAlternation = function (node) {\n        this.alternations.push(node);\n    };\n    return OrCollector;\n}(GAstVisitor));\nexport function validateEmptyOrAlternative(topLevelRule, errMsgProvider) {\n    var orCollector = new OrCollector();\n    topLevelRule.accept(orCollector);\n    var ors = orCollector.alternations;\n    var errors = utils.reduce(ors, function (errors, currOr) {\n        var exceptLast = utils.dropRight(currOr.definition);\n        var currErrors = utils.map(exceptLast, function (currAlternative, currAltIdx) {\n            var possibleFirstInAlt = nextPossibleTokensAfter([currAlternative], [], null, 1);\n            if (utils.isEmpty(possibleFirstInAlt)) {\n                return {\n                    message: errMsgProvider.buildEmptyAlternationError({\n                        topLevelRule: topLevelRule,\n                        alternation: currOr,\n                        emptyChoiceIdx: currAltIdx\n                    }),\n                    type: ParserDefinitionErrorType.NONE_LAST_EMPTY_ALT,\n                    ruleName: topLevelRule.name,\n                    occurrence: currOr.idx,\n                    alternative: currAltIdx + 1\n                };\n            }\n            else {\n                return null;\n            }\n        });\n        return errors.concat(utils.compact(currErrors));\n    }, []);\n    return errors;\n}\nexport function validateAmbiguousAlternationAlternatives(topLevelRule, globalMaxLookahead, errMsgProvider) {\n    var orCollector = new OrCollector();\n    topLevelRule.accept(orCollector);\n    var ors = orCollector.alternations;\n    // New Handling of ignoring ambiguities\n    // - https://github.com/SAP/chevrotain/issues/869\n    ors = reject(ors, function (currOr) { return currOr.ignoreAmbiguities === true; });\n    var errors = utils.reduce(ors, function (result, currOr) {\n        var currOccurrence = currOr.idx;\n        var actualMaxLookahead = currOr.maxLookahead || globalMaxLookahead;\n        var alternatives = getLookaheadPathsForOr(currOccurrence, topLevelRule, actualMaxLookahead, currOr);\n        var altsAmbiguityErrors = checkAlternativesAmbiguities(alternatives, currOr, topLevelRule, errMsgProvider);\n        var altsPrefixAmbiguityErrors = checkPrefixAlternativesAmbiguities(alternatives, currOr, topLevelRule, errMsgProvider);\n        return result.concat(altsAmbiguityErrors, altsPrefixAmbiguityErrors);\n    }, []);\n    return errors;\n}\nvar RepetionCollector = /** @class */ (function (_super) {\n    __extends(RepetionCollector, _super);\n    function RepetionCollector() {\n        var _this = _super !== null && _super.apply(this, arguments) || this;\n        _this.allProductions = [];\n        return _this;\n    }\n    RepetionCollector.prototype.visitRepetitionWithSeparator = function (manySep) {\n        this.allProductions.push(manySep);\n    };\n    RepetionCollector.prototype.visitRepetitionMandatory = function (atLeastOne) {\n        this.allProductions.push(atLeastOne);\n    };\n    RepetionCollector.prototype.visitRepetitionMandatoryWithSeparator = function (atLeastOneSep) {\n        this.allProductions.push(atLeastOneSep);\n    };\n    RepetionCollector.prototype.visitRepetition = function (many) {\n        this.allProductions.push(many);\n    };\n    return RepetionCollector;\n}(GAstVisitor));\nexport { RepetionCollector };\nexport function validateTooManyAlts(topLevelRule, errMsgProvider) {\n    var orCollector = new OrCollector();\n    topLevelRule.accept(orCollector);\n    var ors = orCollector.alternations;\n    var errors = utils.reduce(ors, function (errors, currOr) {\n        if (currOr.definition.length > 255) {\n            errors.push({\n                message: errMsgProvider.buildTooManyAlternativesError({\n                    topLevelRule: topLevelRule,\n                    alternation: currOr\n                }),\n                type: ParserDefinitionErrorType.TOO_MANY_ALTS,\n                ruleName: topLevelRule.name,\n                occurrence: currOr.idx\n            });\n        }\n        return errors;\n    }, []);\n    return errors;\n}\nexport function validateSomeNonEmptyLookaheadPath(topLevelRules, maxLookahead, errMsgProvider) {\n    var errors = [];\n    forEach(topLevelRules, function (currTopRule) {\n        var collectorVisitor = new RepetionCollector();\n        currTopRule.accept(collectorVisitor);\n        var allRuleProductions = collectorVisitor.allProductions;\n        forEach(allRuleProductions, function (currProd) {\n            var prodType = getProdType(currProd);\n            var actualMaxLookahead = currProd.maxLookahead || maxLookahead;\n            var currOccurrence = currProd.idx;\n            var paths = getLookaheadPathsForOptionalProd(currOccurrence, currTopRule, prodType, actualMaxLookahead);\n            var pathsInsideProduction = paths[0];\n            if (isEmpty(flatten(pathsInsideProduction))) {\n                var errMsg = errMsgProvider.buildEmptyRepetitionError({\n                    topLevelRule: currTopRule,\n                    repetition: currProd\n                });\n                errors.push({\n                    message: errMsg,\n                    type: ParserDefinitionErrorType.NO_NON_EMPTY_LOOKAHEAD,\n                    ruleName: currTopRule.name\n                });\n            }\n        });\n    });\n    return errors;\n}\nfunction checkAlternativesAmbiguities(alternatives, alternation, rule, errMsgProvider) {\n    var foundAmbiguousPaths = [];\n    var identicalAmbiguities = reduce(alternatives, function (result, currAlt, currAltIdx) {\n        // ignore (skip) ambiguities with this alternative\n        if (alternation.definition[currAltIdx].ignoreAmbiguities === true) {\n            return result;\n        }\n        forEach(currAlt, function (currPath) {\n            var altsCurrPathAppearsIn = [currAltIdx];\n            forEach(alternatives, function (currOtherAlt, currOtherAltIdx) {\n                if (currAltIdx !== currOtherAltIdx &&\n                    containsPath(currOtherAlt, currPath) &&\n                    // ignore (skip) ambiguities with this \"other\" alternative\n                    alternation.definition[currOtherAltIdx].ignoreAmbiguities !== true) {\n                    altsCurrPathAppearsIn.push(currOtherAltIdx);\n                }\n            });\n            if (altsCurrPathAppearsIn.length > 1 &&\n                !containsPath(foundAmbiguousPaths, currPath)) {\n                foundAmbiguousPaths.push(currPath);\n                result.push({\n                    alts: altsCurrPathAppearsIn,\n                    path: currPath\n                });\n            }\n        });\n        return result;\n    }, []);\n    var currErrors = utils.map(identicalAmbiguities, function (currAmbDescriptor) {\n        var ambgIndices = map(currAmbDescriptor.alts, function (currAltIdx) { return currAltIdx + 1; });\n        var currMessage = errMsgProvider.buildAlternationAmbiguityError({\n            topLevelRule: rule,\n            alternation: alternation,\n            ambiguityIndices: ambgIndices,\n            prefixPath: currAmbDescriptor.path\n        });\n        return {\n            message: currMessage,\n            type: ParserDefinitionErrorType.AMBIGUOUS_ALTS,\n            ruleName: rule.name,\n            occurrence: alternation.idx,\n            alternatives: [currAmbDescriptor.alts]\n        };\n    });\n    return currErrors;\n}\nexport function checkPrefixAlternativesAmbiguities(alternatives, alternation, rule, errMsgProvider) {\n    var errors = [];\n    // flatten\n    var pathsAndIndices = reduce(alternatives, function (result, currAlt, idx) {\n        var currPathsAndIdx = map(currAlt, function (currPath) {\n            return { idx: idx, path: currPath };\n        });\n        return result.concat(currPathsAndIdx);\n    }, []);\n    forEach(pathsAndIndices, function (currPathAndIdx) {\n        var alternativeGast = alternation.definition[currPathAndIdx.idx];\n        // ignore (skip) ambiguities with this alternative\n        if (alternativeGast.ignoreAmbiguities === true) {\n            return;\n        }\n        var targetIdx = currPathAndIdx.idx;\n        var targetPath = currPathAndIdx.path;\n        var prefixAmbiguitiesPathsAndIndices = findAll(pathsAndIndices, function (searchPathAndIdx) {\n            // prefix ambiguity can only be created from lower idx (higher priority) path\n            return (\n            // ignore (skip) ambiguities with this \"other\" alternative\n            alternation.definition[searchPathAndIdx.idx].ignoreAmbiguities !==\n                true &&\n                searchPathAndIdx.idx < targetIdx &&\n                // checking for strict prefix because identical lookaheads\n                // will be be detected using a different validation.\n                isStrictPrefixOfPath(searchPathAndIdx.path, targetPath));\n        });\n        var currPathPrefixErrors = map(prefixAmbiguitiesPathsAndIndices, function (currAmbPathAndIdx) {\n            var ambgIndices = [currAmbPathAndIdx.idx + 1, targetIdx + 1];\n            var occurrence = alternation.idx === 0 ? \"\" : alternation.idx;\n            var message = errMsgProvider.buildAlternationPrefixAmbiguityError({\n                topLevelRule: rule,\n                alternation: alternation,\n                ambiguityIndices: ambgIndices,\n                prefixPath: currAmbPathAndIdx.path\n            });\n            return {\n                message: message,\n                type: ParserDefinitionErrorType.AMBIGUOUS_PREFIX_ALTS,\n                ruleName: rule.name,\n                occurrence: occurrence,\n                alternatives: ambgIndices\n            };\n        });\n        errors = errors.concat(currPathPrefixErrors);\n    });\n    return errors;\n}\nfunction checkTerminalAndNoneTerminalsNameSpace(topLevels, tokenTypes, errMsgProvider) {\n    var errors = [];\n    var tokenNames = map(tokenTypes, function (currToken) { return currToken.name; });\n    forEach(topLevels, function (currRule) {\n        var currRuleName = currRule.name;\n        if (contains(tokenNames, currRuleName)) {\n            var errMsg = errMsgProvider.buildNamespaceConflictError(currRule);\n            errors.push({\n                message: errMsg,\n                type: ParserDefinitionErrorType.CONFLICT_TOKENS_RULES_NAMESPACE,\n                ruleName: currRuleName\n            });\n        }\n    });\n    return errors;\n}\n//# sourceMappingURL=checks.js.map"]},"metadata":{},"sourceType":"module"}