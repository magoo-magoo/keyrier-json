{"ast":null,"code":";\n\n(function (root, factory) {\n  // istanbul ignore next\n  if (typeof define === \"function\" && define.amd) {\n    // istanbul ignore next\n    define([], factory);\n  } else if (typeof module === \"object\" && module.exports) {\n    module.exports = factory();\n  } else {\n    // istanbul ignore next\n    root.regexpToAst = factory();\n  }\n})(typeof self !== \"undefined\" ? // istanbul ignore next\nself : this, function () {\n  // references\n  // https://hackernoon.com/the-madness-of-parsing-real-world-javascript-regexps-d9ee336df983\n  // https://www.ecma-international.org/ecma-262/8.0/index.html#prod-Pattern\n  function RegExpParser() {}\n\n  RegExpParser.prototype.saveState = function () {\n    return {\n      idx: this.idx,\n      input: this.input,\n      groupIdx: this.groupIdx\n    };\n  };\n\n  RegExpParser.prototype.restoreState = function (newState) {\n    this.idx = newState.idx;\n    this.input = newState.input;\n    this.groupIdx = newState.groupIdx;\n  };\n\n  RegExpParser.prototype.pattern = function (input) {\n    // parser state\n    this.idx = 0;\n    this.input = input;\n    this.groupIdx = 0;\n    this.consumeChar(\"/\");\n    var value = this.disjunction();\n    this.consumeChar(\"/\");\n    var flags = {\n      type: \"Flags\",\n      loc: {\n        begin: this.idx,\n        end: input.length\n      },\n      global: false,\n      ignoreCase: false,\n      multiLine: false,\n      unicode: false,\n      sticky: false\n    };\n\n    while (this.isRegExpFlag()) {\n      switch (this.popChar()) {\n        case \"g\":\n          addFlag(flags, \"global\");\n          break;\n\n        case \"i\":\n          addFlag(flags, \"ignoreCase\");\n          break;\n\n        case \"m\":\n          addFlag(flags, \"multiLine\");\n          break;\n\n        case \"u\":\n          addFlag(flags, \"unicode\");\n          break;\n\n        case \"y\":\n          addFlag(flags, \"sticky\");\n          break;\n      }\n    }\n\n    if (this.idx !== this.input.length) {\n      throw Error(\"Redundant input: \" + this.input.substring(this.idx));\n    }\n\n    return {\n      type: \"Pattern\",\n      flags: flags,\n      value: value,\n      loc: this.loc(0)\n    };\n  };\n\n  RegExpParser.prototype.disjunction = function () {\n    var alts = [];\n    var begin = this.idx;\n    alts.push(this.alternative());\n\n    while (this.peekChar() === \"|\") {\n      this.consumeChar(\"|\");\n      alts.push(this.alternative());\n    }\n\n    return {\n      type: \"Disjunction\",\n      value: alts,\n      loc: this.loc(begin)\n    };\n  };\n\n  RegExpParser.prototype.alternative = function () {\n    var terms = [];\n    var begin = this.idx;\n\n    while (this.isTerm()) {\n      terms.push(this.term());\n    }\n\n    return {\n      type: \"Alternative\",\n      value: terms,\n      loc: this.loc(begin)\n    };\n  };\n\n  RegExpParser.prototype.term = function () {\n    if (this.isAssertion()) {\n      return this.assertion();\n    } else {\n      return this.atom();\n    }\n  };\n\n  RegExpParser.prototype.assertion = function () {\n    var begin = this.idx;\n\n    switch (this.popChar()) {\n      case \"^\":\n        return {\n          type: \"StartAnchor\",\n          loc: this.loc(begin)\n        };\n\n      case \"$\":\n        return {\n          type: \"EndAnchor\",\n          loc: this.loc(begin)\n        };\n      // '\\b' or '\\B'\n\n      case \"\\\\\":\n        switch (this.popChar()) {\n          case \"b\":\n            return {\n              type: \"WordBoundary\",\n              loc: this.loc(begin)\n            };\n\n          case \"B\":\n            return {\n              type: \"NonWordBoundary\",\n              loc: this.loc(begin)\n            };\n        } // istanbul ignore next\n\n\n        throw Error(\"Invalid Assertion Escape\");\n      // '(?=' or '(?!'\n\n      case \"(\":\n        this.consumeChar(\"?\");\n        var type;\n\n        switch (this.popChar()) {\n          case \"=\":\n            type = \"Lookahead\";\n            break;\n\n          case \"!\":\n            type = \"NegativeLookahead\";\n            break;\n        }\n\n        ASSERT_EXISTS(type);\n        var disjunction = this.disjunction();\n        this.consumeChar(\")\");\n        return {\n          type: type,\n          value: disjunction,\n          loc: this.loc(begin)\n        };\n    } // istanbul ignore next\n\n\n    ASSERT_NEVER_REACH_HERE();\n  };\n\n  RegExpParser.prototype.quantifier = function (isBacktracking) {\n    var range;\n    var begin = this.idx;\n\n    switch (this.popChar()) {\n      case \"*\":\n        range = {\n          atLeast: 0,\n          atMost: Infinity\n        };\n        break;\n\n      case \"+\":\n        range = {\n          atLeast: 1,\n          atMost: Infinity\n        };\n        break;\n\n      case \"?\":\n        range = {\n          atLeast: 0,\n          atMost: 1\n        };\n        break;\n\n      case \"{\":\n        var atLeast = this.integerIncludingZero();\n\n        switch (this.popChar()) {\n          case \"}\":\n            range = {\n              atLeast: atLeast,\n              atMost: atLeast\n            };\n            break;\n\n          case \",\":\n            var atMost;\n\n            if (this.isDigit()) {\n              atMost = this.integerIncludingZero();\n              range = {\n                atLeast: atLeast,\n                atMost: atMost\n              };\n            } else {\n              range = {\n                atLeast: atLeast,\n                atMost: Infinity\n              };\n            }\n\n            this.consumeChar(\"}\");\n            break;\n        } // throwing exceptions from \"ASSERT_EXISTS\" during backtracking\n        // causes severe performance degradations\n\n\n        if (isBacktracking === true && range === undefined) {\n          return undefined;\n        }\n\n        ASSERT_EXISTS(range);\n        break;\n    } // throwing exceptions from \"ASSERT_EXISTS\" during backtracking\n    // causes severe performance degradations\n\n\n    if (isBacktracking === true && range === undefined) {\n      return undefined;\n    }\n\n    ASSERT_EXISTS(range);\n\n    if (this.peekChar(0) === \"?\") {\n      this.consumeChar(\"?\");\n      range.greedy = false;\n    } else {\n      range.greedy = true;\n    }\n\n    range.type = \"Quantifier\";\n    range.loc = this.loc(begin);\n    return range;\n  };\n\n  RegExpParser.prototype.atom = function () {\n    var atom;\n    var begin = this.idx;\n\n    switch (this.peekChar()) {\n      case \".\":\n        atom = this.dotAll();\n        break;\n\n      case \"\\\\\":\n        atom = this.atomEscape();\n        break;\n\n      case \"[\":\n        atom = this.characterClass();\n        break;\n\n      case \"(\":\n        atom = this.group();\n        break;\n    }\n\n    if (atom === undefined && this.isPatternCharacter()) {\n      atom = this.patternCharacter();\n    }\n\n    ASSERT_EXISTS(atom);\n    atom.loc = this.loc(begin);\n\n    if (this.isQuantifier()) {\n      atom.quantifier = this.quantifier();\n    }\n\n    return atom;\n  };\n\n  RegExpParser.prototype.dotAll = function () {\n    this.consumeChar(\".\");\n    return {\n      type: \"Set\",\n      complement: true,\n      value: [cc(\"\\n\"), cc(\"\\r\"), cc(\"\\u2028\"), cc(\"\\u2029\")]\n    };\n  };\n\n  RegExpParser.prototype.atomEscape = function () {\n    this.consumeChar(\"\\\\\");\n\n    switch (this.peekChar()) {\n      case \"1\":\n      case \"2\":\n      case \"3\":\n      case \"4\":\n      case \"5\":\n      case \"6\":\n      case \"7\":\n      case \"8\":\n      case \"9\":\n        return this.decimalEscapeAtom();\n\n      case \"d\":\n      case \"D\":\n      case \"s\":\n      case \"S\":\n      case \"w\":\n      case \"W\":\n        return this.characterClassEscape();\n\n      case \"f\":\n      case \"n\":\n      case \"r\":\n      case \"t\":\n      case \"v\":\n        return this.controlEscapeAtom();\n\n      case \"c\":\n        return this.controlLetterEscapeAtom();\n\n      case \"0\":\n        return this.nulCharacterAtom();\n\n      case \"x\":\n        return this.hexEscapeSequenceAtom();\n\n      case \"u\":\n        return this.regExpUnicodeEscapeSequenceAtom();\n\n      default:\n        return this.identityEscapeAtom();\n    }\n  };\n\n  RegExpParser.prototype.decimalEscapeAtom = function () {\n    var value = this.positiveInteger();\n    return {\n      type: \"GroupBackReference\",\n      value: value\n    };\n  };\n\n  RegExpParser.prototype.characterClassEscape = function () {\n    var set;\n    var complement = false;\n\n    switch (this.popChar()) {\n      case \"d\":\n        set = digitsCharCodes;\n        break;\n\n      case \"D\":\n        set = digitsCharCodes;\n        complement = true;\n        break;\n\n      case \"s\":\n        set = whitespaceCodes;\n        break;\n\n      case \"S\":\n        set = whitespaceCodes;\n        complement = true;\n        break;\n\n      case \"w\":\n        set = wordCharCodes;\n        break;\n\n      case \"W\":\n        set = wordCharCodes;\n        complement = true;\n        break;\n    }\n\n    ASSERT_EXISTS(set);\n    return {\n      type: \"Set\",\n      value: set,\n      complement: complement\n    };\n  };\n\n  RegExpParser.prototype.controlEscapeAtom = function () {\n    var escapeCode;\n\n    switch (this.popChar()) {\n      case \"f\":\n        escapeCode = cc(\"\\f\");\n        break;\n\n      case \"n\":\n        escapeCode = cc(\"\\n\");\n        break;\n\n      case \"r\":\n        escapeCode = cc(\"\\r\");\n        break;\n\n      case \"t\":\n        escapeCode = cc(\"\\t\");\n        break;\n\n      case \"v\":\n        escapeCode = cc(\"\\v\");\n        break;\n    }\n\n    ASSERT_EXISTS(escapeCode);\n    return {\n      type: \"Character\",\n      value: escapeCode\n    };\n  };\n\n  RegExpParser.prototype.controlLetterEscapeAtom = function () {\n    this.consumeChar(\"c\");\n    var letter = this.popChar();\n\n    if (/[a-zA-Z]/.test(letter) === false) {\n      throw Error(\"Invalid \");\n    }\n\n    var letterCode = letter.toUpperCase().charCodeAt(0) - 64;\n    return {\n      type: \"Character\",\n      value: letterCode\n    };\n  };\n\n  RegExpParser.prototype.nulCharacterAtom = function () {\n    // TODO implement '[lookahead âˆ‰ DecimalDigit]'\n    // TODO: for the deprecated octal escape sequence\n    this.consumeChar(\"0\");\n    return {\n      type: \"Character\",\n      value: cc(\"\\0\")\n    };\n  };\n\n  RegExpParser.prototype.hexEscapeSequenceAtom = function () {\n    this.consumeChar(\"x\");\n    return this.parseHexDigits(2);\n  };\n\n  RegExpParser.prototype.regExpUnicodeEscapeSequenceAtom = function () {\n    this.consumeChar(\"u\");\n    return this.parseHexDigits(4);\n  };\n\n  RegExpParser.prototype.identityEscapeAtom = function () {\n    // TODO: implement \"SourceCharacter but not UnicodeIDContinue\"\n    // // http://unicode.org/reports/tr31/#Specific_Character_Adjustments\n    var escapedChar = this.popChar();\n    return {\n      type: \"Character\",\n      value: cc(escapedChar)\n    };\n  };\n\n  RegExpParser.prototype.classPatternCharacterAtom = function () {\n    switch (this.peekChar()) {\n      // istanbul ignore next\n      case \"\\n\": // istanbul ignore next\n\n      case \"\\r\": // istanbul ignore next\n\n      case \"\\u2028\": // istanbul ignore next\n\n      case \"\\u2029\": // istanbul ignore next\n\n      case \"\\\\\": // istanbul ignore next\n\n      case \"]\":\n        throw Error(\"TBD\");\n\n      default:\n        var nextChar = this.popChar();\n        return {\n          type: \"Character\",\n          value: cc(nextChar)\n        };\n    }\n  };\n\n  RegExpParser.prototype.characterClass = function () {\n    var set = [];\n    var complement = false;\n    this.consumeChar(\"[\");\n\n    if (this.peekChar(0) === \"^\") {\n      this.consumeChar(\"^\");\n      complement = true;\n    }\n\n    while (this.isClassAtom()) {\n      var from = this.classAtom();\n      var isFromSingleChar = from.type === \"Character\";\n\n      if (isFromSingleChar && this.isRangeDash()) {\n        this.consumeChar(\"-\");\n        var to = this.classAtom();\n        var isToSingleChar = to.type === \"Character\"; // a range can only be used when both sides are single characters\n\n        if (isToSingleChar) {\n          if (to.value < from.value) {\n            throw Error(\"Range out of order in character class\");\n          }\n\n          set.push({\n            from: from.value,\n            to: to.value\n          });\n        } else {\n          // literal dash\n          insertToSet(from.value, set);\n          set.push(cc(\"-\"));\n          insertToSet(to.value, set);\n        }\n      } else {\n        insertToSet(from.value, set);\n      }\n    }\n\n    this.consumeChar(\"]\");\n    return {\n      type: \"Set\",\n      complement: complement,\n      value: set\n    };\n  };\n\n  RegExpParser.prototype.classAtom = function () {\n    switch (this.peekChar()) {\n      // istanbul ignore next\n      case \"]\": // istanbul ignore next\n\n      case \"\\n\": // istanbul ignore next\n\n      case \"\\r\": // istanbul ignore next\n\n      case \"\\u2028\": // istanbul ignore next\n\n      case \"\\u2029\":\n        throw Error(\"TBD\");\n\n      case \"\\\\\":\n        return this.classEscape();\n\n      default:\n        return this.classPatternCharacterAtom();\n    }\n  };\n\n  RegExpParser.prototype.classEscape = function () {\n    this.consumeChar(\"\\\\\");\n\n    switch (this.peekChar()) {\n      // Matches a backspace.\n      // (Not to be confused with \\b word boundary outside characterClass)\n      case \"b\":\n        this.consumeChar(\"b\");\n        return {\n          type: \"Character\",\n          value: cc(\"\\u0008\")\n        };\n\n      case \"d\":\n      case \"D\":\n      case \"s\":\n      case \"S\":\n      case \"w\":\n      case \"W\":\n        return this.characterClassEscape();\n\n      case \"f\":\n      case \"n\":\n      case \"r\":\n      case \"t\":\n      case \"v\":\n        return this.controlEscapeAtom();\n\n      case \"c\":\n        return this.controlLetterEscapeAtom();\n\n      case \"0\":\n        return this.nulCharacterAtom();\n\n      case \"x\":\n        return this.hexEscapeSequenceAtom();\n\n      case \"u\":\n        return this.regExpUnicodeEscapeSequenceAtom();\n\n      default:\n        return this.identityEscapeAtom();\n    }\n  };\n\n  RegExpParser.prototype.group = function () {\n    var capturing = true;\n    this.consumeChar(\"(\");\n\n    switch (this.peekChar(0)) {\n      case \"?\":\n        this.consumeChar(\"?\");\n        this.consumeChar(\":\");\n        capturing = false;\n        break;\n\n      default:\n        this.groupIdx++;\n        break;\n    }\n\n    var value = this.disjunction();\n    this.consumeChar(\")\");\n    var groupAst = {\n      type: \"Group\",\n      capturing: capturing,\n      value: value\n    };\n\n    if (capturing) {\n      groupAst.idx = this.groupIdx;\n    }\n\n    return groupAst;\n  };\n\n  RegExpParser.prototype.positiveInteger = function () {\n    var number = this.popChar(); // istanbul ignore next - can't ever get here due to previous lookahead checks\n    // still implementing this error checking in case this ever changes.\n\n    if (decimalPatternNoZero.test(number) === false) {\n      throw Error(\"Expecting a positive integer\");\n    }\n\n    while (decimalPattern.test(this.peekChar(0))) {\n      number += this.popChar();\n    }\n\n    return parseInt(number, 10);\n  };\n\n  RegExpParser.prototype.integerIncludingZero = function () {\n    var number = this.popChar();\n\n    if (decimalPattern.test(number) === false) {\n      throw Error(\"Expecting an integer\");\n    }\n\n    while (decimalPattern.test(this.peekChar(0))) {\n      number += this.popChar();\n    }\n\n    return parseInt(number, 10);\n  };\n\n  RegExpParser.prototype.patternCharacter = function () {\n    var nextChar = this.popChar();\n\n    switch (nextChar) {\n      // istanbul ignore next\n      case \"\\n\": // istanbul ignore next\n\n      case \"\\r\": // istanbul ignore next\n\n      case \"\\u2028\": // istanbul ignore next\n\n      case \"\\u2029\": // istanbul ignore next\n\n      case \"^\": // istanbul ignore next\n\n      case \"$\": // istanbul ignore next\n\n      case \"\\\\\": // istanbul ignore next\n\n      case \".\": // istanbul ignore next\n\n      case \"*\": // istanbul ignore next\n\n      case \"+\": // istanbul ignore next\n\n      case \"?\": // istanbul ignore next\n\n      case \"(\": // istanbul ignore next\n\n      case \")\": // istanbul ignore next\n\n      case \"[\": // istanbul ignore next\n\n      case \"|\":\n        // istanbul ignore next\n        throw Error(\"TBD\");\n\n      default:\n        return {\n          type: \"Character\",\n          value: cc(nextChar)\n        };\n    }\n  };\n\n  RegExpParser.prototype.isRegExpFlag = function () {\n    switch (this.peekChar(0)) {\n      case \"g\":\n      case \"i\":\n      case \"m\":\n      case \"u\":\n      case \"y\":\n        return true;\n\n      default:\n        return false;\n    }\n  };\n\n  RegExpParser.prototype.isRangeDash = function () {\n    return this.peekChar() === \"-\" && this.isClassAtom(1);\n  };\n\n  RegExpParser.prototype.isDigit = function () {\n    return decimalPattern.test(this.peekChar(0));\n  };\n\n  RegExpParser.prototype.isClassAtom = function (howMuch) {\n    if (howMuch === undefined) {\n      howMuch = 0;\n    }\n\n    switch (this.peekChar(howMuch)) {\n      case \"]\":\n      case \"\\n\":\n      case \"\\r\":\n      case \"\\u2028\":\n      case \"\\u2029\":\n        return false;\n\n      default:\n        return true;\n    }\n  };\n\n  RegExpParser.prototype.isTerm = function () {\n    return this.isAtom() || this.isAssertion();\n  };\n\n  RegExpParser.prototype.isAtom = function () {\n    if (this.isPatternCharacter()) {\n      return true;\n    }\n\n    switch (this.peekChar(0)) {\n      case \".\":\n      case \"\\\\\": // atomEscape\n\n      case \"[\": // characterClass\n      // TODO: isAtom must be called before isAssertion - disambiguate\n\n      case \"(\":\n        // group\n        return true;\n\n      default:\n        return false;\n    }\n  };\n\n  RegExpParser.prototype.isAssertion = function () {\n    switch (this.peekChar(0)) {\n      case \"^\":\n      case \"$\":\n        return true;\n      // '\\b' or '\\B'\n\n      case \"\\\\\":\n        switch (this.peekChar(1)) {\n          case \"b\":\n          case \"B\":\n            return true;\n\n          default:\n            return false;\n        }\n\n      // '(?=' or '(?!'\n\n      case \"(\":\n        return this.peekChar(1) === \"?\" && (this.peekChar(2) === \"=\" || this.peekChar(2) === \"!\");\n\n      default:\n        return false;\n    }\n  };\n\n  RegExpParser.prototype.isQuantifier = function () {\n    var prevState = this.saveState();\n\n    try {\n      return this.quantifier(true) !== undefined;\n    } catch (e) {\n      return false;\n    } finally {\n      this.restoreState(prevState);\n    }\n  };\n\n  RegExpParser.prototype.isPatternCharacter = function () {\n    switch (this.peekChar()) {\n      case \"^\":\n      case \"$\":\n      case \"\\\\\":\n      case \".\":\n      case \"*\":\n      case \"+\":\n      case \"?\":\n      case \"(\":\n      case \")\":\n      case \"[\":\n      case \"|\":\n      case \"/\":\n      case \"\\n\":\n      case \"\\r\":\n      case \"\\u2028\":\n      case \"\\u2029\":\n        return false;\n\n      default:\n        return true;\n    }\n  };\n\n  RegExpParser.prototype.parseHexDigits = function (howMany) {\n    var hexString = \"\";\n\n    for (var i = 0; i < howMany; i++) {\n      var hexChar = this.popChar();\n\n      if (hexDigitPattern.test(hexChar) === false) {\n        throw Error(\"Expecting a HexDecimal digits\");\n      }\n\n      hexString += hexChar;\n    }\n\n    var charCode = parseInt(hexString, 16);\n    return {\n      type: \"Character\",\n      value: charCode\n    };\n  };\n\n  RegExpParser.prototype.peekChar = function (howMuch) {\n    if (howMuch === undefined) {\n      howMuch = 0;\n    }\n\n    return this.input[this.idx + howMuch];\n  };\n\n  RegExpParser.prototype.popChar = function () {\n    var nextChar = this.peekChar(0);\n    this.consumeChar();\n    return nextChar;\n  };\n\n  RegExpParser.prototype.consumeChar = function (char) {\n    if (char !== undefined && this.input[this.idx] !== char) {\n      throw Error(\"Expected: '\" + char + \"' but found: '\" + this.input[this.idx] + \"' at offset: \" + this.idx);\n    }\n\n    if (this.idx >= this.input.length) {\n      throw Error(\"Unexpected end of input\");\n    }\n\n    this.idx++;\n  };\n\n  RegExpParser.prototype.loc = function (begin) {\n    return {\n      begin: begin,\n      end: this.idx\n    };\n  }; // consts and utilities\n\n\n  var hexDigitPattern = /[0-9a-fA-F]/;\n  var decimalPattern = /[0-9]/;\n  var decimalPatternNoZero = /[1-9]/;\n\n  function cc(char) {\n    return char.charCodeAt(0);\n  }\n\n  function insertToSet(item, set) {\n    if (item.length !== undefined) {\n      item.forEach(function (subItem) {\n        set.push(subItem);\n      });\n    } else {\n      set.push(item);\n    }\n  }\n\n  function addFlag(flagObj, flagKey) {\n    if (flagObj[flagKey] === true) {\n      throw \"duplicate flag \" + flagKey;\n    }\n\n    flagObj[flagKey] = true;\n  }\n\n  function ASSERT_EXISTS(obj) {\n    // istanbul ignore next\n    if (obj === undefined) {\n      throw Error(\"Internal Error - Should never get here!\");\n    }\n  } // istanbul ignore next\n\n\n  function ASSERT_NEVER_REACH_HERE() {\n    throw Error(\"Internal Error - Should never get here!\");\n  }\n\n  var i;\n  var digitsCharCodes = [];\n\n  for (i = cc(\"0\"); i <= cc(\"9\"); i++) {\n    digitsCharCodes.push(i);\n  }\n\n  var wordCharCodes = [cc(\"_\")].concat(digitsCharCodes);\n\n  for (i = cc(\"a\"); i <= cc(\"z\"); i++) {\n    wordCharCodes.push(i);\n  }\n\n  for (i = cc(\"A\"); i <= cc(\"Z\"); i++) {\n    wordCharCodes.push(i);\n  } // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/RegExp#character-classes\n\n\n  var whitespaceCodes = [cc(\" \"), cc(\"\\f\"), cc(\"\\n\"), cc(\"\\r\"), cc(\"\\t\"), cc(\"\\v\"), cc(\"\\t\"), cc(\"\\u00a0\"), cc(\"\\u1680\"), cc(\"\\u2000\"), cc(\"\\u2001\"), cc(\"\\u2002\"), cc(\"\\u2003\"), cc(\"\\u2004\"), cc(\"\\u2005\"), cc(\"\\u2006\"), cc(\"\\u2007\"), cc(\"\\u2008\"), cc(\"\\u2009\"), cc(\"\\u200a\"), cc(\"\\u2028\"), cc(\"\\u2029\"), cc(\"\\u202f\"), cc(\"\\u205f\"), cc(\"\\u3000\"), cc(\"\\ufeff\")];\n\n  function BaseRegExpVisitor() {}\n\n  BaseRegExpVisitor.prototype.visitChildren = function (node) {\n    for (var key in node) {\n      var child = node[key];\n      /* istanbul ignore else */\n\n      if (node.hasOwnProperty(key)) {\n        if (child.type !== undefined) {\n          this.visit(child);\n        } else if (Array.isArray(child)) {\n          child.forEach(function (subChild) {\n            this.visit(subChild);\n          }, this);\n        }\n      }\n    }\n  };\n\n  BaseRegExpVisitor.prototype.visit = function (node) {\n    switch (node.type) {\n      case \"Pattern\":\n        this.visitPattern(node);\n        break;\n\n      case \"Flags\":\n        this.visitFlags(node);\n        break;\n\n      case \"Disjunction\":\n        this.visitDisjunction(node);\n        break;\n\n      case \"Alternative\":\n        this.visitAlternative(node);\n        break;\n\n      case \"StartAnchor\":\n        this.visitStartAnchor(node);\n        break;\n\n      case \"EndAnchor\":\n        this.visitEndAnchor(node);\n        break;\n\n      case \"WordBoundary\":\n        this.visitWordBoundary(node);\n        break;\n\n      case \"NonWordBoundary\":\n        this.visitNonWordBoundary(node);\n        break;\n\n      case \"Lookahead\":\n        this.visitLookahead(node);\n        break;\n\n      case \"NegativeLookahead\":\n        this.visitNegativeLookahead(node);\n        break;\n\n      case \"Character\":\n        this.visitCharacter(node);\n        break;\n\n      case \"Set\":\n        this.visitSet(node);\n        break;\n\n      case \"Group\":\n        this.visitGroup(node);\n        break;\n\n      case \"GroupBackReference\":\n        this.visitGroupBackReference(node);\n        break;\n\n      case \"Quantifier\":\n        this.visitQuantifier(node);\n        break;\n    }\n\n    this.visitChildren(node);\n  };\n\n  BaseRegExpVisitor.prototype.visitPattern = function (node) {};\n\n  BaseRegExpVisitor.prototype.visitFlags = function (node) {};\n\n  BaseRegExpVisitor.prototype.visitDisjunction = function (node) {};\n\n  BaseRegExpVisitor.prototype.visitAlternative = function (node) {}; // Assertion\n\n\n  BaseRegExpVisitor.prototype.visitStartAnchor = function (node) {};\n\n  BaseRegExpVisitor.prototype.visitEndAnchor = function (node) {};\n\n  BaseRegExpVisitor.prototype.visitWordBoundary = function (node) {};\n\n  BaseRegExpVisitor.prototype.visitNonWordBoundary = function (node) {};\n\n  BaseRegExpVisitor.prototype.visitLookahead = function (node) {};\n\n  BaseRegExpVisitor.prototype.visitNegativeLookahead = function (node) {}; // atoms\n\n\n  BaseRegExpVisitor.prototype.visitCharacter = function (node) {};\n\n  BaseRegExpVisitor.prototype.visitSet = function (node) {};\n\n  BaseRegExpVisitor.prototype.visitGroup = function (node) {};\n\n  BaseRegExpVisitor.prototype.visitGroupBackReference = function (node) {};\n\n  BaseRegExpVisitor.prototype.visitQuantifier = function (node) {};\n\n  return {\n    RegExpParser: RegExpParser,\n    BaseRegExpVisitor: BaseRegExpVisitor,\n    VERSION: \"0.5.0\"\n  };\n});","map":{"version":3,"sources":["/home/magoo/projects/keyrier-json/node_modules/regexp-to-ast/lib/regexp-to-ast.js"],"names":["root","factory","define","amd","module","exports","regexpToAst","self","RegExpParser","prototype","saveState","idx","input","groupIdx","restoreState","newState","pattern","consumeChar","value","disjunction","flags","type","loc","begin","end","length","global","ignoreCase","multiLine","unicode","sticky","isRegExpFlag","popChar","addFlag","Error","substring","alts","push","alternative","peekChar","terms","isTerm","term","isAssertion","assertion","atom","ASSERT_EXISTS","ASSERT_NEVER_REACH_HERE","quantifier","isBacktracking","range","atLeast","atMost","Infinity","integerIncludingZero","isDigit","undefined","greedy","dotAll","atomEscape","characterClass","group","isPatternCharacter","patternCharacter","isQuantifier","complement","cc","decimalEscapeAtom","characterClassEscape","controlEscapeAtom","controlLetterEscapeAtom","nulCharacterAtom","hexEscapeSequenceAtom","regExpUnicodeEscapeSequenceAtom","identityEscapeAtom","positiveInteger","set","digitsCharCodes","whitespaceCodes","wordCharCodes","escapeCode","letter","test","letterCode","toUpperCase","charCodeAt","parseHexDigits","escapedChar","classPatternCharacterAtom","nextChar","isClassAtom","from","classAtom","isFromSingleChar","isRangeDash","to","isToSingleChar","insertToSet","classEscape","capturing","groupAst","number","decimalPatternNoZero","decimalPattern","parseInt","howMuch","isAtom","prevState","e","howMany","hexString","i","hexChar","hexDigitPattern","charCode","char","item","forEach","subItem","flagObj","flagKey","obj","concat","BaseRegExpVisitor","visitChildren","node","key","child","hasOwnProperty","visit","Array","isArray","subChild","visitPattern","visitFlags","visitDisjunction","visitAlternative","visitStartAnchor","visitEndAnchor","visitWordBoundary","visitNonWordBoundary","visitLookahead","visitNegativeLookahead","visitCharacter","visitSet","visitGroup","visitGroupBackReference","visitQuantifier","VERSION"],"mappings":"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","sourcesContent":[";(function(root, factory) {\n    // istanbul ignore next\n    if (typeof define === \"function\" && define.amd) {\n        // istanbul ignore next\n        define([], factory)\n    } else if (typeof module === \"object\" && module.exports) {\n        module.exports = factory()\n    } else {\n        // istanbul ignore next\n        root.regexpToAst = factory()\n    }\n})(\n    typeof self !== \"undefined\"\n        ? // istanbul ignore next\n          self\n        : this,\n    function() {\n        // references\n        // https://hackernoon.com/the-madness-of-parsing-real-world-javascript-regexps-d9ee336df983\n        // https://www.ecma-international.org/ecma-262/8.0/index.html#prod-Pattern\n        function RegExpParser() {}\n\n        RegExpParser.prototype.saveState = function() {\n            return {\n                idx: this.idx,\n                input: this.input,\n                groupIdx: this.groupIdx\n            }\n        }\n\n        RegExpParser.prototype.restoreState = function(newState) {\n            this.idx = newState.idx\n            this.input = newState.input\n            this.groupIdx = newState.groupIdx\n        }\n\n        RegExpParser.prototype.pattern = function(input) {\n            // parser state\n            this.idx = 0\n            this.input = input\n            this.groupIdx = 0\n\n            this.consumeChar(\"/\")\n            var value = this.disjunction()\n            this.consumeChar(\"/\")\n\n            var flags = {\n                type: \"Flags\",\n                loc: { begin: this.idx, end: input.length },\n                global: false,\n                ignoreCase: false,\n                multiLine: false,\n                unicode: false,\n                sticky: false\n            }\n\n            while (this.isRegExpFlag()) {\n                switch (this.popChar()) {\n                    case \"g\":\n                        addFlag(flags, \"global\")\n                        break\n                    case \"i\":\n                        addFlag(flags, \"ignoreCase\")\n                        break\n                    case \"m\":\n                        addFlag(flags, \"multiLine\")\n                        break\n                    case \"u\":\n                        addFlag(flags, \"unicode\")\n                        break\n                    case \"y\":\n                        addFlag(flags, \"sticky\")\n                        break\n                }\n            }\n\n            if (this.idx !== this.input.length) {\n                throw Error(\n                    \"Redundant input: \" + this.input.substring(this.idx)\n                )\n            }\n            return {\n                type: \"Pattern\",\n                flags: flags,\n                value: value,\n                loc: this.loc(0)\n            }\n        }\n\n        RegExpParser.prototype.disjunction = function() {\n            var alts = []\n            var begin = this.idx\n\n            alts.push(this.alternative())\n\n            while (this.peekChar() === \"|\") {\n                this.consumeChar(\"|\")\n                alts.push(this.alternative())\n            }\n\n            return { type: \"Disjunction\", value: alts, loc: this.loc(begin) }\n        }\n\n        RegExpParser.prototype.alternative = function() {\n            var terms = []\n            var begin = this.idx\n\n            while (this.isTerm()) {\n                terms.push(this.term())\n            }\n\n            return { type: \"Alternative\", value: terms, loc: this.loc(begin) }\n        }\n\n        RegExpParser.prototype.term = function() {\n            if (this.isAssertion()) {\n                return this.assertion()\n            } else {\n                return this.atom()\n            }\n        }\n\n        RegExpParser.prototype.assertion = function() {\n            var begin = this.idx\n            switch (this.popChar()) {\n                case \"^\":\n                    return {\n                        type: \"StartAnchor\",\n                        loc: this.loc(begin)\n                    }\n                case \"$\":\n                    return { type: \"EndAnchor\", loc: this.loc(begin) }\n                // '\\b' or '\\B'\n                case \"\\\\\":\n                    switch (this.popChar()) {\n                        case \"b\":\n                            return {\n                                type: \"WordBoundary\",\n                                loc: this.loc(begin)\n                            }\n                        case \"B\":\n                            return {\n                                type: \"NonWordBoundary\",\n                                loc: this.loc(begin)\n                            }\n                    }\n                    // istanbul ignore next\n                    throw Error(\"Invalid Assertion Escape\")\n                // '(?=' or '(?!'\n                case \"(\":\n                    this.consumeChar(\"?\")\n\n                    var type\n                    switch (this.popChar()) {\n                        case \"=\":\n                            type = \"Lookahead\"\n                            break\n                        case \"!\":\n                            type = \"NegativeLookahead\"\n                            break\n                    }\n                    ASSERT_EXISTS(type)\n\n                    var disjunction = this.disjunction()\n\n                    this.consumeChar(\")\")\n\n                    return {\n                        type: type,\n                        value: disjunction,\n                        loc: this.loc(begin)\n                    }\n            }\n            // istanbul ignore next\n            ASSERT_NEVER_REACH_HERE()\n        }\n\n        RegExpParser.prototype.quantifier = function(isBacktracking) {\n            var range\n            var begin = this.idx\n            switch (this.popChar()) {\n                case \"*\":\n                    range = {\n                        atLeast: 0,\n                        atMost: Infinity\n                    }\n                    break\n                case \"+\":\n                    range = {\n                        atLeast: 1,\n                        atMost: Infinity\n                    }\n                    break\n                case \"?\":\n                    range = {\n                        atLeast: 0,\n                        atMost: 1\n                    }\n                    break\n                case \"{\":\n                    var atLeast = this.integerIncludingZero()\n                    switch (this.popChar()) {\n                        case \"}\":\n                            range = {\n                                atLeast: atLeast,\n                                atMost: atLeast\n                            }\n                            break\n                        case \",\":\n                            var atMost\n                            if (this.isDigit()) {\n                                atMost = this.integerIncludingZero()\n                                range = {\n                                    atLeast: atLeast,\n                                    atMost: atMost\n                                }\n                            } else {\n                                range = {\n                                    atLeast: atLeast,\n                                    atMost: Infinity\n                                }\n                            }\n                            this.consumeChar(\"}\")\n                            break\n                    }\n                    // throwing exceptions from \"ASSERT_EXISTS\" during backtracking\n                    // causes severe performance degradations\n                    if (isBacktracking === true && range === undefined) {\n                        return undefined\n                    }\n                    ASSERT_EXISTS(range)\n                    break\n            }\n\n            // throwing exceptions from \"ASSERT_EXISTS\" during backtracking\n            // causes severe performance degradations\n            if (isBacktracking === true && range === undefined) {\n                return undefined\n            }\n\n            ASSERT_EXISTS(range)\n\n            if (this.peekChar(0) === \"?\") {\n                this.consumeChar(\"?\")\n                range.greedy = false\n            } else {\n                range.greedy = true\n            }\n\n            range.type = \"Quantifier\"\n            range.loc = this.loc(begin)\n            return range\n        }\n\n        RegExpParser.prototype.atom = function() {\n            var atom\n            var begin = this.idx\n            switch (this.peekChar()) {\n                case \".\":\n                    atom = this.dotAll()\n                    break\n                case \"\\\\\":\n                    atom = this.atomEscape()\n                    break\n                case \"[\":\n                    atom = this.characterClass()\n                    break\n                case \"(\":\n                    atom = this.group()\n                    break\n            }\n\n            if (atom === undefined && this.isPatternCharacter()) {\n                atom = this.patternCharacter()\n            }\n\n            ASSERT_EXISTS(atom)\n\n            atom.loc = this.loc(begin)\n\n            if (this.isQuantifier()) {\n                atom.quantifier = this.quantifier()\n            }\n\n            return atom\n        }\n\n        RegExpParser.prototype.dotAll = function() {\n            this.consumeChar(\".\")\n            return {\n                type: \"Set\",\n                complement: true,\n                value: [cc(\"\\n\"), cc(\"\\r\"), cc(\"\\u2028\"), cc(\"\\u2029\")]\n            }\n        }\n\n        RegExpParser.prototype.atomEscape = function() {\n            this.consumeChar(\"\\\\\")\n\n            switch (this.peekChar()) {\n                case \"1\":\n                case \"2\":\n                case \"3\":\n                case \"4\":\n                case \"5\":\n                case \"6\":\n                case \"7\":\n                case \"8\":\n                case \"9\":\n                    return this.decimalEscapeAtom()\n                case \"d\":\n                case \"D\":\n                case \"s\":\n                case \"S\":\n                case \"w\":\n                case \"W\":\n                    return this.characterClassEscape()\n                case \"f\":\n                case \"n\":\n                case \"r\":\n                case \"t\":\n                case \"v\":\n                    return this.controlEscapeAtom()\n                case \"c\":\n                    return this.controlLetterEscapeAtom()\n                case \"0\":\n                    return this.nulCharacterAtom()\n                case \"x\":\n                    return this.hexEscapeSequenceAtom()\n                case \"u\":\n                    return this.regExpUnicodeEscapeSequenceAtom()\n                default:\n                    return this.identityEscapeAtom()\n            }\n        }\n\n        RegExpParser.prototype.decimalEscapeAtom = function() {\n            var value = this.positiveInteger()\n\n            return { type: \"GroupBackReference\", value: value }\n        }\n\n        RegExpParser.prototype.characterClassEscape = function() {\n            var set\n            var complement = false\n            switch (this.popChar()) {\n                case \"d\":\n                    set = digitsCharCodes\n                    break\n                case \"D\":\n                    set = digitsCharCodes\n                    complement = true\n                    break\n                case \"s\":\n                    set = whitespaceCodes\n                    break\n                case \"S\":\n                    set = whitespaceCodes\n                    complement = true\n                    break\n                case \"w\":\n                    set = wordCharCodes\n                    break\n                case \"W\":\n                    set = wordCharCodes\n                    complement = true\n                    break\n            }\n\n            ASSERT_EXISTS(set)\n\n            return { type: \"Set\", value: set, complement: complement }\n        }\n\n        RegExpParser.prototype.controlEscapeAtom = function() {\n            var escapeCode\n            switch (this.popChar()) {\n                case \"f\":\n                    escapeCode = cc(\"\\f\")\n                    break\n                case \"n\":\n                    escapeCode = cc(\"\\n\")\n                    break\n                case \"r\":\n                    escapeCode = cc(\"\\r\")\n                    break\n                case \"t\":\n                    escapeCode = cc(\"\\t\")\n                    break\n                case \"v\":\n                    escapeCode = cc(\"\\v\")\n                    break\n            }\n            ASSERT_EXISTS(escapeCode)\n\n            return { type: \"Character\", value: escapeCode }\n        }\n\n        RegExpParser.prototype.controlLetterEscapeAtom = function() {\n            this.consumeChar(\"c\")\n            var letter = this.popChar()\n            if (/[a-zA-Z]/.test(letter) === false) {\n                throw Error(\"Invalid \")\n            }\n\n            var letterCode = letter.toUpperCase().charCodeAt(0) - 64\n            return { type: \"Character\", value: letterCode }\n        }\n\n        RegExpParser.prototype.nulCharacterAtom = function() {\n            // TODO implement '[lookahead âˆ‰ DecimalDigit]'\n            // TODO: for the deprecated octal escape sequence\n            this.consumeChar(\"0\")\n            return { type: \"Character\", value: cc(\"\\0\") }\n        }\n\n        RegExpParser.prototype.hexEscapeSequenceAtom = function() {\n            this.consumeChar(\"x\")\n            return this.parseHexDigits(2)\n        }\n\n        RegExpParser.prototype.regExpUnicodeEscapeSequenceAtom = function() {\n            this.consumeChar(\"u\")\n            return this.parseHexDigits(4)\n        }\n\n        RegExpParser.prototype.identityEscapeAtom = function() {\n            // TODO: implement \"SourceCharacter but not UnicodeIDContinue\"\n            // // http://unicode.org/reports/tr31/#Specific_Character_Adjustments\n            var escapedChar = this.popChar()\n            return { type: \"Character\", value: cc(escapedChar) }\n        }\n\n        RegExpParser.prototype.classPatternCharacterAtom = function() {\n            switch (this.peekChar()) {\n                // istanbul ignore next\n                case \"\\n\":\n                // istanbul ignore next\n                case \"\\r\":\n                // istanbul ignore next\n                case \"\\u2028\":\n                // istanbul ignore next\n                case \"\\u2029\":\n                // istanbul ignore next\n                case \"\\\\\":\n                // istanbul ignore next\n                case \"]\":\n                    throw Error(\"TBD\")\n                default:\n                    var nextChar = this.popChar()\n                    return { type: \"Character\", value: cc(nextChar) }\n            }\n        }\n\n        RegExpParser.prototype.characterClass = function() {\n            var set = []\n            var complement = false\n            this.consumeChar(\"[\")\n            if (this.peekChar(0) === \"^\") {\n                this.consumeChar(\"^\")\n                complement = true\n            }\n\n            while (this.isClassAtom()) {\n                var from = this.classAtom()\n                var isFromSingleChar = from.type === \"Character\"\n                if (isFromSingleChar && this.isRangeDash()) {\n                    this.consumeChar(\"-\")\n                    var to = this.classAtom()\n                    var isToSingleChar = to.type === \"Character\"\n\n                    // a range can only be used when both sides are single characters\n                    if (isToSingleChar) {\n                        if (to.value < from.value) {\n                            throw Error(\"Range out of order in character class\")\n                        }\n                        set.push({ from: from.value, to: to.value })\n                    } else {\n                        // literal dash\n                        insertToSet(from.value, set)\n                        set.push(cc(\"-\"))\n                        insertToSet(to.value, set)\n                    }\n                } else {\n                    insertToSet(from.value, set)\n                }\n            }\n\n            this.consumeChar(\"]\")\n\n            return { type: \"Set\", complement: complement, value: set }\n        }\n\n        RegExpParser.prototype.classAtom = function() {\n            switch (this.peekChar()) {\n                // istanbul ignore next\n                case \"]\":\n                // istanbul ignore next\n                case \"\\n\":\n                // istanbul ignore next\n                case \"\\r\":\n                // istanbul ignore next\n                case \"\\u2028\":\n                // istanbul ignore next\n                case \"\\u2029\":\n                    throw Error(\"TBD\")\n                case \"\\\\\":\n                    return this.classEscape()\n                default:\n                    return this.classPatternCharacterAtom()\n            }\n        }\n\n        RegExpParser.prototype.classEscape = function() {\n            this.consumeChar(\"\\\\\")\n            switch (this.peekChar()) {\n                // Matches a backspace.\n                // (Not to be confused with \\b word boundary outside characterClass)\n                case \"b\":\n                    this.consumeChar(\"b\")\n                    return { type: \"Character\", value: cc(\"\\u0008\") }\n                case \"d\":\n                case \"D\":\n                case \"s\":\n                case \"S\":\n                case \"w\":\n                case \"W\":\n                    return this.characterClassEscape()\n                case \"f\":\n                case \"n\":\n                case \"r\":\n                case \"t\":\n                case \"v\":\n                    return this.controlEscapeAtom()\n                case \"c\":\n                    return this.controlLetterEscapeAtom()\n                case \"0\":\n                    return this.nulCharacterAtom()\n                case \"x\":\n                    return this.hexEscapeSequenceAtom()\n                case \"u\":\n                    return this.regExpUnicodeEscapeSequenceAtom()\n                default:\n                    return this.identityEscapeAtom()\n            }\n        }\n\n        RegExpParser.prototype.group = function() {\n            var capturing = true\n            this.consumeChar(\"(\")\n            switch (this.peekChar(0)) {\n                case \"?\":\n                    this.consumeChar(\"?\")\n                    this.consumeChar(\":\")\n                    capturing = false\n                    break\n                default:\n                    this.groupIdx++\n                    break\n            }\n            var value = this.disjunction()\n            this.consumeChar(\")\")\n\n            var groupAst = {\n                type: \"Group\",\n                capturing: capturing,\n                value: value\n            }\n\n            if (capturing) {\n                groupAst.idx = this.groupIdx\n            }\n\n            return groupAst\n        }\n\n        RegExpParser.prototype.positiveInteger = function() {\n            var number = this.popChar()\n\n            // istanbul ignore next - can't ever get here due to previous lookahead checks\n            // still implementing this error checking in case this ever changes.\n            if (decimalPatternNoZero.test(number) === false) {\n                throw Error(\"Expecting a positive integer\")\n            }\n\n            while (decimalPattern.test(this.peekChar(0))) {\n                number += this.popChar()\n            }\n\n            return parseInt(number, 10)\n        }\n\n        RegExpParser.prototype.integerIncludingZero = function() {\n            var number = this.popChar()\n            if (decimalPattern.test(number) === false) {\n                throw Error(\"Expecting an integer\")\n            }\n\n            while (decimalPattern.test(this.peekChar(0))) {\n                number += this.popChar()\n            }\n\n            return parseInt(number, 10)\n        }\n\n        RegExpParser.prototype.patternCharacter = function() {\n            var nextChar = this.popChar()\n            switch (nextChar) {\n                // istanbul ignore next\n                case \"\\n\":\n                // istanbul ignore next\n                case \"\\r\":\n                // istanbul ignore next\n                case \"\\u2028\":\n                // istanbul ignore next\n                case \"\\u2029\":\n                // istanbul ignore next\n                case \"^\":\n                // istanbul ignore next\n                case \"$\":\n                // istanbul ignore next\n                case \"\\\\\":\n                // istanbul ignore next\n                case \".\":\n                // istanbul ignore next\n                case \"*\":\n                // istanbul ignore next\n                case \"+\":\n                // istanbul ignore next\n                case \"?\":\n                // istanbul ignore next\n                case \"(\":\n                // istanbul ignore next\n                case \")\":\n                // istanbul ignore next\n                case \"[\":\n                // istanbul ignore next\n                case \"|\":\n                    // istanbul ignore next\n                    throw Error(\"TBD\")\n                default:\n                    return { type: \"Character\", value: cc(nextChar) }\n            }\n        }\n        RegExpParser.prototype.isRegExpFlag = function() {\n            switch (this.peekChar(0)) {\n                case \"g\":\n                case \"i\":\n                case \"m\":\n                case \"u\":\n                case \"y\":\n                    return true\n                default:\n                    return false\n            }\n        }\n\n        RegExpParser.prototype.isRangeDash = function() {\n            return this.peekChar() === \"-\" && this.isClassAtom(1)\n        }\n\n        RegExpParser.prototype.isDigit = function() {\n            return decimalPattern.test(this.peekChar(0))\n        }\n\n        RegExpParser.prototype.isClassAtom = function(howMuch) {\n            if (howMuch === undefined) {\n                howMuch = 0\n            }\n\n            switch (this.peekChar(howMuch)) {\n                case \"]\":\n                case \"\\n\":\n                case \"\\r\":\n                case \"\\u2028\":\n                case \"\\u2029\":\n                    return false\n                default:\n                    return true\n            }\n        }\n\n        RegExpParser.prototype.isTerm = function() {\n            return this.isAtom() || this.isAssertion()\n        }\n\n        RegExpParser.prototype.isAtom = function() {\n            if (this.isPatternCharacter()) {\n                return true\n            }\n\n            switch (this.peekChar(0)) {\n                case \".\":\n                case \"\\\\\": // atomEscape\n                case \"[\": // characterClass\n                // TODO: isAtom must be called before isAssertion - disambiguate\n                case \"(\": // group\n                    return true\n                default:\n                    return false\n            }\n        }\n\n        RegExpParser.prototype.isAssertion = function() {\n            switch (this.peekChar(0)) {\n                case \"^\":\n                case \"$\":\n                    return true\n                // '\\b' or '\\B'\n                case \"\\\\\":\n                    switch (this.peekChar(1)) {\n                        case \"b\":\n                        case \"B\":\n                            return true\n                        default:\n                            return false\n                    }\n                // '(?=' or '(?!'\n                case \"(\":\n                    return (\n                        this.peekChar(1) === \"?\" &&\n                        (this.peekChar(2) === \"=\" || this.peekChar(2) === \"!\")\n                    )\n                default:\n                    return false\n            }\n        }\n\n        RegExpParser.prototype.isQuantifier = function() {\n            var prevState = this.saveState()\n            try {\n                return this.quantifier(true) !== undefined\n            } catch (e) {\n                return false\n            } finally {\n                this.restoreState(prevState)\n            }\n        }\n\n        RegExpParser.prototype.isPatternCharacter = function() {\n            switch (this.peekChar()) {\n                case \"^\":\n                case \"$\":\n                case \"\\\\\":\n                case \".\":\n                case \"*\":\n                case \"+\":\n                case \"?\":\n                case \"(\":\n                case \")\":\n                case \"[\":\n                case \"|\":\n                case \"/\":\n                case \"\\n\":\n                case \"\\r\":\n                case \"\\u2028\":\n                case \"\\u2029\":\n                    return false\n                default:\n                    return true\n            }\n        }\n\n        RegExpParser.prototype.parseHexDigits = function(howMany) {\n            var hexString = \"\"\n            for (var i = 0; i < howMany; i++) {\n                var hexChar = this.popChar()\n                if (hexDigitPattern.test(hexChar) === false) {\n                    throw Error(\"Expecting a HexDecimal digits\")\n                }\n                hexString += hexChar\n            }\n            var charCode = parseInt(hexString, 16)\n            return { type: \"Character\", value: charCode }\n        }\n\n        RegExpParser.prototype.peekChar = function(howMuch) {\n            if (howMuch === undefined) {\n                howMuch = 0\n            }\n            return this.input[this.idx + howMuch]\n        }\n\n        RegExpParser.prototype.popChar = function() {\n            var nextChar = this.peekChar(0)\n            this.consumeChar()\n            return nextChar\n        }\n\n        RegExpParser.prototype.consumeChar = function(char) {\n            if (char !== undefined && this.input[this.idx] !== char) {\n                throw Error(\n                    \"Expected: '\" +\n                        char +\n                        \"' but found: '\" +\n                        this.input[this.idx] +\n                        \"' at offset: \" +\n                        this.idx\n                )\n            }\n\n            if (this.idx >= this.input.length) {\n                throw Error(\"Unexpected end of input\")\n            }\n            this.idx++\n        }\n\n        RegExpParser.prototype.loc = function(begin) {\n            return { begin: begin, end: this.idx }\n        }\n\n        // consts and utilities\n        var hexDigitPattern = /[0-9a-fA-F]/\n        var decimalPattern = /[0-9]/\n        var decimalPatternNoZero = /[1-9]/\n\n        function cc(char) {\n            return char.charCodeAt(0)\n        }\n\n        function insertToSet(item, set) {\n            if (item.length !== undefined) {\n                item.forEach(function(subItem) {\n                    set.push(subItem)\n                })\n            } else {\n                set.push(item)\n            }\n        }\n\n        function addFlag(flagObj, flagKey) {\n            if (flagObj[flagKey] === true) {\n                throw \"duplicate flag \" + flagKey\n            }\n\n            flagObj[flagKey] = true\n        }\n\n        function ASSERT_EXISTS(obj) {\n            // istanbul ignore next\n            if (obj === undefined) {\n                throw Error(\"Internal Error - Should never get here!\")\n            }\n        }\n\n        // istanbul ignore next\n        function ASSERT_NEVER_REACH_HERE() {\n            throw Error(\"Internal Error - Should never get here!\")\n        }\n\n        var i\n        var digitsCharCodes = []\n        for (i = cc(\"0\"); i <= cc(\"9\"); i++) {\n            digitsCharCodes.push(i)\n        }\n\n        var wordCharCodes = [cc(\"_\")].concat(digitsCharCodes)\n        for (i = cc(\"a\"); i <= cc(\"z\"); i++) {\n            wordCharCodes.push(i)\n        }\n\n        for (i = cc(\"A\"); i <= cc(\"Z\"); i++) {\n            wordCharCodes.push(i)\n        }\n\n        // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/RegExp#character-classes\n        var whitespaceCodes = [\n            cc(\" \"),\n            cc(\"\\f\"),\n            cc(\"\\n\"),\n            cc(\"\\r\"),\n            cc(\"\\t\"),\n            cc(\"\\v\"),\n            cc(\"\\t\"),\n            cc(\"\\u00a0\"),\n            cc(\"\\u1680\"),\n            cc(\"\\u2000\"),\n            cc(\"\\u2001\"),\n            cc(\"\\u2002\"),\n            cc(\"\\u2003\"),\n            cc(\"\\u2004\"),\n            cc(\"\\u2005\"),\n            cc(\"\\u2006\"),\n            cc(\"\\u2007\"),\n            cc(\"\\u2008\"),\n            cc(\"\\u2009\"),\n            cc(\"\\u200a\"),\n            cc(\"\\u2028\"),\n            cc(\"\\u2029\"),\n            cc(\"\\u202f\"),\n            cc(\"\\u205f\"),\n            cc(\"\\u3000\"),\n            cc(\"\\ufeff\")\n        ]\n\n        function BaseRegExpVisitor() {}\n\n        BaseRegExpVisitor.prototype.visitChildren = function(node) {\n            for (var key in node) {\n                var child = node[key]\n                /* istanbul ignore else */\n                if (node.hasOwnProperty(key)) {\n                    if (child.type !== undefined) {\n                        this.visit(child)\n                    } else if (Array.isArray(child)) {\n                        child.forEach(function(subChild) {\n                            this.visit(subChild)\n                        }, this)\n                    }\n                }\n            }\n        }\n\n        BaseRegExpVisitor.prototype.visit = function(node) {\n            switch (node.type) {\n                case \"Pattern\":\n                    this.visitPattern(node)\n                    break\n                case \"Flags\":\n                    this.visitFlags(node)\n                    break\n                case \"Disjunction\":\n                    this.visitDisjunction(node)\n                    break\n                case \"Alternative\":\n                    this.visitAlternative(node)\n                    break\n                case \"StartAnchor\":\n                    this.visitStartAnchor(node)\n                    break\n                case \"EndAnchor\":\n                    this.visitEndAnchor(node)\n                    break\n                case \"WordBoundary\":\n                    this.visitWordBoundary(node)\n                    break\n                case \"NonWordBoundary\":\n                    this.visitNonWordBoundary(node)\n                    break\n                case \"Lookahead\":\n                    this.visitLookahead(node)\n                    break\n                case \"NegativeLookahead\":\n                    this.visitNegativeLookahead(node)\n                    break\n                case \"Character\":\n                    this.visitCharacter(node)\n                    break\n                case \"Set\":\n                    this.visitSet(node)\n                    break\n                case \"Group\":\n                    this.visitGroup(node)\n                    break\n                case \"GroupBackReference\":\n                    this.visitGroupBackReference(node)\n                    break\n                case \"Quantifier\":\n                    this.visitQuantifier(node)\n                    break\n            }\n\n            this.visitChildren(node)\n        }\n\n        BaseRegExpVisitor.prototype.visitPattern = function(node) {}\n\n        BaseRegExpVisitor.prototype.visitFlags = function(node) {}\n\n        BaseRegExpVisitor.prototype.visitDisjunction = function(node) {}\n\n        BaseRegExpVisitor.prototype.visitAlternative = function(node) {}\n\n        // Assertion\n        BaseRegExpVisitor.prototype.visitStartAnchor = function(node) {}\n\n        BaseRegExpVisitor.prototype.visitEndAnchor = function(node) {}\n\n        BaseRegExpVisitor.prototype.visitWordBoundary = function(node) {}\n\n        BaseRegExpVisitor.prototype.visitNonWordBoundary = function(node) {}\n\n        BaseRegExpVisitor.prototype.visitLookahead = function(node) {}\n\n        BaseRegExpVisitor.prototype.visitNegativeLookahead = function(node) {}\n\n        // atoms\n        BaseRegExpVisitor.prototype.visitCharacter = function(node) {}\n\n        BaseRegExpVisitor.prototype.visitSet = function(node) {}\n\n        BaseRegExpVisitor.prototype.visitGroup = function(node) {}\n\n        BaseRegExpVisitor.prototype.visitGroupBackReference = function(node) {}\n\n        BaseRegExpVisitor.prototype.visitQuantifier = function(node) {}\n\n        return {\n            RegExpParser: RegExpParser,\n            BaseRegExpVisitor: BaseRegExpVisitor,\n            VERSION: \"0.5.0\"\n        }\n    }\n)\n"]},"metadata":{},"sourceType":"script"}