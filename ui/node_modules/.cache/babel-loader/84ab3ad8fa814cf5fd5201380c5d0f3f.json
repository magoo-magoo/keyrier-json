{"ast":null,"code":"ace.define(\"ace/snippets/haskell\", [\"require\", \"exports\", \"module\"], function (require, exports, module) {\n  \"use strict\";\n\n  exports.snippetText = \"snippet lang\\n\\\n\t{-# LANGUAGE ${1:OverloadedStrings} #-}\\n\\\nsnippet info\\n\\\n\t-- |\\n\\\n\t-- Module      :  ${1:Module.Namespace}\\n\\\n\t-- Copyright   :  ${2:Author} ${3:2011-2012}\\n\\\n\t-- License     :  ${4:BSD3}\\n\\\n\t--\\n\\\n\t-- Maintainer  :  ${5:email@something.com}\\n\\\n\t-- Stability   :  ${6:experimental}\\n\\\n\t-- Portability :  ${7:unknown}\\n\\\n\t--\\n\\\n\t-- ${8:Description}\\n\\\n\t--\\n\\\nsnippet import\\n\\\n\timport           ${1:Data.Text}\\n\\\nsnippet import2\\n\\\n\timport           ${1:Data.Text} (${2:head})\\n\\\nsnippet importq\\n\\\n\timport qualified ${1:Data.Text} as ${2:T}\\n\\\nsnippet inst\\n\\\n\tinstance ${1:Monoid} ${2:Type} where\\n\\\n\t\t${3}\\n\\\nsnippet type\\n\\\n\ttype ${1:Type} = ${2:Type}\\n\\\nsnippet data\\n\\\n\tdata ${1:Type} = ${2:$1} ${3:Int}\\n\\\nsnippet newtype\\n\\\n\tnewtype ${1:Type} = ${2:$1} ${3:Int}\\n\\\nsnippet class\\n\\\n\tclass ${1:Class} a where\\n\\\n\t\t${2}\\n\\\nsnippet module\\n\\\n\tmodule `substitute(substitute(expand('%:r'), '[/\\\\\\\\]','.','g'),'^\\\\%(\\\\l*\\\\.\\\\)\\\\?','','')` (\\n\\\n\t)\twhere\\n\\\n\t`expand('%') =~ 'Main' ? \\\"\\\\n\\\\nmain = do\\\\n  print \\\\\\\"hello world\\\\\\\"\\\" : \\\"\\\"`\\n\\\n\\n\\\nsnippet const\\n\\\n\t${1:name} :: ${2:a}\\n\\\n\t$1 = ${3:undefined}\\n\\\nsnippet fn\\n\\\n\t${1:fn} :: ${2:a} -> ${3:a}\\n\\\n\t$1 ${4} = ${5:undefined}\\n\\\nsnippet fn2\\n\\\n\t${1:fn} :: ${2:a} -> ${3:a} -> ${4:a}\\n\\\n\t$1 ${5} = ${6:undefined}\\n\\\nsnippet ap\\n\\\n\t${1:map} ${2:fn} ${3:list}\\n\\\nsnippet do\\n\\\n\tdo\\n\\\n\t\t\\n\\\nsnippet λ\\n\\\n\t\\\\${1:x} -> ${2}\\n\\\nsnippet \\\\\\n\\\n\t\\\\${1:x} -> ${2}\\n\\\nsnippet <-\\n\\\n\t${1:a} <- ${2:m a}\\n\\\nsnippet ←\\n\\\n\t${1:a} <- ${2:m a}\\n\\\nsnippet ->\\n\\\n\t${1:m a} -> ${2:a}\\n\\\nsnippet →\\n\\\n\t${1:m a} -> ${2:a}\\n\\\nsnippet tup\\n\\\n\t(${1:a}, ${2:b})\\n\\\nsnippet tup2\\n\\\n\t(${1:a}, ${2:b}, ${3:c})\\n\\\nsnippet tup3\\n\\\n\t(${1:a}, ${2:b}, ${3:c}, ${4:d})\\n\\\nsnippet rec\\n\\\n\t${1:Record} { ${2:recFieldA} = ${3:undefined}\\n\\\n\t\t\t\t, ${4:recFieldB} = ${5:undefined}\\n\\\n\t\t\t\t}\\n\\\nsnippet case\\n\\\n\tcase ${1:something} of\\n\\\n\t\t${2} -> ${3}\\n\\\nsnippet let\\n\\\n\tlet ${1} = ${2}\\n\\\n\tin ${3}\\n\\\nsnippet where\\n\\\n\twhere\\n\\\n\t\t${1:fn} = ${2:undefined}\\n\\\n\";\n  exports.scope = \"haskell\";\n});\n\n(function () {\n  ace.require([\"ace/snippets/haskell\"], function (m) {\n    if (typeof module == \"object\" && typeof exports == \"object\" && module) {\n      module.exports = m;\n    }\n  });\n})();","map":{"version":3,"sources":["/home/magoo/projects/keyrier-json/node_modules/ace-builds/src-noconflict/snippets/haskell.js"],"names":["ace","define","require","exports","module","snippetText","scope","m"],"mappings":"AAAAA,GAAG,CAACC,MAAJ,CAAW,sBAAX,EAAkC,CAAC,SAAD,EAAW,SAAX,EAAqB,QAArB,CAAlC,EAAkE,UAASC,OAAT,EAAkBC,OAAlB,EAA2BC,MAA3B,EAAmC;AACrG;;AAEAD,EAAAA,OAAO,CAACE,WAAR,GAAsB;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;CAAtB;AAmFAF,EAAAA,OAAO,CAACG,KAAR,GAAgB,SAAhB;AAEC,CAxFD;;AAwFmB,CAAC,YAAW;AACXN,EAAAA,GAAG,CAACE,OAAJ,CAAY,CAAC,sBAAD,CAAZ,EAAsC,UAASK,CAAT,EAAY;AAC9C,QAAI,OAAOH,MAAP,IAAiB,QAAjB,IAA6B,OAAOD,OAAP,IAAkB,QAA/C,IAA2DC,MAA/D,EAAuE;AACnEA,MAAAA,MAAM,CAACD,OAAP,GAAiBI,CAAjB;AACH;AACJ,GAJD;AAKH,CANE","sourcesContent":["ace.define(\"ace/snippets/haskell\",[\"require\",\"exports\",\"module\"], function(require, exports, module) {\n\"use strict\";\n\nexports.snippetText = \"snippet lang\\n\\\n\t{-# LANGUAGE ${1:OverloadedStrings} #-}\\n\\\nsnippet info\\n\\\n\t-- |\\n\\\n\t-- Module      :  ${1:Module.Namespace}\\n\\\n\t-- Copyright   :  ${2:Author} ${3:2011-2012}\\n\\\n\t-- License     :  ${4:BSD3}\\n\\\n\t--\\n\\\n\t-- Maintainer  :  ${5:email@something.com}\\n\\\n\t-- Stability   :  ${6:experimental}\\n\\\n\t-- Portability :  ${7:unknown}\\n\\\n\t--\\n\\\n\t-- ${8:Description}\\n\\\n\t--\\n\\\nsnippet import\\n\\\n\timport           ${1:Data.Text}\\n\\\nsnippet import2\\n\\\n\timport           ${1:Data.Text} (${2:head})\\n\\\nsnippet importq\\n\\\n\timport qualified ${1:Data.Text} as ${2:T}\\n\\\nsnippet inst\\n\\\n\tinstance ${1:Monoid} ${2:Type} where\\n\\\n\t\t${3}\\n\\\nsnippet type\\n\\\n\ttype ${1:Type} = ${2:Type}\\n\\\nsnippet data\\n\\\n\tdata ${1:Type} = ${2:$1} ${3:Int}\\n\\\nsnippet newtype\\n\\\n\tnewtype ${1:Type} = ${2:$1} ${3:Int}\\n\\\nsnippet class\\n\\\n\tclass ${1:Class} a where\\n\\\n\t\t${2}\\n\\\nsnippet module\\n\\\n\tmodule `substitute(substitute(expand('%:r'), '[/\\\\\\\\]','.','g'),'^\\\\%(\\\\l*\\\\.\\\\)\\\\?','','')` (\\n\\\n\t)\twhere\\n\\\n\t`expand('%') =~ 'Main' ? \\\"\\\\n\\\\nmain = do\\\\n  print \\\\\\\"hello world\\\\\\\"\\\" : \\\"\\\"`\\n\\\n\\n\\\nsnippet const\\n\\\n\t${1:name} :: ${2:a}\\n\\\n\t$1 = ${3:undefined}\\n\\\nsnippet fn\\n\\\n\t${1:fn} :: ${2:a} -> ${3:a}\\n\\\n\t$1 ${4} = ${5:undefined}\\n\\\nsnippet fn2\\n\\\n\t${1:fn} :: ${2:a} -> ${3:a} -> ${4:a}\\n\\\n\t$1 ${5} = ${6:undefined}\\n\\\nsnippet ap\\n\\\n\t${1:map} ${2:fn} ${3:list}\\n\\\nsnippet do\\n\\\n\tdo\\n\\\n\t\t\\n\\\nsnippet λ\\n\\\n\t\\\\${1:x} -> ${2}\\n\\\nsnippet \\\\\\n\\\n\t\\\\${1:x} -> ${2}\\n\\\nsnippet <-\\n\\\n\t${1:a} <- ${2:m a}\\n\\\nsnippet ←\\n\\\n\t${1:a} <- ${2:m a}\\n\\\nsnippet ->\\n\\\n\t${1:m a} -> ${2:a}\\n\\\nsnippet →\\n\\\n\t${1:m a} -> ${2:a}\\n\\\nsnippet tup\\n\\\n\t(${1:a}, ${2:b})\\n\\\nsnippet tup2\\n\\\n\t(${1:a}, ${2:b}, ${3:c})\\n\\\nsnippet tup3\\n\\\n\t(${1:a}, ${2:b}, ${3:c}, ${4:d})\\n\\\nsnippet rec\\n\\\n\t${1:Record} { ${2:recFieldA} = ${3:undefined}\\n\\\n\t\t\t\t, ${4:recFieldB} = ${5:undefined}\\n\\\n\t\t\t\t}\\n\\\nsnippet case\\n\\\n\tcase ${1:something} of\\n\\\n\t\t${2} -> ${3}\\n\\\nsnippet let\\n\\\n\tlet ${1} = ${2}\\n\\\n\tin ${3}\\n\\\nsnippet where\\n\\\n\twhere\\n\\\n\t\t${1:fn} = ${2:undefined}\\n\\\n\";\nexports.scope = \"haskell\";\n\n});                (function() {\n                    ace.require([\"ace/snippets/haskell\"], function(m) {\n                        if (typeof module == \"object\" && typeof exports == \"object\" && module) {\n                            module.exports = m;\n                        }\n                    });\n                })();\n            "]},"metadata":{},"sourceType":"script"}