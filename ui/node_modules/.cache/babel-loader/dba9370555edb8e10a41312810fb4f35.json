{"ast":null,"code":"import e from \"lodash\";\nimport { createToken as r, Lexer as t, CstParser as n } from \"chevrotain\";\n\nvar i = function (e) {\n  if (\"string\" != typeof e) return \"\";\n  var r = a(e);\n  return \"string\" == typeof r ? r : null === r ? \"\" : JSON.stringify(r, null, 2);\n},\n    a = function (e) {\n  if (\"string\" != typeof e || \"\" === e.trim()) return null;\n  var r = e.replace(/\\\\n/g, \"\\\\n\").replace(/\\\\'/g, \"\\\\'\").replace(/\\\\\"/g, '\\\\\"').replace(/\\\\&/g, \"\\\\&\").replace(/\\\\r/g, \"\\\\r\").replace(/\\\\t/g, \"\\\\t\").replace(/\\\\b/g, \"\\\\b\").replace(/\\\\f/g, \"\\\\f\");\n\n  try {\n    return JSON.parse(r);\n  } catch (r) {\n    return e;\n  }\n},\n    u = function e(r) {\n  return Array.isArray(r) ? r.map(function (r) {\n    return e(r);\n  }).join(\",\") : \"object\" == typeof r ? JSON.stringify(r) : null != r ? r.toString() : \"\";\n},\n    o = function (e, r) {\n  return \"string\" != typeof e ? null : e.length <= r ? e : e.substring(0, r) + \"...\";\n},\n    s = function (e, r) {\n  return !(!e || !r || !e.toLocaleLowerCase().includes(r.toLocaleLowerCase()));\n},\n    l = [\"B\", \"kB\", \"MB\", \"GB\"],\n    c = function (e) {\n  if (!Number.isFinite(e)) throw new TypeError(\"Expected a finite number, got \" + typeof e + \": \" + e);\n  var r = e < 0,\n      t = r ? \"-\" : \"\";\n  if (r && (e = -e), e < 1) return t + e.toString() + \" B\";\n  var n = Math.min(Math.floor(Math.log10(e) / 3), l.length - 1);\n  return t + (e = Number((e / Math.pow(1024, n)).toPrecision(3))).toString() + \" \" + l[n];\n};\n\nfunction f(e, r) {\n  e.prototype = Object.create(r.prototype), e.prototype.constructor = e, e.__proto__ = r;\n}\n\nvar p = new RegExp(\"(\\\"[a-zA-Z0-9%\\\\s-&(){}\\\\[\\\\]$\\\\*!\\\\\\\\@/,;:=ë#+-<>?^']*\\\")|('[a-zA-Z0-9%\\\\s-&(){}\\\\[\\\\]$\\\\*!\\\\\\\\@/,;:=ë#+-<>?^\\\"]*')\"),\n    E = r({\n  name: \"Identifier\",\n  pattern: /[a-zA-Z]+[\\w.]*/\n}),\n    v = r({\n  name: \"WhiteSpace\",\n  pattern: /\\s+/,\n  group: t.SKIPPED\n}),\n    m = r({\n  name: \"Select\",\n  pattern: /SELECT/i,\n  longer_alt: E\n}),\n    h = r({\n  name: \"From\",\n  pattern: /FROM/i,\n  longer_alt: E\n}),\n    g = r({\n  name: \"Where\",\n  pattern: /WHERE/i,\n  longer_alt: E\n}),\n    O = r({\n  name: \"Comma\",\n  pattern: /,/\n}),\n    L = r({\n  name: \"Like\",\n  pattern: /like/i,\n  longer_alt: E\n}),\n    S = r({\n  name: \"Limit\",\n  pattern: /limit/i,\n  longer_alt: E\n}),\n    C = r({\n  name: \"Null\",\n  pattern: /NULL/i,\n  longer_alt: E\n}),\n    U = r({\n  name: \"In\",\n  pattern: /in/i,\n  longer_alt: E\n}),\n    d = r({\n  name: \"IsNot\",\n  pattern: /is\\s+not/i,\n  longer_alt: E\n}),\n    A = r({\n  name: \"Is\",\n  pattern: /is/i,\n  longer_alt: E\n}),\n    N = r({\n  name: \"NotLike\",\n  pattern: /NOT\\s+LIKE/i\n}),\n    T = r({\n  name: \"OrderBy\",\n  pattern: /ORDER\\s+BY+/i\n}),\n    y = r({\n  name: \"OrderByDirection\",\n  pattern: /(ASC|DESC)/i,\n  longer_alt: E\n}),\n    M = r({\n  name: \"As\",\n  pattern: /AS/i,\n  longer_alt: E\n}),\n    B = r({\n  name: \"OrAnd\",\n  pattern: /(AND|OR)/i,\n  longer_alt: E\n}),\n    R = r({\n  name: \"Star\",\n  pattern: /\\*/\n}),\n    b = r({\n  name: \"Integer\",\n  pattern: /0|[1-9]\\d*/\n}),\n    w = r({\n  name: \"StringToken\",\n  pattern: p\n}),\n    x = r({\n  name: \"GreaterOrEqualThan\",\n  pattern: />=/\n}),\n    I = r({\n  name: \"GreaterThan\",\n  pattern: />/\n}),\n    k = r({\n  name: \"LessOrEqualThan\",\n  pattern: /<=/\n}),\n    _ = r({\n  name: \"LessThan\",\n  pattern: /</\n}),\n    P = r({\n  name: \"Equal\",\n  pattern: /=/\n}),\n    W = r({\n  name: \"NotEqual\",\n  pattern: /(!=|<>)/\n}),\n    D = r({\n  name: \"OpenParenthesis\",\n  pattern: /\\(/\n}),\n    j = r({\n  name: \"CloseParenthesis\",\n  pattern: /\\)/\n}),\n    q = {\n  WhiteSpace: v,\n  Select: m,\n  From: h,\n  Where: g,\n  Comma: O,\n  Like: L,\n  Limit: S,\n  Null: C,\n  In: U,\n  IsNot: d,\n  Is: A,\n  NotLike: N,\n  OrderBy: T,\n  OrderByDirection: y,\n  As: M,\n  OrAnd: B,\n  Identifier: E,\n  Star: R,\n  Integer: b,\n  StringToken: w,\n  Equal: P,\n  NotEqual: W,\n  GreaterOrEqualThan: x,\n  GreaterThan: I,\n  LessOrEqualThan: k,\n  LessThan: _,\n  OpenParenthesis: D,\n  CloseParenthesis: j\n},\n    F = new t(Object.values(q)),\n    J = function (e) {\n  function r(r) {\n    var t;\n    return (t = e.call(this, q, r) || this).cols = t.RULE(\"cols\", function () {\n      t.OR([{\n        ALT: function () {\n          return t.CONSUME(R, {\n            LABEL: \"value\"\n          });\n        }\n      }, {\n        ALT: function () {\n          t.OR1([{\n            ALT: function () {\n              return t.CONSUME(w, {\n                LABEL: \"value\"\n              });\n            }\n          }, {\n            ALT: function () {\n              return t.CONSUME(E, {\n                LABEL: \"value\"\n              });\n            }\n          }]), t.OPTION(function () {\n            t.CONSUME(M), t.OR2([{\n              ALT: function () {\n                return t.CONSUME1(w, {\n                  LABEL: \"name\"\n                });\n              }\n            }, {\n              ALT: function () {\n                return t.CONSUME1(E, {\n                  LABEL: \"name\"\n                });\n              }\n            }]);\n          });\n        }\n      }]);\n    }), t.projection = t.RULE(\"projection\", function () {\n      t.OR([{\n        ALT: function () {\n          return t.AT_LEAST_ONE_SEP({\n            SEP: O,\n            DEF: function () {\n              t.SUBRULE(t.cols);\n            }\n          });\n        }\n      }]);\n    }), t.selectStatement = t.RULE(\"selectStatement\", function () {\n      t.SUBRULE(t.selectClause), t.SUBRULE(t.fromClause), t.OPTION(function () {\n        t.SUBRULE(t.whereClause);\n      }), t.OPTION2(function () {\n        t.SUBRULE(t.orderByClause);\n      }), t.OPTION3(function () {\n        t.SUBRULE(t.limitClause);\n      });\n    }), t.selectClause = t.RULE(\"selectClause\", function () {\n      t.CONSUME(m), t.SUBRULE(t.projection);\n    }), t.fromClause = t.RULE(\"fromClause\", function () {\n      t.CONSUME(h), t.OR([{\n        ALT: function () {\n          return t.CONSUME(E, {\n            LABEL: \"table\"\n          });\n        }\n      }, {\n        ALT: function () {\n          return t.CONSUME(w, {\n            LABEL: \"table\"\n          });\n        }\n      }]), t.OPTION(function () {\n        return t.CONSUME2(E, {\n          LABEL: \"alias\"\n        });\n      });\n    }), t.whereClause = t.RULE(\"whereClause\", function () {\n      t.CONSUME(g), t.SUBRULE(t.expression);\n    }), t.expression = t.RULE(\"expression\", function () {\n      t.MANY_SEP({\n        SEP: B,\n        DEF: function () {\n          return t.SUBRULE(t.subExpression), B.name;\n        }\n      });\n    }), t.subExpression = t.RULE(\"subExpression\", function () {\n      t.SUBRULE(t.atomicExpression, {\n        LABEL: \"left\"\n      }), t.SUBRULE(t.relationalOperator), t.SUBRULE2(t.atomicExpression, {\n        LABEL: \"right\"\n      });\n    }), t.atomicExpression = t.RULE(\"atomicExpression\", function () {\n      t.OR([{\n        ALT: function () {\n          return t.CONSUME(b);\n        }\n      }, {\n        ALT: function () {\n          return t.CONSUME(C);\n        }\n      }, {\n        ALT: function () {\n          return t.CONSUME(E);\n        }\n      }, {\n        ALT: function () {\n          return t.CONSUME(w);\n        }\n      }, {\n        ALT: function () {\n          t.CONSUME(D), t.MANY_SEP({\n            SEP: O,\n            DEF: function () {\n              t.OR1([{\n                ALT: function () {\n                  return t.CONSUME1(b, {\n                    LABEL: \"in\"\n                  });\n                }\n              }, {\n                ALT: function () {\n                  return t.CONSUME1(w, {\n                    LABEL: \"in\"\n                  });\n                }\n              }]);\n            }\n          }), t.CONSUME(j);\n        }\n      }]);\n    }), t.relationalOperator = t.RULE(\"relationalOperator\", function () {\n      t.OR([{\n        ALT: function () {\n          return t.CONSUME(x);\n        }\n      }, {\n        ALT: function () {\n          return t.CONSUME(I);\n        }\n      }, {\n        ALT: function () {\n          return t.CONSUME(k);\n        }\n      }, {\n        ALT: function () {\n          return t.CONSUME(_);\n        }\n      }, {\n        ALT: function () {\n          return t.CONSUME(P);\n        }\n      }, {\n        ALT: function () {\n          return t.CONSUME(W);\n        }\n      }, {\n        ALT: function () {\n          return t.CONSUME(L);\n        }\n      }, {\n        ALT: function () {\n          return t.CONSUME(N);\n        }\n      }, {\n        ALT: function () {\n          return t.CONSUME(U);\n        }\n      }, {\n        ALT: function () {\n          return t.CONSUME(d);\n        }\n      }, {\n        ALT: function () {\n          return t.CONSUME(A);\n        }\n      }]);\n    }), t.orderByClause = t.RULE(\"orderByClause\", function () {\n      t.CONSUME(T), t.CONSUME(E), t.OPTION({\n        DEF: function () {\n          return t.CONSUME(y);\n        }\n      });\n    }), t.limitClause = t.RULE(\"limitClause\", function () {\n      t.CONSUME(S), t.CONSUME(b);\n    }), t.performSelfAnalysis(), t;\n  }\n\n  return f(r, e), r;\n}(n),\n    G = (new J(), new J()),\n    z = new (function (e) {\n  function r() {\n    var r;\n    return (r = e.call(this) || this).validateVisitor(), r;\n  }\n\n  f(r, e);\n  var t = r.prototype;\n  return t.selectStatement = function (e) {\n    return {\n      fields: this.visit(e.selectClause),\n      source: this.visit(e.fromClause),\n      where: this.visit(e.whereClause),\n      order: this.visit(e.orderByClause),\n      limit: this.visit(e.limitClause)\n    };\n  }, t.selectClause = function (e) {\n    return this.visit(e.projection);\n  }, t.cols = function (e) {\n    var r = e.value[0].image;\n    e.value[0].tokenType === q.StringToken && (r = $(r));\n    var t = e.name && e.name[0] ? e.name[0].image : r;\n    return e.name && e.name[0].tokenType === q.StringToken && (t = $(t)), {\n      name: t,\n      value: r\n    };\n  }, t.projection = function (e) {\n    var r = this,\n        t = e.cols.map(function (e) {\n      return r.visit(e);\n    }),\n        n = [];\n    return t.forEach(function (e) {\n      var r = e.value,\n          t = Z(e.name),\n          i = t.pathArray,\n          a = t.propertyName,\n          u = Z(r);\n      n.push({\n        name: {\n          value: a,\n          values: i\n        },\n        field: {\n          value: u.propertyName,\n          values: u.pathArray\n        }\n      });\n    }), n;\n  }, t.fromClause = function (e) {\n    var r,\n        t = e.table[0].image;\n    e.table[0].tokenType === q.StringToken && (t = $(t));\n    var n = (null == (r = e.alias) ? void 0 : r.length) ? e.alias[0].image : t;\n    return {\n      name: {\n        value: t,\n        values: Z(t).pathArray\n      },\n      alias: {\n        value: n,\n        values: Z(n).pathArray\n      }\n    };\n  }, t.whereClause = function (e) {\n    return {\n      conditions: this.visit(e.expression)\n    };\n  }, t.limitClause = function (e) {\n    return {\n      value: {\n        value: parseInt(e.Integer[0].image)\n      }\n    };\n  }, t.orderByClause = function (e) {\n    var r = Z(e.Identifier[0].image);\n    return {\n      orderings: [{\n        value: {\n          value: r.propertyName,\n          values: r.pathArray\n        },\n        direction: e.OrderByDirection && e.OrderByDirection[0].image\n      }]\n    };\n  }, t.expression = function (e, r) {\n    var t;\n    if (void 0 === r && (r = 0), (null == (t = e.subExpression) ? void 0 : t.length) - r == 1) return this.visit(e.subExpression[r]);\n    var n = this.visit(e.subExpression[r]),\n        i = this.OrAnd(e.OrAnd[r]);\n    return {\n      left: n,\n      right: this.expression(e, ++r),\n      operation: i\n    };\n  }, t.subExpression = function (e) {\n    var r = this.visit(e.left[0]),\n        t = this.visit(e.relationalOperator),\n        n = this.visit(e.right[0]);\n    return {\n      left: {\n        value: r,\n        values: Z(r).pathArray\n      },\n      operation: t,\n      right: {\n        value: n,\n        values: Z(n).pathArray\n      }\n    };\n  }, t.atomicExpression = function (e) {\n    for (var r = 0, t = Object.entries(e); r < t.length; r++) {\n      var n = t[r],\n          i = n[0],\n          a = n[1];\n      if (\"in\" === i) return a.map(function (e) {\n        return e.tokenType === b ? parseInt(e.image) : $(e.image);\n      }).map(function (e) {\n        return {\n          value: e\n        };\n      });\n      if (\"Integer\" === i) return parseInt(a[0].image);\n      if (\"Null\" === i) return null;\n      if (\"Identifier\" === i) return a[0].image;\n      if (\"StringToken\" === i) return $(a[0].image);\n    }\n\n    return null;\n  }, t.relationalOperator = function (e) {\n    return Object.values(e)[0][0].image;\n  }, t.OrAnd = function (e) {\n    return e.image;\n  }, r;\n}(G.getBaseCstVisitorConstructor()))(),\n    Y = function (e) {\n  var r,\n      t = function (e) {\n    var r = F.tokenize(e);\n    if (r.errors.length > 0) throw Error(JSON.stringify(r.errors));\n    return r;\n  }(e);\n\n  if (G.input = t.tokens, r = G.selectStatement(), G.errors.length > 0) throw Error(JSON.stringify(G.errors));\n  return z.visit(r);\n},\n    Z = function (e) {\n  var r = String(e).split(\".\");\n  return {\n    propertyName: r[r.length - 1],\n    pathArray: r\n  };\n},\n    $ = function (e) {\n  return e.substring(1, e.length - 1);\n},\n    K = function (e, r) {\n  try {\n    var t = Y(V(r));\n    if (t.source.name.values && \"data\" !== t.source.name.values[0]) return new SyntaxError(String(t.source.name.values[0]));\n    var n = a(e),\n        i = Q(t, n);\n    return JSON.stringify(i);\n  } catch (e) {\n    return e;\n  }\n},\n    V = function (e) {\n  return e.replace(/--(.*?)(\\n|$)/gm, \"\");\n},\n    H = function (e, r, t) {\n  return r.some(function (e) {\n    return \"*\" === e.field.value;\n  }) ? e : ee(r, e, t);\n},\n    Q = function (r, t) {\n  var n = [].concat(r.source.name.values);\n  n.shift();\n  var i = e.chain(t);\n  n && n.length > 0 && (i = e.chain(i.get(n)));\n  var a,\n      u,\n      o = i.value();\n  return e.isArray(o) ? i.filter(function (e) {\n    return !r.where || !r.where.conditions || X(r.where.conditions.operation, r.where.conditions.left, r.where.conditions.right, e);\n  }).orderBy(r.order ? r.order.orderings.map(function (e) {\n    return e.value.value;\n  }) : void 0, r.order ? r.order.orderings.map(function (e) {\n    return e.direction;\n  }) : void 0).map(function (e) {\n    return H(e, r.fields, r.source);\n  }).take((null == (a = r.limit) || null == (u = a.value) ? void 0 : u.value) ? parseInt(r.limit.value.value.toString()) : 999999999999999).value() : H(o, r.fields, r.source);\n},\n    X = function r(t, n, i, a) {\n  var u = e.get(a, function (e) {\n    if (!e) return [];\n\n    if (\"data\" === e[0]) {\n      var r = [].concat(e);\n      return r.shift(), r;\n    }\n\n    return e;\n  }(null == n ? void 0 : n.values));\n\n  switch (t.toLowerCase()) {\n    case \"or\":\n      return r(n.operation, n.left, n.right, a) || r(i.operation, i.left, i.right, a);\n\n    case \"and\":\n      return r(n.operation, n.left, n.right, a) && r(i.operation, i.left, i.right, a);\n\n    case \"=\":\n    case \"is\":\n      return u === i.value;\n\n    case \"!=\":\n    case \"is not\":\n    case \"<>\":\n      return u !== i.value;\n\n    case \"like\":\n      var o = String(u),\n          s = String(i.value);\n\n      if (s.startsWith(\"%\") && s.endsWith(\"%\")) {\n        if (o.includes(s.substring(1, s.length - 1))) return !0;\n      } else if (s.startsWith(\"%\")) {\n        if (o.endsWith(s.substring(s.indexOf(\"%\") + 1))) return !0;\n      } else if (s.endsWith(\"%\") && o.startsWith(s.substring(0, s.indexOf(\"%\")))) return !0;\n\n      return !1;\n\n    case \"not like\":\n      var l = String(u),\n          c = String(i.value);\n\n      if (c.startsWith(\"%\") && c.endsWith(\"%\")) {\n        if (l.includes(c.substring(1, c.length - 1))) return !1;\n      } else if (c.startsWith(\"%\")) {\n        if (l.endsWith(c.substring(c.indexOf(\"%\") + 1))) return !1;\n      } else if (c.endsWith(\"%\") && l.startsWith(c.substring(0, c.indexOf(\"%\")))) return !1;\n\n      return !0;\n\n    case \">\":\n      return !!i.value && u > i.value;\n\n    case \">=\":\n      return !!i.value && u >= i.value;\n\n    case \"<\":\n      return !!i.value && u < i.value;\n\n    case \"<=\":\n      return !!i.value && u <= i.value;\n\n    case \"in\":\n      return Array.isArray(i.value) && i.value.filter(function (e) {\n        return e.value === u;\n      }).length > 0;\n  }\n\n  return !1;\n},\n    ee = function (r, t, n) {\n  var i = {};\n  return r.forEach(function (r) {\n    var a = e.get(t, r.field.values.filter(function (e) {\n      var r;\n      return e !== (null == (r = n.alias) ? void 0 : r.value);\n    }));\n    i[r.name.value] = a;\n  }), t = i;\n};\n\nexport { s as containsIgnoreCase, u as customToString, i as jsonBeautify, a as jsonParseSafe, Y as parse, c as prettyPrintBytes, K as sqlQuery, o as takeFirst };","map":{"version":3,"sources":["../converters/json.ts","../converters/string.ts","../sql/lexer.ts","../sql/parser.ts","../sql/actions-visitor.ts","../sql.ts"],"names":["jsonBeautify","str","parsed","jsonParseSafe","JSON","stringify","trim","safeStr","replace","parse","error","customToString","obj","Array","isArray","map","e","join","toString","takeFirst","n","length","substring","containsIgnoreCase","part","toLocaleLowerCase","includes","UNITS","prettyPrintBytes","value","Number","isFinite","TypeError","isNegative","prefix","exponent","Math","min","floor","log10","pow","toPrecision","stringTokenRegex","RegExp","Identifier","createToken","name","pattern","WhiteSpace","group","Lexer","SKIPPED","Select","longer_alt","From","Where","Comma","Like","Limit","Null","In","IsNot","Is","NotLike","OrderBy","OrderByDirection","As","OrAnd","Star","Integer","StringToken","GreaterOrEqualThan","GreaterThan","LessOrEqualThan","LessThan","Equal","NotEqual","OpenParenthesis","CloseParenthesis","tokenVocabulary","SelectLexer","Object","values","inputText","lexingResult","tokenize","errors","Error","SelectParser","CstParser","config","_this","cols","RULE","OR","ALT","CONSUME","LABEL","OR1","OPTION","OR2","CONSUME1","projection","AT_LEAST_ONE_SEP","SEP","DEF","SUBRULE","selectStatement","selectClause","fromClause","whereClause","OPTION2","orderByClause","OPTION3","limitClause","CONSUME2","expression","MANY_SEP","subExpression","atomicExpression","relationalOperator","SUBRULE2","performSelfAnalysis","parserInstance","getBaseCstVisitorConstructor","validateVisitor","ctx","this","visit","fields","source","where","order","limit","image","tokenType","convertStringTokenToJsString","_this2","x","forEach","pathArray","namePathArray","propertyName","namePropertyName","splitPropertyPath","field","push","tableName","table","alias","conditions","parseInt","direction","orderings","i","left","operation","right","context","entries","key","token","toAstVisitorInstance","toAst","lexResult","lex","input","tokens","cst","stringPath","String","split","path","newPath","shift","sqlEvaluation","sourceString","queryString","sqlTree","cleanComment","SyntaxError","sourceDataObject","result","executeQuery","v","some","mapObject","fromPath","_","chain","get","filter","compareOperands","orderBy","undefined","take","leftValue","computePath","toLowerCase","leftStr","rightStr","startsWith","endsWith","indexOf","mapped","temp","val"],"mappings":"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","sourcesContent":["export const jsonBeautify = (str: string | undefined) => {\n    if (typeof str !== 'string') {\n        return ''\n    }\n\n    const parsed = jsonParseSafe(str)\n    if (typeof parsed === 'string') {\n        return parsed\n    }\n\n    if (parsed === null) {\n        return ''\n    }\n\n    return JSON.stringify(parsed, null, 2)\n}\n\nexport const jsonParseSafe = (str: string | null) => {\n    if (typeof str !== 'string' || str.trim() === '') {\n        return null\n    }\n\n    const safeStr = str\n        .replace(/\\\\n/g, '\\\\n')\n        .replace(/\\\\'/g, \"\\\\'\")\n        .replace(/\\\\\"/g, '\\\\\"')\n        .replace(/\\\\&/g, '\\\\&')\n        .replace(/\\\\r/g, '\\\\r')\n        .replace(/\\\\t/g, '\\\\t')\n        .replace(/\\\\b/g, '\\\\b')\n        .replace(/\\\\f/g, '\\\\f')\n\n    try {\n        return JSON.parse(safeStr)\n    } catch (error) {\n        return str\n    }\n}\n","export const customToString = (obj: any | null | undefined): string => {\n    if (Array.isArray(obj)) {\n        const array: any[] = obj\n        return array.map(e => customToString(e)).join(',')\n    }\n    if (typeof obj === 'object') {\n        return JSON.stringify(obj)\n    }\n    if (obj !== null && obj !== undefined) {\n        return obj.toString()\n    }\n\n    return ''\n}\n\nexport const takeFirst = (str: string | null | undefined, n: number) => {\n    if (typeof str !== 'string') {\n        return null\n    }\n    if (str.length <= n) {\n        return str\n    }\n    return `${str.substring(0, n)}...`\n}\n\nexport const containsIgnoreCase = (str: string, part: string) => {\n    if (!str || !part) {\n        return false\n    }\n    if (str.toLocaleLowerCase().includes(part.toLocaleLowerCase())) {\n        return true\n    }\n\n    return false\n}\n\nconst UNITS = ['B', 'kB', 'MB', 'GB']\n\nexport const prettyPrintBytes = (value: number) => {\n    if (!Number.isFinite(value)) {\n        throw new TypeError(`Expected a finite number, got ${typeof value}: ${value}`)\n    }\n\n    const isNegative = value < 0\n    const prefix = isNegative ? '-' : ''\n    if (isNegative) {\n        value = -value\n    }\n    if (value < 1) {\n        const numberStr = value.toString()\n        return prefix + numberStr + ' B'\n    }\n    const exponent = Math.min(Math.floor(Math.log10(value) / 3), UNITS.length - 1)\n    value = Number((value / Math.pow(1024, exponent)).toPrecision(3))\n    const numberString = value.toString()\n    const unit = UNITS[exponent]\n    return prefix + numberString + ' ' + unit\n}\n","import { createToken, Lexer } from 'chevrotain'\n\nconst stringTokenCharacterRegexString = 'a-zA-Z0-9%\\\\s-&(){}\\\\[\\\\]$\\\\*!\\\\\\\\@/,;:=ë#+-<>?^'\nconst stringTokenRegex = new RegExp(\n    `(\"[${stringTokenCharacterRegexString}']*\")|('[${stringTokenCharacterRegexString}\"]*')`\n)\n\nexport const Identifier = createToken({ name: 'Identifier', pattern: /[a-zA-Z]+[\\w.]*/ })\nexport const WhiteSpace = createToken({ name: 'WhiteSpace', pattern: /\\s+/, group: Lexer.SKIPPED })\nexport const Select = createToken({ name: 'Select', pattern: /SELECT/i, longer_alt: Identifier })\nexport const From = createToken({ name: 'From', pattern: /FROM/i, longer_alt: Identifier })\nexport const Where = createToken({ name: 'Where', pattern: /WHERE/i, longer_alt: Identifier })\nexport const Comma = createToken({ name: 'Comma', pattern: /,/ })\nexport const Like = createToken({ name: 'Like', pattern: /like/i, longer_alt: Identifier })\nexport const Limit = createToken({ name: 'Limit', pattern: /limit/i, longer_alt: Identifier })\nexport const Null = createToken({ name: 'Null', pattern: /NULL/i, longer_alt: Identifier })\nexport const In = createToken({ name: 'In', pattern: /in/i, longer_alt: Identifier })\nexport const IsNot = createToken({ name: 'IsNot', pattern: /is\\s+not/i, longer_alt: Identifier })\nexport const Is = createToken({ name: 'Is', pattern: /is/i, longer_alt: Identifier })\nexport const NotLike = createToken({ name: 'NotLike', pattern: /NOT\\s+LIKE/i })\nexport const OrderBy = createToken({ name: 'OrderBy', pattern: /ORDER\\s+BY+/i })\nexport const OrderByDirection = createToken({\n    name: 'OrderByDirection',\n    pattern: /(ASC|DESC)/i,\n    longer_alt: Identifier,\n})\nexport const As = createToken({ name: 'As', pattern: /AS/i, longer_alt: Identifier })\nexport const OrAnd = createToken({ name: 'OrAnd', pattern: /(AND|OR)/i, longer_alt: Identifier })\nexport const Star = createToken({ name: 'Star', pattern: /\\*/ })\nexport const Integer = createToken({ name: 'Integer', pattern: /0|[1-9]\\d*/ })\nexport const StringToken = createToken({ name: 'StringToken', pattern: stringTokenRegex })\nexport const GreaterOrEqualThan = createToken({ name: 'GreaterOrEqualThan', pattern: />=/ })\nexport const GreaterThan = createToken({ name: 'GreaterThan', pattern: />/ })\nexport const LessOrEqualThan = createToken({ name: 'LessOrEqualThan', pattern: /<=/ })\nexport const LessThan = createToken({ name: 'LessThan', pattern: /</ })\nexport const Equal = createToken({ name: 'Equal', pattern: /=/ })\nexport const NotEqual = createToken({ name: 'NotEqual', pattern: /(!=|<>)/ })\nexport const OpenParenthesis = createToken({ name: 'OpenParenthesis', pattern: /\\(/ })\nexport const CloseParenthesis = createToken({ name: 'CloseParenthesis', pattern: /\\)/ })\n\nexport const tokenVocabulary = {\n    WhiteSpace,\n    Select,\n    From,\n    Where,\n    Comma,\n    Like,\n    Limit,\n    Null,\n    In,\n    IsNot,\n    Is,\n    NotLike,\n    OrderBy,\n    OrderByDirection,\n    As,\n    OrAnd,\n\n    Identifier,\n\n    Star,\n    Integer,\n    StringToken,\n\n    Equal,\n    NotEqual,\n    GreaterOrEqualThan,\n    GreaterThan,\n    LessOrEqualThan,\n    LessThan,\n\n    OpenParenthesis,\n    CloseParenthesis,\n} as const\n\nexport type Token = keyof typeof tokenVocabulary\n\nconst SelectLexer = new Lexer(Object.values(tokenVocabulary))\n\nexport const lex = (inputText: string) => {\n    const lexingResult = SelectLexer.tokenize(inputText)\n\n    if (lexingResult.errors.length > 0) {\n        throw Error(JSON.stringify(lexingResult.errors))\n    }\n\n    return lexingResult\n}\n","import { CstNode, CstParser } from 'chevrotain'\nimport {\n    As,\n    CloseParenthesis,\n    Comma,\n    Equal,\n    From,\n    GreaterOrEqualThan,\n    GreaterThan,\n    Identifier,\n    In,\n    Integer,\n    Is,\n    IsNot,\n    LessOrEqualThan,\n    LessThan,\n    lex as selectLexer,\n    Like,\n    Limit,\n    NotEqual,\n    NotLike,\n    Null,\n    OpenParenthesis,\n    OrAnd,\n    OrderBy,\n    OrderByDirection,\n    Select,\n    Star,\n    StringToken,\n    tokenVocabulary,\n    Where,\n} from './lexer'\n\nexport const labels = {\n    value: 'value',\n    table: 'table',\n    name: 'name',\n    alias: 'alias',\n    left: 'left',\n    right: 'right',\n    in: 'in',\n} as const\n\nclass SelectParser extends CstParser {\n    public selectStatement: (idxInCallingRule?: number | undefined, ...args: any[]) => CstNode | CstNode[]\n    public fromClause: (idxInCallingRule?: number | undefined, ...args: any[]) => any\n    public selectClause: (idxInCallingRule?: number | undefined, ...args: any[]) => any\n    public whereClause: (idxInCallingRule?: number | undefined, ...args: any[]) => any\n    public relationalOperator: (idxInCallingRule?: number | undefined, ...args: any[]) => any\n    public orderByClause: (idxInCallingRule?: number | undefined, ...args: any[]) => any\n    public limitClause: (idxInCallingRule?: number | undefined, ...args: any[]) => any\n    public atomicExpression: (idxInCallingRule?: number | undefined, ...args: any[]) => any\n    public expression: (idxInCallingRule?: number | undefined, ...args: any[]) => any\n    public subExpression: (idxInCallingRule?: number | undefined, ...args: any[]) => any\n    public projection: (idxInCallingRule?: number | undefined, ...args: any[]) => any\n    public cols: (idxInCallingRule?: number | undefined, ...args: any[]) => any\n    constructor(config?: any) {\n        super(tokenVocabulary, config)\n\n        this.cols = this.RULE('cols', () => {\n            this.OR([\n                { ALT: () => this.CONSUME(Star, { LABEL: labels.value }) },\n                {\n                    ALT: () => {\n                        this.OR1([\n                            {\n                                ALT: () => this.CONSUME(StringToken, { LABEL: labels.value }),\n                            },\n                            {\n                                ALT: () => this.CONSUME(Identifier, { LABEL: labels.value }),\n                            },\n                        ])\n                        this.OPTION(() => {\n                            this.CONSUME(As)\n                            this.OR2([\n                                {\n                                    ALT: () => this.CONSUME1(StringToken, { LABEL: labels.name }),\n                                },\n                                {\n                                    ALT: () => this.CONSUME1(Identifier, { LABEL: labels.name }),\n                                },\n                            ])\n                        })\n                    },\n                },\n            ])\n        })\n\n        this.projection = this.RULE('projection', () => {\n            this.OR([\n                {\n                    ALT: () =>\n                        this.AT_LEAST_ONE_SEP({\n                            SEP: Comma,\n                            DEF: () => {\n                                this.SUBRULE(this.cols)\n                            },\n                        }),\n                },\n            ])\n        })\n\n        this.selectStatement = this.RULE('selectStatement', () => {\n            this.SUBRULE(this.selectClause)\n            this.SUBRULE(this.fromClause)\n            this.OPTION(() => {\n                this.SUBRULE(this.whereClause)\n            })\n            this.OPTION2(() => {\n                this.SUBRULE(this.orderByClause)\n            })\n            this.OPTION3(() => {\n                this.SUBRULE(this.limitClause)\n            })\n        })\n\n        this.selectClause = this.RULE('selectClause', () => {\n            this.CONSUME(Select)\n            this.SUBRULE(this.projection)\n        })\n\n        this.fromClause = this.RULE('fromClause', () => {\n            this.CONSUME(From)\n            this.OR([\n                {\n                    ALT: () => this.CONSUME(Identifier, { LABEL: labels.table }),\n                },\n                {\n                    ALT: () => this.CONSUME(StringToken, { LABEL: labels.table }),\n                },\n            ])\n            this.OPTION(() => this.CONSUME2(Identifier, { LABEL: labels.alias }))\n        })\n\n        this.whereClause = this.RULE('whereClause', () => {\n            this.CONSUME(Where)\n            this.SUBRULE(this.expression)\n        })\n\n        this.expression = this.RULE('expression', () => {\n            this.MANY_SEP({\n                SEP: OrAnd,\n                DEF: () => {\n                    this.SUBRULE(this.subExpression)\n\n                    return OrAnd.name\n                },\n            })\n        })\n\n        this.subExpression = this.RULE('subExpression', () => {\n            this.SUBRULE(this.atomicExpression, { LABEL: labels.left })\n            this.SUBRULE(this.relationalOperator)\n            this.SUBRULE2(this.atomicExpression, { LABEL: labels.right })\n        })\n\n        this.atomicExpression = this.RULE('atomicExpression', () => {\n            this.OR([\n                { ALT: () => this.CONSUME(Integer) },\n                { ALT: () => this.CONSUME(Null) },\n                { ALT: () => this.CONSUME(Identifier) },\n                { ALT: () => this.CONSUME(StringToken) },\n                {\n                    ALT: () => {\n                        this.CONSUME(OpenParenthesis)\n                        this.MANY_SEP({\n                            SEP: Comma,\n                            DEF: () => {\n                                this.OR1([\n                                    {\n                                        ALT: () => this.CONSUME1(Integer, { LABEL: labels.in }),\n                                    },\n                                    {\n                                        ALT: () => this.CONSUME1(StringToken, { LABEL: labels.in }),\n                                    },\n                                ])\n                            },\n                        })\n                        this.CONSUME(CloseParenthesis)\n                    },\n                },\n            ])\n        })\n\n        this.relationalOperator = this.RULE('relationalOperator', () => {\n            this.OR([\n                { ALT: () => this.CONSUME(GreaterOrEqualThan) },\n                { ALT: () => this.CONSUME(GreaterThan) },\n                { ALT: () => this.CONSUME(LessOrEqualThan) },\n                { ALT: () => this.CONSUME(LessThan) },\n                { ALT: () => this.CONSUME(Equal) },\n                { ALT: () => this.CONSUME(NotEqual) },\n                { ALT: () => this.CONSUME(Like) },\n                { ALT: () => this.CONSUME(NotLike) },\n                { ALT: () => this.CONSUME(In) },\n                { ALT: () => this.CONSUME(IsNot) },\n                { ALT: () => this.CONSUME(Is) },\n            ])\n        })\n\n        this.orderByClause = this.RULE('orderByClause', () => {\n            this.CONSUME(OrderBy)\n            this.CONSUME(Identifier)\n            this.OPTION({\n                DEF: () => this.CONSUME(OrderByDirection),\n            })\n        })\n\n        this.limitClause = this.RULE('limitClause', () => {\n            this.CONSUME(Limit)\n            this.CONSUME(Integer)\n        })\n\n        this.performSelfAnalysis()\n    }\n}\n\nconst parserInstance = new SelectParser()\n\nconst parse = (inputText: string) => {\n    const lexResult = selectLexer(inputText)\n\n    parserInstance.input = lexResult.tokens\n\n    parserInstance.selectStatement()\n\n    if (parserInstance.errors.length > 0) {\n        throw Error(parserInstance.errors[0].message)\n    }\n}\n\nexport { parserInstance, SelectParser, parse }\n","import { CstNode, ICstVisitor, IToken } from 'chevrotain'\nimport { Integer, lex, Token, tokenVocabulary } from './lexer'\nimport { SelectParser } from './parser'\nimport { Field, Operand, Order, ordering, From, SQLTree } from './SqlTree'\n\nconst parserInstance = new SelectParser()\nconst BaseSQLVisitor: new (arg?: any) => ICstVisitor<number, any> = parserInstance.getBaseCstVisitorConstructor()\n\nclass SQLToAstVisitor extends BaseSQLVisitor {\n    constructor() {\n        super()\n        this.validateVisitor()\n    }\n\n    public selectStatement(ctx: {\n        selectClause: CstNode | CstNode[]\n        fromClause: CstNode | CstNode[]\n        whereClause: CstNode | CstNode[]\n        orderByClause: CstNode | CstNode[]\n        limitClause: CstNode | CstNode[]\n    }) {\n        const select = this.visit(ctx.selectClause)\n        const from = this.visit(ctx.fromClause)\n        const where = this.visit(ctx.whereClause)\n        const order = this.visit(ctx.orderByClause)\n        const limit = this.visit(ctx.limitClause)\n        return {\n            fields: select,\n            source: from,\n            where,\n            order,\n            limit,\n        } as const\n    }\n\n    public selectClause(ctx: { projection: CstNode | CstNode[] }) {\n        const columns = this.visit(ctx.projection)\n        return columns\n    }\n\n    public cols(ctx: { name: IToken[]; value: IToken[] }) {\n        let value = ctx.value[0].image\n\n        if (ctx.value[0].tokenType === tokenVocabulary.StringToken) {\n            value = convertStringTokenToJsString(value)\n        }\n\n        let name = ctx.name && ctx.name[0] ? ctx.name[0].image : value\n\n        if (ctx.name && ctx.name[0].tokenType === tokenVocabulary.StringToken) {\n            name = convertStringTokenToJsString(name)\n        }\n        return {\n            name,\n            value,\n        }\n    }\n\n    public projection(ctx: { cols: CstNode[] }) {\n        const cols: { value: string; name: string }[] = ctx.cols.map(x => this.visit(x)) as any\n        const fields: Field[] = []\n        cols.forEach(({ name, value }) => {\n            const { pathArray: namePathArray, propertyName: namePropertyName } = splitPropertyPath(name)\n            const { pathArray: fieldPathArray, propertyName: fieldPropertyName } = splitPropertyPath(value)\n            const field: Field = {\n                name: {\n                    value: namePropertyName,\n                    values: namePathArray,\n                },\n                field: {\n                    value: fieldPropertyName,\n                    values: fieldPathArray,\n                },\n            }\n            fields.push(field)\n        })\n        return fields\n    }\n\n    public fromClause(ctx: { table: Array<IToken>; alias: Array<IToken> }): From {\n        let tableName: string = ctx.table[0].image\n        if (ctx.table[0].tokenType === tokenVocabulary.StringToken) {\n            tableName = convertStringTokenToJsString(tableName)\n        }\n        const alias = ctx.alias?.length ? ctx.alias[0].image : tableName\n        return {\n            name: {\n                value: tableName,\n                values: splitPropertyPath(tableName).pathArray,\n            },\n            alias: {\n                value: alias,\n                values: splitPropertyPath(alias).pathArray,\n            },\n        }\n    }\n\n    public whereClause(ctx: { expression: CstNode | CstNode[] }) {\n        const conditions = this.visit(ctx.expression)\n\n        return {\n            conditions,\n        } as const\n    }\n\n    public limitClause(ctx: { Integer: IToken[] }) {\n        const limit = parseInt(ctx.Integer[0].image)\n        return {\n            value: {\n                value: limit,\n            },\n        }\n    }\n    public orderByClause(ctx: { OrderBy: IToken[]; Identifier: IToken[]; OrderByDirection: IToken[] }): Order {\n        const { pathArray, propertyName } = splitPropertyPath(ctx.Identifier[0].image)\n        const direction = ctx.OrderByDirection && (ctx.OrderByDirection[0].image as 'asc' | 'desc')\n\n        const order: ordering = {\n            value: {\n                value: propertyName,\n                values: pathArray,\n            },\n            direction,\n        }\n\n        return {\n            orderings: [order],\n        }\n    }\n\n    public expression(\n        ctx: {\n            subExpression: Array<CstNode | CstNode[]>\n            OrAnd: Array<IToken>\n            right: Array<CstNode | CstNode[]>\n        },\n        i: number = 0\n    ) {\n        if (ctx.subExpression?.length - i === 1) {\n            const left = this.visit(ctx.subExpression[i])\n            return left\n        }\n        const left = this.visit(ctx.subExpression[i])\n\n        const operation = this.OrAnd(ctx.OrAnd[i])\n        const right: Operand = this.expression(ctx, ++i)\n\n        return {\n            left,\n            right,\n            operation,\n        }\n    }\n\n    public subExpression(ctx: {\n        left: Array<CstNode | CstNode[]>\n        relationalOperator: CstNode | CstNode[]\n        right: Array<CstNode | CstNode[]>\n    }) {\n        const left = this.visit(ctx.left[0])\n        const operation = this.visit(ctx.relationalOperator)\n        const right = this.visit(ctx.right[0])\n\n        return {\n            left: { value: left, values: splitPropertyPath(left).pathArray },\n            operation,\n            right: { value: right, values: splitPropertyPath(right).pathArray },\n        }\n    }\n\n    public atomicExpression(context: Record<Token | 'in', Array<IToken>>) {\n        const entries = Object.entries(context) as [keyof typeof context, Array<IToken>][]\n        for (let [key, value] of entries) {\n            if (key === 'in') {\n                return value\n                    .map(x => {\n                        if (x.tokenType === Integer) {\n                            return parseInt(x.image)\n                        }\n                        return convertStringTokenToJsString(x.image)\n                    })\n                    .map(value => ({ value }))\n            }\n            if (key === 'Integer') {\n                return parseInt(value[0].image)\n            }\n            if (key === 'Null') {\n                return null\n            }\n            if (key === 'Identifier') {\n                return value[0].image\n            }\n            if (key === 'StringToken') {\n                return convertStringTokenToJsString(value[0].image)\n            }\n        }\n        return null\n    }\n\n    public relationalOperator(ctx: Record<Token, Array<IToken>>) {\n        const values = Object.values(ctx)\n        return values[0][0].image\n    }\n\n    public OrAnd(token: IToken) {\n        return token.image\n    }\n}\n\nconst toAstVisitorInstance = new SQLToAstVisitor()\n\nconst toAst = (inputText: string) => {\n    const lexResult = lex(inputText)\n\n    parserInstance.input = lexResult.tokens\n    let cst: CstNode[] | CstNode\n\n    cst = parserInstance.selectStatement()\n\n    if (parserInstance.errors.length > 0) {\n        throw Error(JSON.stringify(parserInstance.errors))\n    }\n    const ast = toAstVisitorInstance.visit(cst)\n    return (ast as unknown) as SQLTree\n}\n\nconst splitPropertyPath = (stringPath: string | number) => {\n    const pathArray = String(stringPath).split('.')\n\n    return { propertyName: pathArray[pathArray.length - 1], pathArray }\n}\n\nconst convertStringTokenToJsString = (str: string) => str.substring(1, str.length - 1)\n\nexport { toAst }\n","import _ from 'lodash'\nimport { jsonParseSafe } from './converters/json'\nimport { toAst } from './sql/actions-visitor'\nimport { Field, Operand, From, SQLTree } from './sql/SqlTree'\nexport const computePath = (path: string[] | undefined) => {\n    if (!path) {\n        return []\n    }\n    if (path[0] === 'data') {\n        const newPath = [...path]\n        newPath.shift()\n        return newPath\n    }\n\n    return path\n}\n\nexport const sqlEvaluation = (sourceString: string, queryString: string) => {\n    try {\n        const sqlTree = toAst(cleanComment(queryString))\n        if (sqlTree.source.name.values && sqlTree.source.name.values[0] !== 'data') {\n            return new SyntaxError(String(sqlTree.source.name.values[0]))\n        }\n\n        const sourceDataObject = jsonParseSafe(sourceString)\n\n        const result = executeQuery(sqlTree, sourceDataObject)\n\n        return JSON.stringify(result)\n    } catch (e) {\n        return e as Error\n    }\n}\n\nconst cleanComment = (str: string) => str.replace(/--(.*?)(\\n|$)/gm, '')\n\nconst map = (v: object, fields: Field[], source: From) => {\n    if (fields.some(x => x.field.value === '*')) {\n        return v\n    }\n\n    return mapObject(fields, v, source)\n}\n\nconst executeQuery = (sqlTree: SQLTree, sourceDataObject: object) => {\n    let fromPath: (string | number)[] = [...sqlTree.source.name.values]\n    fromPath.shift()\n\n    let result = _.chain<any>(sourceDataObject)\n\n    if (fromPath && fromPath.length > 0) {\n        result = _.chain<any>(result.get(fromPath))\n    }\n    const value = result.value()\n    if (_.isArray(value)) {\n        return result\n            .filter(v => {\n                if (!sqlTree.where || !sqlTree.where.conditions) {\n                    return true\n                }\n                const leftValue = sqlTree.where.conditions.left\n                const rightValue = sqlTree.where.conditions.right\n                const operation = sqlTree.where.conditions.operation\n\n                return compareOperands(operation, leftValue, rightValue, v)\n            })\n            .orderBy(\n                sqlTree.order ? sqlTree.order.orderings.map(x => x.value.value) : undefined,\n                sqlTree.order ? sqlTree.order.orderings.map(x => x.direction) : undefined\n            )\n            .map(v => map(v, sqlTree.fields, sqlTree.source))\n            .take(sqlTree.limit?.value?.value ? parseInt(sqlTree.limit.value.value.toString()) : 999999999999999)\n            .value()\n    }\n    return map(value, sqlTree.fields, sqlTree.source)\n}\nconst operators = {\n    modulo: '%',\n} as const\nconst compareOperands = (operation: string, left: Operand, right: Operand, value: object): boolean => {\n    const leftValue = _.get(value, computePath(left?.values))\n\n    switch (operation.toLowerCase()) {\n        case 'or':\n            return (\n                compareOperands(left.operation, left.left, left.right, value) ||\n                compareOperands(right.operation, right.left, right.right, value)\n            )\n        case 'and':\n            return (\n                compareOperands(left.operation, left.left, left.right, value) &&\n                compareOperands(right.operation, right.left, right.right, value)\n            )\n\n        case '=':\n        case 'is':\n            return leftValue === right.value\n        case '!=':\n        case 'is not':\n        case '<>':\n            return leftValue !== right.value\n        case 'like': {\n            const leftStr = String(leftValue)\n            const rightStr = String(right.value)\n            if (rightStr.startsWith(operators.modulo) && rightStr.endsWith(operators.modulo)) {\n                if (leftStr.includes(rightStr.substring(1, rightStr.length - 1))) {\n                    return true\n                }\n            } else if (rightStr.startsWith(operators.modulo)) {\n                if (leftStr.endsWith(rightStr.substring(rightStr.indexOf(operators.modulo) + 1))) {\n                    return true\n                }\n            } else if (rightStr.endsWith(operators.modulo)) {\n                if (leftStr.startsWith(rightStr.substring(0, rightStr.indexOf(operators.modulo)))) {\n                    return true\n                }\n            }\n            return false\n        }\n        case 'not like': {\n            const leftStr = String(leftValue)\n            const rightStr = String(right.value)\n            if (rightStr.startsWith(operators.modulo) && rightStr.endsWith(operators.modulo)) {\n                if (leftStr.includes(rightStr.substring(1, rightStr.length - 1))) {\n                    return false\n                }\n            } else if (rightStr.startsWith(operators.modulo)) {\n                if (leftStr.endsWith(rightStr.substring(rightStr.indexOf(operators.modulo) + 1))) {\n                    return false\n                }\n            } else if (rightStr.endsWith(operators.modulo)) {\n                if (leftStr.startsWith(rightStr.substring(0, rightStr.indexOf(operators.modulo)))) {\n                    return false\n                }\n            }\n            return true\n        }\n        case '>':\n            return !!right.value && leftValue > right.value\n        case '>=':\n            return !!right.value && leftValue >= right.value\n        case '<':\n            return !!right.value && leftValue < right.value\n        case '<=':\n            return !!right.value && leftValue <= right.value\n        case 'in':\n            return Array.isArray(right.value) && right.value.filter(x => x.value === leftValue).length > 0\n    }\n    return false\n}\n\nconst mapObject = (fields: Field[], mapped: object, source: From) => {\n    const temp: {\n        [key: string]: any\n    } = {}\n    fields.forEach(field => {\n        const value = _.get(\n            mapped,\n            field.field.values.filter(val => val !== source.alias?.value)\n        )\n        temp[field.name.value] = value\n    })\n    mapped = temp\n    return mapped\n}\n"]},"metadata":{},"sourceType":"module"}